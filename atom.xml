<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小土刀</title>
  <subtitle>Agony is my triumph</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wdxtub.com/"/>
  <updated>2017-02-10T02:20:27.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name>wdxtub</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【不周山之机器学习】习题课 壹 线性代数</title>
    <link href="http://wdxtub.com/2017/02/08/linear-algebra/"/>
    <id>http://wdxtub.com/2017/02/08/linear-algebra/</id>
    <published>2017-02-07T23:19:50.000Z</published>
    <updated>2017-02-10T02:20:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍线性代数中与机器学习相关的重要概念，方便不懂的时候进行查阅。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.02.08: 开始编写</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>线性代数是是代数学的一个分支，主要处理线性关系问题，即数学对象之间的关系是以<strong>一次形式</strong>来表达的。线性关系问题简称线性问题，解线性方程组的问题是最简单的线性问题。</p>
<p>很多实际问题的处理，最后往往归结为线性问题，它比较容易处理。因此，线性代数在许多领域都有着广泛的应用，是一门基本且重要的学科。</p>
<h2 id="向量、行列式、矩阵"><a href="#向量、行列式、矩阵" class="headerlink" title="向量、行列式、矩阵"></a>向量、行列式、矩阵</h2><blockquote>
<p>线性代数中最重要的内容就是行列式和矩阵，虽然表面上看，行列式和矩阵不过是一种符号或速记，但从数学史上来看，优良的数学符号和生动的概念是数学思想产生的动力和钥匙。</p>
</blockquote>
<h3 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量 Vector"></a>向量 Vector</h3><p>向量的可以用列的形式表示，但是为了书写和打印方便，一般会用圆括号括起来，转换为行的形式。如：$\mathbf{v}=(v_1,v_2)$。</p>
<p>若有向量 $\mathbf{v}=(v_1,v_2),\; \mathbf{w}=(w_1, w_2)$ 和常数 $c, d$，则</p>
<ul>
<li>向量相加 $\mathbf{v+w}=(v_1+w_1,v_2+w_2)$</li>
<li>向量数乘 $c\mathbf{v}=(cv_1,cv_2)$</li>
<li>$c\mathbf{v}+d\mathbf{w}$ 是向量 $\mathbf{v}$ 和 $\mathbf{w}$ 的线性组合</li>
<li>$\mathbf{v\cdot w}$ 是向量 $\mathbf{v}$ 和 $\mathbf{w}$ 的内积（点积），值为 $\mathbf{v\cdot w}=\sum v_iw_i$，显然 $\mathbf{v\cdot w}=\mathbf{w\cdot v}$</li>
<li>$\Vert \mathbf{v} \Vert$ 是向量 $\mathbf{v}$ 的长度，$\Vert\mathbf{v}=\sqrt{\mathbf{v\cdot v}}\Vert$</li>
<li>单位向量 $\mathbf{u}$ 的长度为1，$\mathbf{u}=\frac{\mathbf{v}}{\Vert\mathbf{v} \Vert}$ 是与 $\mathbf{v}$ 同方向的单位向量</li>
</ul>
<p>如果 $\mathbf{v}$ 和 $\mathbf{w}$ 是非零向量，则有</p>
<p>$$\frac{\mathbf{v\cdot w}}{\Vert\mathbf{v} \Vert \Vert\mathbf{w} \Vert}=cos\;\theta$$</p>
<p>据此我们可以得到两个重要不等式：</p>
<ul>
<li>$|\mathbf{v\cdot w}| \le \Vert\mathbf{v}\Vert \Vert\mathbf{w} \Vert$</li>
<li>$\Vert\mathbf{v+w}\Vert \le \Vert\mathbf{v}\Vert + \Vert\mathbf{w} \Vert$</li>
</ul>
<p><strong>有关向量的线性表示，下面的说法是等价的：</strong></p>
<ul>
<li>向量 $b$ 能由向量组 $\mathbf{a_1,a_2,\cdots,a_m }$ 线性表示</li>
<li>线性方程组 $x_1\mathbf{a_1}+x_2\mathbf{a_2}+\cdots+x_m\mathbf{a_m}=\mathbf{b}$ 有解</li>
<li>秩相同 $R(\mathbf{a_1,a_2,\cdots,a_m }) = R(\mathbf{a_1,a_2,\cdots,a_m,b})$，因为 $\mathbf{b}$ 可以被向量组 $\mathbf{a_1,a_2,\cdots,a_m }$ 线性表示</li>
</ul>
<p>如果向量组 $A: \mathbf{a_1,a_2,\cdots,a_m }(m \ge 2)$ 线性相关，下面说法等价：</p>
<ul>
<li>向量组 $A$ 至少存在一个向量是其余 $m-1$ 个向量的线性组合</li>
<li>线性方程组 $x_1\mathbf{a_1}+x_2\mathbf{a_2}+\cdots+x_m\mathbf{a_m}=0$ 有非零解</li>
<li>$\mathbf{a_1,a_2,\cdots,a_m }$ 的秩小于向量的个数 $m$，即 $R(\mathbf{a_1,a_2,\cdots,a_m })&lt;m$</li>
</ul>
<p>如果向量组 $A: \mathbf{a_1,a_2,\cdots,a_m }(m \ge 2)$ 线性无关，下面说法等价：</p>
<ul>
<li>线性方程组 $x_1\mathbf{a_1}+x_2\mathbf{a_2}+\cdots+x_m\mathbf{a_m}=0$ 只有零解</li>
<li>$\mathbf{a_1,a_2,\cdots,a_m }$ 的秩等于向量的个数 $m$，即 $R(\mathbf{a_1,a_2,\cdots,a_m })=m$</li>
</ul>
<p>这里我们可以看到向量、方程组和矩阵问题实际上是可以相互转换的。但需要注意<strong>向量组等价，可得矩阵等价</strong>，但<strong>矩阵等价不能得到向量组等价</strong></p>
<h3 id="行列式-Determinant"><a href="#行列式-Determinant" class="headerlink" title="行列式 Determinant"></a>行列式 Determinant</h3><p>行列式最初用于求解线性方程，行列式是否为零可用来判定一个线性方程是否有解。</p>
<p><strong>行列式的三种变换：</strong></p>
<ul>
<li>互换某两行（列），记为 $r_i \leftrightarrow r_j\;(c_i \leftrightarrow c_j)$</li>
<li>提出某一行（列）的公因子，记为 $r_i \div k\;(c_i \div k)$</li>
<li>把某一行（列）的 $k$ 倍加到另一行（列），记为 $r_i+kr_j\;(c_i+kc_j)$</li>
</ul>
<p>计算行列式最常用的一种方法就是利用变换 $r_i+kr_j\;(c_i+kc_j)$ 和 $r_i \leftrightarrow r_j\;(c_i \leftrightarrow c_j)$，把行列式转化为上三角形行列式，从而算得行列式的值。</p>
<p>行列式为零，要么是两行（列）相同，要么是两行（列）成比例。</p>
<p>行列式按某行展开可以按任一行展开，而一行元素乘以另一行对应元素的代数余子式，其和为零。综合起来是：</p>
$$a_{k1}A_{i1}+a_{k2}A_{i2}+ \cdots + a_{kn}A_{in}=\sum_{s=1}^n a_{ks}A_{is}=\begin{cases}D&, k=i\\ 0&,k\ne i\end{cases}$$
<p>另外 $D^T=D$ 也是行列式的性质，这里提一下。</p>
<h3 id="矩阵-Matrix"><a href="#矩阵-Matrix" class="headerlink" title="矩阵 Matrix"></a>矩阵 Matrix</h3><p>若有矩阵 $A$ 和矩阵 $B$，那么</p>
<ul>
<li>两个大小相同的矩阵才可以相加，记为 $A+B$，是对应位置的元素进行相加</li>
<li>如果矩阵 $A$ 有 $n$ 列且矩阵 $B$ 有 $n$ 行，这两个矩阵可以相乘得到 $AB$</li>
</ul>
<p>一个 $m \times n$ 的矩阵与一个 $n\times p$ 的矩阵相乘所需的乘法次数是 $mnp$ 次，一般我们会采用动态规划的方法来对乘法进行优化。</p>
<p>矩阵加法满足：</p>
<ul>
<li>交换率 $A+B=B+A$</li>
<li>分配率 $c(A+B)=cA+cB$</li>
<li>结合律 $A+(B+C)=(A+B)+C$</li>
</ul>
<p>矩阵乘法满足：</p>
<ul>
<li>左分配率 $C(A+B)=CA+CB$</li>
<li>右分配率 $(A+B)C=AC+BC$</li>
<li>结合律 $A(BC)=(AB)C$</li>
</ul>
<p>矩阵 $A$ 可逆当且仅当存在矩阵 $A^{-1}$，使得 $A^{-1}A=I$ 和 $AA^{-1}=I$，其中 $A^{-1}$ 称为 $A$ 的逆矩(inverse)阵。如果 $A$ 不可逆，称 $A$ 为奇异(singular)矩阵。</p>
<p>转置(transpose)是把一个矩阵行与列进行互换，如对于矩阵 $A$ 转置为 $(A^T)_{ij}=A_{ji}$。</p>
<p>对于矩阵 $A$ 和 $B$，$(A+B)^T=A^T+B^T,\;(AB)^T=B^TA^T,\;(A^{-1})^T=(A^T)^{-1}$</p>
<p>如果对于矩阵 $A$ 有 $a_{ij}=a_{ji}$，则称 $A$ 为对称矩阵。对称矩阵 $A$ 可分解为 $A=LDL^T$</p>
<p>对任意矩阵 $R$，$R^TR$ 和 $RR^T$ 都是对称矩阵且它们对角线上元素非负，大多数科学问题都是从一个矩阵 $R$ 开始，以 $R^TR$ 或 $RR^T$ 结束。</p>
<p>对于非零矩阵 $A$，$A^2$ 可以是零矩阵，但 $A^TA$ 不可能是零矩阵。</p>
<p><strong>求解线性方程组是线性代数的核心问题。</strong></p>
<p>求解 $A\mathbf{x}=\mathbf{b}$ 是寻找一个特定组合来产生 $\mathbf{b}$，其中 $\mathbf{A}$ 被称为系数矩阵。这个求解的过程，从另外一个角度来看是寻找多条线（平面或超平面）的交点。</p>
<p>每个超级计算机都会拿求解 $A\mathbf{x}=\mathbf{b}$ 来测试速度，计算机编程中应该直接进行消元或者置换，而不应该采用矩阵相乘来实现，因为矩阵相乘的方式带来更多冗余计算。</p>
<p>$n$ 阶矩阵 $A$，可以认为下列说法是等价的：</p>
<ol>
<li>$\mathbf{A}$ 是满秩矩阵</li>
<li>$\mathbf{A}$ 的标准形是 $E$</li>
<li>$\mathbf{A}$ 可以表达为有限个初等矩阵的乘积</li>
<li>齐次线性方程组 $Ax=0$ 只有零解</li>
<li>非齐次线性方程组 $Ax=b$ 有唯一解</li>
</ol>
<h2 id="向量空间和子空间"><a href="#向量空间和子空间" class="headerlink" title="向量空间和子空间"></a>向量空间和子空间</h2><p>空间 $R^n$ 包含任何含有 $n$ 个实数元素的列向量 $\mathbf{v}$，我们可以把 $R^n$ 中任意向量加在一起，也可以为任何向量乘上一个数字 $c$，得到的结果都在这个空间中。</p>
<ul>
<li>对于一个集合，如果集合中元素对加法和数乘（即向量乘以一个常数）是封闭的，那么这个集合构成一个空间。</li>
<li>只包含一个零向量的空间称为空间 $Z$</li>
</ul>
<p>一个向量空间的子空间(Subspace)满足如下条件：如果 $\mathbf{v}$ 和 $\mathbf{w}$ 都在这个子空间中，则 $\mathbf{v+w}$ 与 $c\mathbf{v}$ 也在这个子空间中，而他们的线性组合 $c\mathbf{v}+d\mathbf{w}$ 也在子空间中。</p>
<ul>
<li>矩阵 $A$ 列向量的线性组合构成它的列空间，一般记为 $C(A)$，当 $\mathbf{b}$ 在 $C(A)$ 时 $A\mathbf{x}=\mathbf{b}$ 有解。</li>
<li>矩阵 $A$ 的 NULL 空间包括满足 $A\mathbf{x}=0$ 的所有 $\mathbf{x}$，记为 $N(A)$</li>
<li>一个矩阵的行空间和它的 NULL 空间相互正交</li>
<li>矩阵的秩是矩阵主元的数量，可以记为 $r$，它不但是行向量的维度还是列向量的维度，而且 NULL 空间的维度是列空间的维度减去 $r$</li>
<li>对于矩阵 $A$ 和 $B$，存在结论 $rank(AB) \le min(rank(A),rank(B))$</li>
</ul>
<p><strong>$A\mathbf{x}=\mathbf{b}$ 的全部解</strong></p>
<ul>
<li>求解 $A\mathbf{x}=\mathbf{b}$ 可以看做求以 $A$ 列向量为坐标轴时 $\mathbf{b}$ 的坐标值 $\mathbf{x}$</li>
<li>$A\mathbf{x}=\mathbf{b}$ 可解当且仅当最后 $m-r$ 个等式变成 $0=0$</li>
<li>$A\mathbf{x}=\mathbf{b}$ 的所有解是满足 $A\mathbf{x}=\mathbf{b}$ 的一个特解 $x_p$ 加上 $A\mathbf{x}=0$ </li>
<li>根据秩 $r$ 的取值，线性方程组有如下四种可能（其中 $m,n$ 为行数、列数）<ul>
<li>$r=m,r=n$，方阵且可逆，$A\mathbf{x}=\mathbf{b}$ 有且只有一个解</li>
<li>$r=m,r&lt;n$，矮又宽型，$A\mathbf{x}=\mathbf{b}$ 有无穷多解</li>
<li>$r&lt;m,r=n$，高又瘦型，$A\mathbf{x}=\mathbf{b}$ 有一个解或无解</li>
<li>$r&lt;m,r&lt;n$，行和列都不满秩，$A\mathbf{x}=\mathbf{b}$ 有无穷多解或无解</li>
</ul>
</li>
</ul>
<p>一组向量 $\mathbf{v_1,\cdots,v_n}$ <strong>线性无关</strong>，当且仅当 $x_1\mathbf{v_1}+x_2\mathbf{v_2}+\cdots+x_n\mathbf{v_n}=\mathbf{0}$ 中的 $x$ 全为零。</p>
<ul>
<li>一组向量的线性组合所构成的空间是这组向量所张成的空间，空间中线性无关且能张成这一空间的一组向量可以作为这一空间的基。</li>
<li>所有基包含向量个数相同，我们把这个数称为该空间的维度，矩阵 $A$ 列向量所张成空间的维度等于矩阵的秩</li>
<li>空间中每个向量表示为一组基线性组合是唯一的</li>
<li>空间 $Z$ 只包含零向量，这一空间的维度为 0，空集构成此空间的一组基</li>
</ul>
<h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><blockquote>
<p>矩阵乘以向量，在功能上相当于把一个向量变换为另一个向量。一个矩阵的特征向量是这样一种特定的向量，它经过这种变换后方向不变（或正好相反），只发生长度上的伸缩，特征值则反映了特征向量的伸缩倍数（及方向）。</p>
</blockquote>
<p>用公式表示为：</p>
<p>$$\mathbf{Ax}=\lambda \mathbf{x}$$</p>
<ul>
<li>满足上式的向量 $\mathbf{x}$ 称为矩阵 $\mathbf{A}$ 的特征向量</li>
<li>数 $\lambda$ 反应了伸缩的倍数及方向，称为与 $\mathbf{x}$ 对应的特征值</li>
</ul>
<p>一些重要性质</p>
<p>设 $\lambda_1,\lambda_2,\cdots,\lambda_n$ 是 n 阶矩阵 $\mathbf{A}$ 的 $n$ 个特征值，则：</p>
<ul>
<li>$\lambda_1,\lambda_2,\cdots,\lambda_n=a_{11}+a_{22}+\cdots+a_{nn}$</li>
<li>$\lambda_1\lambda_2\cdots\lambda_n=|\mathbf{A}|$
</li>
</ul>
<p><strong>特征向量之间的关系：</strong></p>
<ul>
<li>矩阵 $\mathbf{A}$ 的属于不同特征值的特征向量是线性无关的</li>
<li>设 $\lambda_1,\lambda_2,\cdots,\lambda_n$ 是矩阵 $\mathbf{A}$ 的 $m$ 个互异特征值，对应于 $\lambda_i\;(i=1,2,\cdots,m)$ 的线性无关的特征向量有 $r_i$ 个，则→所有这些特征向量构成的向量组是线性无关的</li>
<li>对称矩阵 $\mathbf{A}$ 的属于不同特征值的特征向量是两两相交的</li>
</ul>
<p><strong>特征值所对应的特征向量的个数：</strong></p>
<ul>
<li>每个特征值都对应着至少一个特征向量</li>
<li>$k$ 重特征值对应的线性无关的特征向量的个数不超过 $k$</li>
<li>若 $A$ 为对称矩阵，则 $A$ 的每个特征值对应的线性无关特征向量的个数恰好等于该特征值的重数</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>理解矩阵 <a href="http://blog.csdn.net/myan/article/details/647511" target="_blank" rel="external">一</a> <a href="http://blog.csdn.net/myan/article/details/649018" target="_blank" rel="external">二</a> <a href="http://blog.csdn.net/myan/article/details/1865397" target="_blank" rel="external">三</a></li>
<li><a href="https://hujiaweibujidao.github.io/files/linear_algebra_huangzhenghua.pdf" target="_blank" rel="external">线性代数·总结与复习</a></li>
<li><a href="http://www.zhaokv.com/wiki/book/ila/review" target="_blank" rel="external">线性代数总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍线性代数中与机器学习相关的重要概念，方便不懂的时候进行查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="机器学习" scheme="http://wdxtub.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性代数" scheme="http://wdxtub.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【不周山之机器学习】习题课 零 微积分</title>
    <link href="http://wdxtub.com/2017/02/06/calculus/"/>
    <id>http://wdxtub.com/2017/02/06/calculus/</id>
    <published>2017-02-06T13:19:27.000Z</published>
    <updated>2017-02-07T23:13:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍微积分中与机器学习相关的重要概念，方便不懂的时候进行查阅。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.02.08: 完成初稿</li>
<li>2017.02.06: 开始编写</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>世界是一个复杂但逻辑高度自洽的体系，数学用简单且无二义的符号来描述世界，所以如果我们连科学家用来建模世界的『语言』都看不懂的话，更不用说去理解这个世界了。</p>
<p>但是数学要怎么学呢？首先我认为现在的数学教学并不是特别好的方法，学了一堆『方法』，却不知道有什么『目标』，轻则让人迷失方向，重则丧失对数学仅存的那点兴趣。数学这栋大厦已经足够高耸入云了，还是先弄清楚我们需要什么，再按图索骥比较好。</p>
<p>正如参考链接中所说：</p>
<blockquote>
<p>学会这样一种自下而上的，多级抽象的思考方式，个人认为是数学带给我们的最重要财富。数学不是令人生畏的满屏公式，不是折磨人的重复计算，是有关“如何对概念进行抽象”的精巧艺术。</p>
</blockquote>
<p>就让我们从微积分开始，走入奇妙且简洁的数学世界吧！</p>
<p>注：部分知识点会简单带过，主要是介绍最基础和涉及机器学习相关的内容</p>
<h2 id="函数、极限与连续"><a href="#函数、极限与连续" class="headerlink" title="函数、极限与连续"></a>函数、极限与连续</h2><p><strong>初等函数</strong>在其定义域内都是连续的，<strong>基本初等函数</strong>有以下五种：</p>
<ol>
<li>幂函数：$y=x^\mu\;(\mu \in R)$</li>
<li>指数函：$y=a^x\;(a&gt;0 \;且\; a \neq 1)$</li>
<li>对数函数：$y=log_ax\;(a>0 \;且\; a \neq 1)$，特别当 $a=e$ 时，记为 $y = ln\; x$</li>
<li>三角函数：如 $y=sin\;x, y=cos\; x, y=tan\; x$ 等</li>
<li>反三角函数：如 $y=arcsin\;x, y=arccos\; x, y=arctan\; x$ 等</li>
</ol>
<p>由常数和基本初等函数经过有限次的四则运算和有限次的函数复合步骤所构成并可用一个式子表示的函数，称为<strong>初等函数</strong>。</p>
<h3 id="函数与函数表达式"><a href="#函数与函数表达式" class="headerlink" title="函数与函数表达式"></a>函数与函数表达式</h3><p>函数即『对应关系』本身. 对应关系是抽象的, 我们看到的解析表达式 $y=f(x)$ 正是为了表述、体现那个看不到摸不着的关系而给出的具象。我们要特别重视公式法表示函数时的不同表现形式。</p>
<p>常见的函数表达式类型有：</p>
<ul>
<li>分段函数。求极限、连续性讨论、求导、积分</li>
<li>幂指函数。形如 $u(x)^{v(x)}$ 的求极限与求导</li>
<li>积分上限函数。形如 $\int_a^xf(x)dx$ 的求极限与求导</li>
<li>隐函数</li>
<li>参数方程确定的函数</li>
</ul>
<p>关于收敛数列（极限存在）由两个性质：唯一性和有界性</p>
<h3 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h3><p>如果  $lim_{x \to \ast}f(x)=0$ ，则 $f(x)$ 为  $x \to \ast $ 时的无穷小（这里的 <code>*</code> 可以代表常数、无穷大、单侧逼近的各种情形）</p>
<p>这里需要注意的是：</p>
<ul>
<li>无穷小是一个函数，且必须指名具体的条件，也就是 $x \to *$</li>
<li>等价无穷小 (同阶无穷小)、高阶无穷小 (低阶无穷小) 讲的是函数趋于 0 的速度的比较（比如 $x \to 0$ 时 $x^3$ 趋于 0 的速度比 $x^2$ 要快，故 $x \to 0$ 时 $x^3$ 是较 $x^2$ 高阶的无穷小）</li>
<li>多项式函数中，次数最低的项决定无穷小的阶数，或者说决定其速度的数量级（如 $x \to 0$ 时 $3x^3 + 2x$ 与 $x$ 是同阶无穷小）。无穷大的情形则相反，次数最高的项起决定作用。</li>
</ul>
<p><strong>常见的等价无穷小</strong></p>
<p>当 $x \to 0$ 时，</p>
<p>$$x \sim e^x -1 \sim ln(1+x) \sim sin\;x \sim tan\;x \sim arcsin\;x \sim arctan\;x$$</p>
<p>$$1-cos\; x \sim \frac{x^2}{2}$$</p>
<p>$$(1+x)^a-1 \sim ax$$</p>
<p>具体的验证可以用洛必达法则或泰勒展开，比如：</p>
<p>对于 $sin\;x$，由泰勒展开可得 $sin\;x=x-\frac{1}{3!}x^3+\frac{1}{5!}x^5-\frac{1}{7!}x^7+\cdots$，可见 $x \to 0$ 时，$sin\; x = x + o(x)$，即 $sin\;x \sim x$</p>
<p>对于 $cos\;x$，由泰勒展开可得 $cos\;x=x-\frac{1}{2!}x^2+\frac{1}{4!}x^4-\frac{1}{6!}x^6+\cdots$，可见 $x \to 0$ 时 $cos\;x-1$ 为无穷小，且 $cos\;x-1= -\frac{1}{2!}x^2+o(x^2)$，即 $cos\;x-1 \sim -\frac{x^2}{2!}$</p>
<p>其他的也可以用这样的方法证明</p>
<h3 id="1-infty-型极限"><a href="#1-infty-型极限" class="headerlink" title="$1^\infty$ 型极限"></a>$1^\infty$ 型极限</h3><p>一个 $1^\infty$ 型极限的常见例子是  $lim_{x \to \infty}(1+\frac{1}{x})^x=e$ ，其一般形式是</p>
 $lim_{x \to \ast}(1+\alpha(x))^{\beta(x)}=exp\{lim_{x \to \ast} \alpha(x)\beta(x)\}$ 
<p>其中 $x \to \ast$ 时，$\alpha(x) \to 0,\;\beta(x) \to \infty$</p>
<p>具体的推导过程是利用幂指函数的求界限方式，并且可以利用 $\alpha(x) \to 0$ 时 $ln(1+\alpha(x)) \sim \alpha(x)$ 这一性质得到上面的式子。</p>
<p>最后注意一个重要性质：<strong>有界函数与无穷小的乘积仍为无穷小</strong></p>
<h3 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h3><p>说一个函数连续, 就是其曲线连续、不断开。判断连续或间断, 都只需要抓住一个表达式</p>
 $lim_{x \to x_0}f(x)=f(x_0)$ 
<p>如果上面的式子满足如下情况，则认为是间断：</p>
<ol>
<li>$f(x_0)$ 不成立，即函数在 $x_0$ 处无定义</li>
<li>$lim_{x \to x_0}f(x)$ 不成，即函数在 $x_0$ 无极限</li>
<li>等号 <code>=</code> 不成立</li>
</ol>
<p>这里第一类间断是可修复的间断，而第二类则不是。另外<strong>零点定理</strong>、<strong>介值定理</strong>, 一定要结合几何意义去理解。</p>
<p>最大值和最小值定理就是说在闭区间上的连续函数 $f(x)$ 一定是有上下界的。</p>
<p>介值定理就是说在闭区间上的连续函数 $f(x)$，如果左右端点的取值不同，例如 $f(a)=A,f(b)=B$，那么区间中肯定有一点的函数值能够取到 $[A,B]$ 之间的任何一个值。</p>
<p>零点定理就是说在闭区间上的连续函数 $f(x)$，如果左右端点的取值异号，例如 $f(a)=A &gt; 0,f(b)=B &lt; 0$，那么区间中肯定有一点的函数值为 0。</p>
<h2 id="导数与微分"><a href="#导数与微分" class="headerlink" title="导数与微分"></a>导数与微分</h2><p>导数的几何意义就是曲线在某点的切线的斜率，反应了变化的快慢，理解这个很重要，后面的偏导数的理解也类似。如果用物体的运动来解释的话，导数就是物体在那个时刻的加速度了。</p>
<p>通俗地说，可导函数曲线是光滑的，『尖点』处不可导，定义式为：</p>
$$ f'(x_0)= \frac{f(x)-f(x_0)}{x-x_0}$$
<p>与连续的关系是：<strong>可导必定连续; 连续不一定可导</strong>(比如函数在尖点处连续但不可导)</p>
<p>罗尔中值定理就是说对于在区间 $(a,b)$ 上的连续可导函数 $f(x)$，若左右端点的函数值相等，那么区间内至少有一个点满足它的导数为 0，即 $f’(\epsilon)=0,\;\epsilon \in (a,b)$</p>
<p>拉格朗日中值定理就是说对于在区间 $(a,b)$ 上的连续可导函数 $f(x)$，区间内至少有一个点满足 $f’(\epsilon)=\frac{f(a)-f(b)}{a-b}, \; \epsilon \in (a,b)$。该定理就没有罗尔中值定理的条件那么严格了，所以后者是前者的一个特殊情况。拉格朗日中值定理的几何意义如下，曲线在 C 点处的切线平行于弦 AB</p>
<p><img src="/images/14865079484407.jpg" alt=""></p>
<p>柯西中值定理就扩展到区间 $(a,b)$ 上的两个连续可导函数 $f(x)$ 和 $F(x)$，区间内至少有一个点满足 $\frac{f’(\epsilon)}{F’(\epsilon)} = \frac{f(a)-f(b)}{F(a)-F(b)},\;\epsilon \in (a,b)$</p>
<h3 id="基本求导方法"><a href="#基本求导方法" class="headerlink" title="基本求导方法"></a>基本求导方法</h3><ul>
<li>对于分段函数来说，分段点的导数要用定义来求</li>
<li>对于幂指函数来说，幂指函数本质上是复合函数</li>
<li>对于隐函数来说，隐函数求导实际上就是复合函数求导</li>
<li>对于参数方程函数来说，实际上也是复合函数的求导，要特别注意求二阶导数</li>
</ul>
<p>洛必达法则很重要，因为很多时候我们总是会遇到各种不同特殊形式的未定式，它们的极限可以试试使用洛必达法则来求。</p>
<p>在满足条件的前提下，我们可以先对分子分母求导然后求极限，即 $lim_{x \to x_0}\frac{f(x)}{g(x)}=lim_{x \to x_0}\frac{f'(x)}{g'(x)}$</p>
<h3 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h3><p>微分中值定理如何理解? 极值与最值的区别?</p>
<ul>
<li>恒等式或不等式的证明</li>
<li>求函数的极值或最值，单调性、凹凸性判别，拐点</li>
<li>极值是局部的</li>
<li>最值是全局的</li>
<li>驻点是可能的极值点</li>
<li>极值点不一定是驻点。</li>
</ul>
<p>驻点：函数 $f(x)$ 一阶导数为 0 的点，根据它的正负可以判断函数的单调性，大于 0 为单调递增</p>
<p>拐点：函数 $f(x)$ 二阶导数为 0 的点，根据它的正负可以判断函数的凹凸性，大于 0 为凹的</p>
<h3 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h3><p>求解 $y’’+py’+qy=0$，这里 $p, q$ 是常数。</p>
<p>对应的特征方程 $r^2+pr+q=0$，得特征根 $r_1, r_2$</p>
<ol>
<li>若 $r_1 \ne r_2$，则通解 $y=C_1e^{r_1x}+C_2e^{r_2x}$</li>
<li>若 $r_1 = r_2 = r$，则通解 $y=(C_1+C_2x)e^{rx}$</li>
<li>若 $r_{1,2} = \alpha \pm i\beta$，则通解 $y=e^{\alpha x}(C_1cos\;\beta x+C_2sin\;\beta x)$</li>
</ol>
<h2 id="不定积分与定积分"><a href="#不定积分与定积分" class="headerlink" title="不定积分与定积分"></a>不定积分与定积分</h2><p>我们需要理解定<strong>积分的几何意义</strong>以及<strong>换元积分法和分布积分法的实质</strong>。<strong>分段函数的定积分</strong>和<strong>积分中值定理</strong>也是需要掌握的内容。</p>
<h3 id="换元积分法"><a href="#换元积分法" class="headerlink" title="换元积分法"></a>换元积分法</h3><p>又叫第一类换元法，用来处理形如 $\int f(\varphi(x))g(x)dx$ 的积分。这类积分的特点<br>是: 被积表达式一般是两个函数的乘积，其中一个为复合函数，且其内函数 $\varphi(x)$ 的导数往往是剩下那个函数 $g(x)$，即 $\varphi ‘(x)=g(x)$，或者说 $d(\varphi(x))=g(x)dx$，从而</p>
<p>$$\int f(\varphi(x))g(x)dx=\int f(\varphi(x))d(\varphi(x))$$</p>
<p>再把 $\varphi(x)$ 作为一个整体变量 $u$，以 $\int f(u)du$ 这样的积分进行计算。</p>
<h3 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h3><p>分部积分法所处理的积分，其被积表达式也一般是两个函数的乘积，这两个函数是不同类型的初等函数，或者说通常是幂、指、对、三角、反三角等函数中的某两个。分部积分法的关键在于其中<strong>暗含了一次求导</strong>，使被积表达式中的一个函数得以『消失』或简化。</p>
<p>举个例子：</p>
<p>$$\int x^2e^xdx=\int x^2d(e^x)=x^2e^x-\int e^xd(x^2)=x^2e^x-\int 2xe^xdx$$</p>
<p>后移的函数 $x^2$ 可以被求导，继续这个过程，就可以完成积分：</p>
<p>$$\int x^2e^xdx=x^2e^x-\int 2xe^xdx=x^2e^x-2(xe^x-\int e^xdx)$$</p>
<h3 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h3><p>证明：若 $f(x),\;g(x)$ 都是可微函数，且当 $x \ge a$ 时，$|f’(x) \le g’(x)|$，则当 $x \ge a$ 时，$|f(x)-f(a)| \le g(x) - g(a)$</p>
<p>由 $x \ge a$ 时，$|f’(x) \le g’(x)|$ 有</p>
$$\int_a^x|f'(x)|dx \le \int_a^xg'(x)dx$$
<p>而 </p>
$$|\int_a^xf'(x)dx|\le \int_a^x|f'(x)|dx \le \int_a^xg'(x)dx$$
<p>且</p>
$$|\int_a^xf'(x)dx|=|[f(x)]_a^x|=|f(x)-f(a)|$$
$$\int_a^xg'(x)dx=[g(x)]_a^x=g(x)-g(a)$$
<p>可得</p>
<p>$|f(x)-f(a)| \le g(x) - g(a)$</p>
<h3 id="定积分的应用"><a href="#定积分的应用" class="headerlink" title="定积分的应用"></a>定积分的应用</h3><p>需要了解<strong>元素法</strong>，定积分可以用于：</p>
<ul>
<li>求面积</li>
<li>求弧长</li>
<li>求旋转体体积</li>
<li>计算做功问题</li>
</ul>
<h3 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h3><p>积分 $\int_0^a\frac{1}{x^p}dx$，当 $p &lt; 1$ 时收敛，当 $p \ge 1$ 时发散，其中 $a$ 为任意正数。</p>
<p>积分 $\int_0^{+\infty} \frac{1}{x^p}dx$，当 $p&gt;1$ 时收敛，当 $p \le 1$ 时发散，其中 $a$ 为任意正数。</p>
<h2 id="多元函数微分"><a href="#多元函数微分" class="headerlink" title="多元函数微分"></a>多元函数微分</h2><p>梯度是一个向量：</p>
$$\mathbf{grad}f(x_0,y_0)=\{f_x(x_0, y_0), f_y(x_0,y_0)\}$$ 
<p>梯度概念的引入，简化了方向导数的计算表达式。在可微的条件下，方向导数</p>
$$\frac{\partial f}{\partial \mathbf{\iota}}=f_x(x_0,y_0)cos\theta+f_y(x_0, y_0)sin\theta=\{f_x(x_0, y_0), f_y(x_0,y_0)\}\cdot\{cos\theta, sin\theta\}=\mathbf{grad}f(x_0,y_0)\cdot\mathbf{e_\iota}$$
<p>梯度所指的方向，是函数值增加最快的方向。这也是用『梯度』一词来命名这个概念的缘由</p>
$$\frac{\partial f}{\partial \mathbf{\iota}}=\mathbf{grad}f(x_0,y_0)\cdot\mathbf{e_\iota}=|\mathbf{grad}f(x_0,y_0)||\mathbf{e_\iota}|cos\langle \mathbf{grad}f(x_0,y_0), \mathbf{e_\iota}\rangle=|\mathbf{grad}f(x_0,y_0)|cos\langle \mathbf{grad}f(x_0,y_0), \mathbf{e_\iota}\rangle$$
<p>当取定 $\mathbf{e_\iota}$ 与 $\mathbf{grad}f(x_0,y_0)$ 同方向时，方向导数取到最大值，且最大值为 $|\mathbf{grad}f(x_0, y_0)|$</p>
<h2 id="无穷级数"><a href="#无穷级数" class="headerlink" title="无穷级数"></a>无穷级数</h2><p>级数 $\sum_{n=1}^\infty u_n=u_1+u_2+\cdots+u_n+\cdots$ 是无穷多项求和的问题。更多的时候是关注和的存在性，即收敛与否的问题。通常会转化为讨论前 $n$ 项和数列 $\{s_n\}$ 的敛散性，其中 $s_n\triangleq u_1+u_2+\cdots+u_n$</p>
<p>级数收敛的必要条件是 $lim_{n \to \infty}u_n = 0$，但反之不成立，比如调和级数 $\sum_{n=1}^\infty \frac{1}{n}$ 满足 $lim_{n \to \infty}u_n = 0$，但级数发散。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>数学的用处 <a href="http://blog.sina.com.cn/s/blog_946b64360101ehvn.html" target="_blank" rel="external">一</a> <a href="http://blog.sina.com.cn/s/blog_946b64360101emco.html" target="_blank" rel="external">二</a> <a href="http://blog.sina.com.cn/s/blog_946b64360101ewp9.html" target="_blank" rel="external">三</a> <a href="http://blog.sina.com.cn/s/blog_946b64360101f2qa.html" target="_blank" rel="external">四</a></li>
<li>微积分复习总结 <a href="https://hujiaweibujidao.github.io/files/calculus1_huangzhenghua.pdf" target="_blank" rel="external">上</a> <a href="https://hujiaweibujidao.github.io/files/calculus2_huangzhenghua.pdf" target="_blank" rel="external">下</a></li>
<li><a href="https://hujiaweibujidao.github.io/files/calculus_summary.pdf" target="_blank" rel="external">微积分总结</a></li>
<li><a href="http://blog.sciencenet.cn/blog-826653-863396.html" target="_blank" rel="external">重修微积分1 - 无穷</a> | <a href="http://blog.sciencenet.cn/blog-826653-863399.html" target="_blank" rel="external">重修微积分2 - 收敛</a> | <a href="http://blog.sciencenet.cn/blog-826653-879432.html" target="_blank" rel="external">重修微积分3 - 拓扑</a> | <a href="http://blog.sciencenet.cn/blog-826653-881217.html" target="_blank" rel="external">重修微积分4 - 距离</a></li>
<li><a href="http://blog.sciencenet.cn/blog-826653-884719.html" target="_blank" rel="external">重修微积分5 - 线性</a> | <a href="http://blog.sciencenet.cn/blog-826653-886565.html" target="_blank" rel="external">重修微积分6 - 微分</a> | <a href="http://blog.sciencenet.cn/blog-826653-888365.html" target="_blank" rel="external">重修微积分7 - 测度</a> | <a href="http://blog.sciencenet.cn/blog-826653-890282.html" target="_blank" rel="external">重修微积分8 - 积分</a></li>
<li><a href="http://blog.sciencenet.cn/blog-826653-892196.html" target="_blank" rel="external">重修微积分9 - 泛函</a> | <a href="http://blog.sciencenet.cn/blog-826653-893883.html" target="_blank" rel="external">重修微积分10 - 算子</a></li>
<li>理解数学 - 模型 <a href="http://blog.sciencenet.cn/blog-826653-714192.html" target="_blank" rel="external">1</a> <a href="http://blog.sciencenet.cn/blog-826653-715358.html" target="_blank" rel="external">2</a> <a href="http://blog.sciencenet.cn/blog-826653-717208.html" target="_blank" rel="external">3</a></li>
<li>理解数学 - 抽象 <a href="http://blog.sciencenet.cn/blog-826653-705074.html" target="_blank" rel="external">1</a> <a href="http://blog.sciencenet.cn/blog-826653-706209.html" target="_blank" rel="external">2</a> <a href="http://blog.sciencenet.cn/blog-826653-707072.html" target="_blank" rel="external">3</a></li>
<li>理解数学 - 逻辑 <a href="http://blog.sciencenet.cn/blog-826653-708208.html" target="_blank" rel="external">1</a> <a href="http://blog.sciencenet.cn/blog-826653-709084.html" target="_blank" rel="external">2</a> <a href="http://blog.sciencenet.cn/blog-826653-710160.html" target="_blank" rel="external">3</a> <a href="http://blog.sciencenet.cn/blog-826653-711094.html" target="_blank" rel="external">4</a> <a href="http://blog.sciencenet.cn/blog-826653-712467.html" target="_blank" rel="external">5</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍微积分中与机器学习相关的重要概念，方便不懂的时候进行查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="机器学习" scheme="http://wdxtub.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="微积分" scheme="http://wdxtub.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>如何做职业选择</title>
    <link href="http://wdxtub.com/2017/02/05/how-to-choose-career/"/>
    <id>http://wdxtub.com/2017/02/05/how-to-choose-career/</id>
    <published>2017-02-05T04:12:42.000Z</published>
    <updated>2017-02-05T06:28:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>职业选择之所以困难，是因为不存在所谓的『最优解』。这里分享一下我自己做职业选择的一些思考，『颇示己志』的同时，希望能给也在迷茫的朋友们一些参考。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.02.05: 完成初稿</li>
</ul>
<p><strong>我要离开大疆了，去一家做人工智能的创业公司。</strong></p>
<p>离职的决定看似很突然，但并不是冲动，反而是下定了决心。这个过程中有犹豫和摇摆，但更多是在一片迷茫之中最终找到了自己真正想要走的方向。</p>
<p>很多关心我的朋友好奇我离职的原因，毕竟可能很难再有遇到像大疆这样大体量的公司，对初出茅庐的我委以重任，让我负责若干重要项目的架构、设计与开发。氛围很好，同事和上下级间更像是朋友和伙伴，互相帮助互相配合，一起解决问题攻克难关。</p>
<p>充分的信任 + 广阔的上升空间 + 舒服的工作氛围，这一切是如此完美，以至于这个时候要离职的我，看起来就好像脑袋被驴踢了一样。</p>
<p>我的脑袋可能真的被门夹了，一扇命运之门。</p>
<p>恍惚之中我仿佛穿越到了五年前，带着大箱子降落在北京的那个下午。怎么也没有想到，我一个搞计算机视觉的人，居然到微软的 Bing 成了一个 PM(Program Manager) 实习生。怎么也没有想到，很偶然的机会听了一次关于搜索引擎语义理解和自动问答的讲座，居然对我未来的选择起到了如此大的影响。怎么也没有想到，兜兜转转最终还是回到了梦想的起点，那就是去搞<strong>人工智能</strong>。</p>
<p>当时的梦想非常『科幻』，想做一个有自己『意识』的聊天机器人（哪怕是设置好的『意识』，但是尽量让人感觉不出来）。这个聊天机器人可以通过载入不同的『意识卡』改变自己的『意识』。每个人也可以从自己的大脑中 dump 出自己的意识并制作成『意识卡』。</p>
<p>这意味着我可以每隔五年制作一次自己的『意识卡』，把二十岁的『意识卡』载入聊天机器人，我就可以跟二十岁的自己聊天。我甚至可以看着『二十岁的自己』跟『十五岁的自己』聊天！脑洞再大一点，甚至可以 dump 出各种伟人的『意识卡』，假如秦始皇那时候就有这个技术，我们现在甚至仍旧能跟秦始皇对话（从某种意义上来说）！</p>
<p>学着学着我意识到，这个梦想真的太过遥远了。但千里之行始于足下，我至少可以先从可行的做起。于是本科的毕业设计便围绕是『自动问答系统』展开的，比方说我输入『中国的首都是哪里』，那么引擎给出的答案应该是『北京』。</p>
<p>既然是回答问题，那么一个绕不开的问题便是如何去表示知识。于是研究生的毕业设计是 WKK(Wdx’s Knowledge Kit)，想要打造一个智能知识管家，把网络上零零碎碎的信息组合成知识，形成『信息/知识闭环』，比方说我现在想要学围棋，那么 WKK 应当是能够辅助我学习的工具，即帮我认识到那些我自己都不知道自己不知道的东西。</p>
<blockquote>
<p>当你老了，回顾一生，就会发觉：什么时候出国读书、什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你做出抉择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。但一场巨变，已经发生了。地动山移，浑然不觉，当时只道是寻常。 - 陶杰《杀鹌鹑的少女》</p>
</blockquote>
<p>所以，当我遇到一个机会，能和一个靠谱的团队一起把自己一直想做一直在做的东西（自然语言处理、机器学习、深度学习、知识图谱、数据挖掘）打造成一个有社会影响力的产品时，就真的好像被命运之门狠狠夹了一下脑袋。</p>
<p>如果现在因为更加安稳的路而放弃追逐梦想，老了之后一定懊悔当初为什么没有更加『离经叛道』的。</p>
<p>所谓职业选择，其实更多是明心见性的过程，外在因素会有影响，但最重要的是<strong>做自己想做的</strong>，只有这样才有源源不断的热情和动力，在最艰难的时候依然能坚持下去。</p>
<hr>
<p>整理自己文章的时候，仿佛从字里行间又看到了当年那个激扬文字的自己，这里摘录一下，也算『每日三省吾身』。</p>
<p><a href="http://wdxtub.com/2015/04/28/what-is-important/">什么最重要（写于2015.04.28）</a>中提过『找自己』，列出了四点要注意的：</p>
<ul>
<li><strong>体验</strong>：身处其中即为体，那么验呢？验证的是你对这个世界的判断，验证的是你对自己的理解</li>
<li><strong>感知</strong>：特定去训练自己的感知能力</li>
<li><strong>挣脱</strong>：离经叛道最需要的不是能力，反而是勇气，顺着被大多数人验证过的路径走，是安全的选择，但是为了获得这样的安全，你就必须和千千万万拥有同样想法的人竞争</li>
<li><strong>眼界</strong>：跨领域的全局思考方式，一个项目，首先能设计好，还能让别人知道这个好，也能让别人在用的时候从中得到好处，顺带还能通过有效的传播方式让更多的人知道这个好，最后再找来能做好的人完成好</li>
</ul>
<p><a href="http://wdxtub.com/2016/02/12/end-of-anxiety/">不安的终结（写于2016.02.12）</a> 给出了面对不安的解决办法：</p>
<p>危险的环境和危机感，才是驱使人类不断进步，不断征服新事物的根本动力。人人都会不安，这是本能，但是本能之上，应该意识到不安的终结并不是避免困难的出现，而是去战胜困难。自信不是把自己当做宠物，当做温室里的花朵来成长，而是相信自己，永远敢于接受下一次的挑战。</p>
<p><a href="http://wdxtub.com/2016/04/24/coming-back/">回国（写于2016.04.24）</a>提到了我回国的原因：</p>
<p>人各有志，安安稳稳过一辈子也是很好的选择，可是我还是觉得，人生难得几回搏，沿着所谓『大家都觉得好』的路往前走，是不是太无趣了些？</p>
<p><a href="http://wdxtub.com/2016/04/27/shadow-hunter/">影子猎手（写于2016.04.27）</a>提到了我最终想要成为的形象：</p>
<p>猎手知道自己的猎物是什么，知道自己要怎么做才能得手，有勇气去失败，有胆量去成功。这里的『影子』，其实是我用来描述信息的一种抽象表示，意指很多时候我们无法真正看到本体，反而只能看到本体经过投影的有损压缩过的信息，就像影子一样。</p>
<p>信息决定格局，格局决定命运。影子猎手永远在向上攀登，知道自学无法拥有一切，所以尽可能跟各种人进行高质量的沟通，在不同的地方获取不同的信息，再利用信息不对称，完成那些别人想都没想过的壮举。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;职业选择之所以困难，是因为不存在所谓的『最优解』。这里分享一下我自己做职业选择的一些思考，『颇示己志』的同时，希望能给也在迷茫的朋友们一些参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="选择" scheme="http://wdxtub.com/tags/%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>第三十四周 - 青春大概</title>
    <link href="http://wdxtub.com/2017/02/03/about-youth/"/>
    <id>http://wdxtub.com/2017/02/03/about-youth/</id>
    <published>2017-02-03T15:59:59.000Z</published>
    <updated>2017-02-04T01:05:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>哭过笑过恋过恨过，仿佛是一梦蹉跎。迷惑失落忧愁寂寞，谁都是凡人一个。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.02.04: 完成初稿</li>
<li>2017.02.03: 完成大纲</li>
</ul>
<p>立春、初七、周五、新年第一个工作日、一个结束与一个开始。 </p>
<p>辞职、交接、撸串、搬家收拾洗洗刷刷、一次转身与一次回望。</p>
<p>要怎么样收尾呢？不知道。无论是跟老大解释要离开的原因还是跟同事交接工作相关事宜，莫名有了许多悲壮的感觉。悲是因为大疆是我非常喜欢的公司，却因为公司需要和个人发展目标有些不一致，没有办法再为之添砖加瓦；壮是因为相信自己到了新的行业和领域能够更充分的发挥自己的能力，反过来说不定今后还有合作的机会呢。</p>
<p>虽然我也知道 business is business，但一起经历了各种各样的事情，忽然说要离开，真有些开不了口。可能我还没有成熟到能够『看山还是山，看水还是水』吧，所以我特别感谢老大对我的理解和鼓励，我一定会好好努力做出一点成绩，不给大家丢人。</p>
<p>大疆对我来说有知遇之恩，同学朋友领导对我的关怀和信任让我意识到一群人努力把自己想要的东西从零到以做出来是多么让人快乐的过程。深圳是一个年轻的城市，大疆是一个年轻的公司，身边的小伙伴是一群年轻的梦想家，身处其中所感受到的朝气蓬勃，真有种『数风流人物还看今朝』的气势。</p>
<p>可是对于硬件相关知之甚少的我，很多时候只能以辅助的形式参与到各项工作中。但对于年轻人来说，没有什么比冲到第一线去披荆斩棘建功立业更有吸引力的。现在的工作固然安稳固然轻松，可是换个角度想，没有了挑战，日子也有些无趣。所以，接下来的日子会把之前给自己挖的坑填一下，然后轻装上阵，去新的战场接受新的挑战。</p>
<p>带着诸多不舍和眷恋，春节期间有些矫枉过正地在飞飞机，几乎把广州飞了个遍：从生物岛到二沙岛，从执信中学到中山大学，从体育学院到猎德大桥。尝试了各种拍摄方式，甚至还做了五秒钟的定格动画，在密集地拍摄中完成了从记录到创作的进化，感觉再次打开了新世界的大门。</p>
<p>在珠江边用无人机给爸妈拍视频的时候忽然意识到，科技和工程最重要的还是要回归到人，脱离了人本身去追求载体很快便会厌倦，但是人如果是快乐的，有了更好的载体，就能让幸福感更长久的延续下去。</p>
<p>新的一年还有很多事情等着我去完成，既然做了决定，就要一如既往全力以赴下去。</p>
<p>数着等着望着怕着，青春已时日无多；在遗忘中不舍，醉熏交错，青春大概如你所说；在花落时结果，期望很多，青春大概都这样过；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哭过笑过恋过恨过，仿佛是一梦蹉跎。迷惑失落忧愁寂寞，谁都是凡人一个。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="结束" scheme="http://wdxtub.com/tags/%E7%BB%93%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>小土刀的理财指南</title>
    <link href="http://wdxtub.com/2017/01/31/money-management-guide/"/>
    <id>http://wdxtub.com/2017/01/31/money-management-guide/</id>
    <published>2017-01-31T05:33:13.000Z</published>
    <updated>2017-01-31T15:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>理财与其说是一种行为和方法，不如说是一种以系统性思维看待金钱的生活方式。对于大部分人来说，重要的是理清基本概念，形成一套适合自己的简便易执行的理财方案。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.31: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>理财是一个很大的话题，不过对于实际操作来说，最重要是形成一套基于基本公理且易执行的指导思想，这样才更能固化成为生活方式，也便于具体情况具体分析。那么这些『公理』要怎么确定呢？我这里有一个思路：系统性思维。</p>
<p>所谓系统性思维，指的是对于一个系统来说，有三个要素：输入、存量和输出。只要处理好这三个要素的动态平衡，就可以保证系统正常运作。个中道理其实很简单，输入大于输出，存量增加；输出大于输入，存量减少。所谓理财，其实就是围绕着这三个要素的。接下来我也会以此为脉络来写这个指南。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入简单来说就是挣钱，分为主动收入和被动收入。主动收入对我来说就是工资了，被动收入的话目前来看是博客的打赏。</p>
<p>但其实还有一个很重要的输入是时间，每天都有新的 24 小时入账，不过时间是比较特殊的，因为看起来似乎是无法存起来的（但实际上是有办法的，后面会说）。</p>
<p>主动收入的提高方式基本有俩：『好好干活升职加薪（当然跳槽也算）』或者『自己当老板（当然不能是亏钱的那种）』。</p>
<p>被动收入的多少基本取决于个人的影响力，好好经营博客和社交网络，持续提供有价值的输出是正道。在我看来这个更多是一件放长线钓大鱼的事情，而且也不宜有太多的功利性，随性就好。</p>
<p>一句话总结：<strong>踏实做事，能力是价值，收入是价格可能会波动，但长期来看不会离价值太远</strong>。</p>
<h2 id="存量"><a href="#存量" class="headerlink" title="存量"></a>存量</h2><p>存量其实是一种规划，年轻人存量不大的时候，没啥必要搞太多奇技淫巧，先把合理的生活方式固定下来，培养习惯更重要。好的存量习惯包括：</p>
<ul>
<li>每个月先存款再消费，收入的 30%-40% 先攒起来，归入到『暂时不花的』的分类，可以放到银行的理财产品中</li>
<li>维护自己的紧急备用金，大约是自己 3-6 个月的总支出（这里有一个问题，先要知道自己每个月大概要花多少钱），归入到『很快能花的』的分类，可以买一些大公司的货币基金（支付宝的余额宝和招行的朝朝盈也属于此类）</li>
<li>现金和活期存款不宜过多，归入到『立刻能花的』分类，尤其推荐多用信用卡来消费，慢慢建立自己的信用</li>
</ul>
<p>至于资产配置什么的（将投资组合分布于几种不相关的资产，提高收益同时降低风险），都知道是非常有效的手段，但是对于我来说，也没那么多资产，就不要先瞎折腾了。</p>
<p>前面提到了输入中固定有的是时间，那么时间要怎么存呢？答案很简单，就是把工作生活学习的知识转换成能力，积累经验复用经验，实际上就等于把过去的时间『存』起来了，不然时间过去就过去了，是永远追不回来的一笔财富。</p>
<p>一句话总结：<strong>收益性、风险性、流动性总是需要取舍的，但是想办法把时间存下来是一本万利的事情</strong>。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出简单来说就是花钱了，但其实这也是最难的部分，怎么花什么时候花都是需要慢慢摸索的，同样的，对于年轻人来说，最重要的是培养习惯，比如：</p>
<ul>
<li>学会做预算（首先需要知道自己每个月大概要花多少钱）</li>
<li>把钱和时间多花在未来的自己身上，包括但不限于：买书看书写作、运动健身旅行</li>
<li>能花钱买时间的时候就要买，毕竟时间是不可再生资源</li>
<li>削减小额花销，可有可没有的就选择没有</li>
<li>断舍离，买真正需要的东西，不囤积，不冲动消费</li>
<li>买资产不买折旧</li>
<li>买一个东西如果只是因为便宜，那就不要买</li>
<li>一个即使很贵的东西，如果经常要用到，其实是便宜</li>
<li>…其他想到再加</li>
</ul>
<p>一句话总结：<strong>剁手一时爽，过后悔断肠。买回来的东西一定要用起来，从众和攀比心理是最先需要摒弃的</strong>。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>前面存量和输出这两节都提到了一个需求：知道自己每个月大概要花多少钱。怎么实现呢？</p>
<p>记账！</p>
<p>通过记账我们可以知道钱从哪里来，要到哪里去，并且据此来设置合理的预算，慢慢达成我们想要的目标。记账虽然比较繁琐，但是其实每次记一笔，不会多花很多时间，而且随着数据积累的增加，效率也会越来越高，坚持半年一年再看看，应该就能比较了解自己的消费习惯了。</p>
<p>另外就是要定期进行资产统计，比方说存量里的各个类别各自有多少，有没有什么变化，是不是维持了比较合适的比例。</p>
<p>一句话总结：<strong>坚持是最重要的策略，长期的数据中有很多秘密，要努力去挖掘和利用</strong>。</p>
<h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><p>重要是去读一读，然后结合实际生活运用，我就不列太多了。</p>
<ul>
<li>《富爸爸，穷爸爸》</li>
<li>《小狗钱钱》</li>
<li>《邻家的百万富翁》</li>
<li>《在星巴克要买大杯咖啡》</li>
<li>《个人理财》</li>
<li>《穷查理宝典》</li>
<li>《思考致富》</li>
<li>《管道的力量》</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.duokan.com/search/%E9%9B%AA%E7%90%83/1" target="_blank" rel="external">雪球系列</a></li>
<li><a href="http://www.duokan.com/search/%E5%A5%B9%E7%90%86%E8%B4%A2/1" target="_blank" rel="external">她理财系列</a></li>
<li><a href="http://www.duokan.com/search/%E7%AE%80%E4%B8%83/1" target="_blank" rel="external">简七理财系列</a></li>
<li><a href="https://www.zhihu.com/question/21781920" target="_blank" rel="external">理财小白如何理财</a></li>
<li><a href="https://www.zhihu.com/question/50138948" target="_blank" rel="external">个人理财有哪些冷门但不可缺少的知识</a></li>
<li><a href="https://www.zhihu.com/question/19575803" target="_blank" rel="external">个人理财有哪些基本原理和方法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理财与其说是一种行为和方法，不如说是一种以系统性思维看待金钱的生活方式。对于大部分人来说，重要的是理清基本概念，形成一套适合自己的简便易执行的理财方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="生活" scheme="http://wdxtub.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="理财" scheme="http://wdxtub.com/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>【我在故宫修文物】观自</title>
    <link href="http://wdxtub.com/2017/01/31/masters-in-forbidden-city-movie/"/>
    <id>http://wdxtub.com/2017/01/31/masters-in-forbidden-city-movie/</id>
    <published>2017-01-30T23:38:36.000Z</published>
    <updated>2017-01-31T00:47:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>以自身来观物，又以物来观自身。通过『物』的传承来固化那些看起来虚无缥缈的东西，并以此体现人的意识与审美，是特别有价值的事情。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.13: 完成初稿</li>
</ul>
<p>当我第一次在 CMU 的休息室里看到同学的屏幕上出现在故宫修文物的时候，有些意外也有些感动，意外是因为看起来这并不在程序员的值域中，感动是因为终于出现了一部让『外行』也愿意看的纪录片。尤其是『择一事，终一生』的态度，确实是当下社会亟需弘扬和传承的。在故宫修文物这个主题有太多可以着墨的地方，却正因如此变得难以展开。导演想要表达的内容太多，最终呈现出来的却没有把点连成线，于是成了一地散落的珠子。不过吧，这才是刚开始，摸着石头过河也是正常，只要匠艺仍在，其他的都可以慢慢来。</p>
<p><img src="/images/14858205417946.jpg" alt=""></p>
<p>纪录片也是需要剧情来贯穿情节的，不然可以记录的面太多，让人有些难以跟上导演的节奏。以本片为例，完全可以用『修复技术展览』为明线把不同的技艺串联起来，比现在这样松散着堆叠素材要好。好，关于本片拍摄部分的点评到此为止，接下来就说说我的感想。</p>
<p>修文物是一个特别传统的手艺活，需要一代代的传承，所以最重要的就是培养人。培养人的第一步就是磨练耐性，修复不比创作，很多时候是得以静制动，从学生转换为匠人的过程必然是痛苦的，但既然迈出了第一步，扛起了这个担子，就要一直坚持下去。说得虚一点，有了想要保护某样东西的心情，很多困难是可以克服的。</p>
<p>做事先要做人，在修复文物的同时，也是在补完自身，毕竟这些器物上承载了太多太多，天天接触总是会浸染一些。看得过程中，我觉得他们的精神状态特别好，放松但不随意，严谨但不呆板，精确但不教条，真乃巧手以既拙作也。</p>
<p>一件事情做久了，自然也有了感情。片中一位快要退休的工作人员饱含深情说即使退休了，但是如果需要，也会义无反顾的返聘回来。忽然意识到，这和退役军人一样，只要祖国需要，还是会义无反顾的入伍。</p>
<p>每当这个时候，我就会想，能够找到坚持一生的事情，无论是机缘巧合歪打误撞，都是很幸福的事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以自身来观物，又以物来观自身。通过『物』的传承来固化那些看起来虚无缥缈的东西，并以此体现人的意识与审美，是特别有价值的事情。&lt;/p&gt;
    
    </summary>
    
      <category term="Movie" scheme="http://wdxtub.com/categories/Movie/"/>
    
    
      <category term="电影" scheme="http://wdxtub.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="故宫" scheme="http://wdxtub.com/tags/%E6%95%85%E5%AE%AB/"/>
    
      <category term="文物" scheme="http://wdxtub.com/tags/%E6%96%87%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>【小土刀玩摄影】ζ Mavic Pro 调教指南</title>
    <link href="http://wdxtub.com/2017/01/30/mavic-pro-setting-guide/"/>
    <id>http://wdxtub.com/2017/01/30/mavic-pro-setting-guide/</id>
    <published>2017-01-30T12:22:09.000Z</published>
    <updated>2017-01-30T14:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mavic Pro 是大疆于 2016 年 9 月推出的个人航拍飞行器，便携且强大，但实际拍摄时出片率较低。这里分享一些简单的『调教』技巧，让大家更容易拍出大片。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.30: 完成初稿</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>拿到 Mavic Pro 之后也已经飞了几十次了，携带是方便了很多，但是拍摄的时候始终感觉『有力无处使』，无论是镜头控制还是拍摄录像的体验都不如之前我飞的 Phantom 系列。总结起来，不如意的地方有：</p>
<ol>
<li>云台的默认设置过于灵敏，调整角度时顿挫感强烈，拍出来的视频比较生硬</li>
<li>飞行器的默认设置过于灵敏，尤其是转动机身时，加速之后看着头晕</li>
<li>静态图片和视频的成像风格差异极大，拍照成像对比度和锐度过高</li>
<li>控制模式过多，很多模式感觉像是强加上去的，重复且逻辑层级不一致</li>
</ol>
<p><img src="/images/14857830080685.jpg" alt=""></p>
<p>今天在逛 youtube 的时候看到了几个国外爱好者拍的视频，结合自己的飞行拍摄经验，尝试了一下他们介绍的『调教』方法，感觉不错，可以基本解决上面提到的几个问题，在这里分享给大家（原视频见最后的参考链接）。</p>
<h2 id="飞行设置"><a href="#飞行设置" class="headerlink" title="飞行设置"></a>飞行设置</h2><p>为了解决飞行过于敏捷导致的画面不稳定，我们需要进入飞行器的高级设置，把机身转动的曲线弄得『弧度』大一些，简单来说就是，只要左摇杆不是推到最左边或者最右边，实际的转动是远小于物理上距离的改变量的，这里我们把中间那里调为 0.20，这样摇杆打到一半，实际的转动约为四分之一。</p>
<p><img src="/images/14857830791508.jpg" alt=""></p>
<p>灵敏度的调整思路和上面一样，这里主要降低的是姿态和偏航行程这两项。</p>
<p><img src="/images/14857831106853.jpg" alt=""></p>
<p>感度的调整只需要改动『偏航』部分，我们所做的都是为了尽可能 Mavic 不那么『敏捷』从而得到较好的录制效果。</p>
<p><img src="/images/14857831312862.jpg" alt=""></p>
<h2 id="云台设置"><a href="#云台设置" class="headerlink" title="云台设置"></a>云台设置</h2><p>云台的设置同理，俯仰轴灵敏度调低一些，这样拨动滚轮所触发的镜头调整的幅度较小，不会出现画面突变的问题。而俯仰缓启/停则是在操作前后都预留一定的缓冲，不会出现镜头忽然变化的问题。</p>
<p><img src="/images/14857832035108.jpg" alt=""></p>
<h2 id="遥控器设置"><a href="#遥控器设置" class="headerlink" title="遥控器设置"></a>遥控器设置</h2><p>这里的设置主要是方便快捷操作，既然买了遥控器就要把遥控器用起来嘛。自定义按钮一个是手动中心点对焦，建议拍摄之前多按几次，不然很容易对不上焦。至于开启/关闭前臂灯，主要是夜间飞行的时候方便找 Mavic 以及拍摄时关闭以免影响画面。在天上的时间很宝贵，所以能快十几秒就很好了。</p>
<p><img src="/images/14857831664572.jpg" alt=""></p>
<p>至于这个五维按键呢，建议一定要把竖向拍摄和 AE 锁定给选出来（竖向拍摄操作太反人类，AE 锁定容易点错），至于数码变焦其实意义不大。</p>
<p><img src="/images/14857831802385.jpg" alt=""></p>
<h2 id="镜头设置"><a href="#镜头设置" class="headerlink" title="镜头设置"></a>镜头设置</h2><p>拍摄静态照片的设置让我非常头疼，有两个方法可以解决，一个是开启智能跟随或者其他什么的智能模式，这样会自动调整镜头的设置，要么就考虑使用下图所示的自定义风格。前者简单粗暴，后者可以根据不同的需要进行调整，总而言之不要用默认的和自带的设置就好（颜色实在是太糟糕了）。</p>
<p><img src="/images/14857832326754.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后强调一句，飞行这个事儿是非常主观的体验，还是要不断摸索找到自己最舒服的飞行方式。当然，最重要的，注意飞行安全，最近已经有不少朋友把 Mavic 弄坏了，虽然有保险，但安全是一刻也不能放下的。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.youtube.com/watch?v=2K-6-p1pgao" target="_blank" rel="external">Ultimate DJI Mavic setup hacks! How to get super-smooth pro-looking drone footage</a></li>
<li><a href="https://www.youtube.com/watch?v=BmWqfJCwbfI" target="_blank" rel="external">DJI Mavic Pro: Essential camera settings for amazing pictures</a></li>
<li><a href="https://www.youtube.com/watch?v=wMkZQWmoBeU" target="_blank" rel="external">Best Video Settings (Res/FPS) - DJI Mavic Pro</a></li>
<li><a href="https://www.youtube.com/watch?v=6kfuJxF3PUM" target="_blank" rel="external">Best Settings (sensitivity setup) - DJI Mavic Pro</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mavic Pro 是大疆于 2016 年 9 月推出的个人航拍飞行器，便携且强大，但实际拍摄时出片率较低。这里分享一些简单的『调教』技巧，让大家更容易拍出大片。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="航拍" scheme="http://wdxtub.com/tags/%E8%88%AA%E6%8B%8D/"/>
    
      <category term="Mavic" scheme="http://wdxtub.com/tags/Mavic/"/>
    
      <category term="设置" scheme="http://wdxtub.com/tags/%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>【致命 ID】自我认同</title>
    <link href="http://wdxtub.com/2017/01/30/identity-movie/"/>
    <id>http://wdxtub.com/2017/01/30/identity-movie/</id>
    <published>2017-01-30T05:32:18.000Z</published>
    <updated>2017-01-30T10:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到最后我忽然意识到，迷失自己有两种，一种是不知道自己在哪里，另一种是不知道自己到底是哪个自己。注：高能剧透预警。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.30: 完成初稿</li>
</ul>
<p>一开始看影片简介还以为是『风暴山庄』类型片，但片中两条线交汇的瞬间有种精神与现实融合的感觉，相互残杀的即使是人格本身，也只能孕育出新的怨恨吧。纵使躲藏伪装惩罚原谅，剩下来的只不过是最深的孤独。想了很久，还是觉得看电影嘛，没有必要过分解读，接下来就简单说一说我的理解吧。</p>
<p><img src="/images/14857544144175.jpg" alt=""></p>
<p>简单过一下剧情，一个杀人犯准备被处死的前夜，找到一本日记本证明这个杀人犯有人格分裂症需要改判。但是也不能说有精神病就有精神病，于是当着大法官的面一边做治疗一边展现多重人格。在整个展现的过程中，在精神世界里发生了人格间的残杀，最终剩下了一个看起来比较『无害』的人格。可惜道高一尺魔高一丈，隐藏大 boss 并没有被消灭，怨恨仍在，罪恶并没有消散。</p>
<p>精神世界中一共死了十个人格，有意思的是，他们拿着的号码牌正是死亡顺序，并且先死的是比较弱的人格，这些人格分别是：</p>
<ol>
<li>过气女明星：势利自私，最先被干掉</li>
<li>Lou：新婚丈夫，瞎结婚是错误（虽然怎么样都是炮灰）</li>
<li>囚犯：被锁在厕所，逃跑，但无路可逃</li>
<li>小男孩父亲：继父、有责任心、教条、弱势</li>
<li>小男孩母亲：关爱、照顾</li>
<li>Ginny：新婚妻子，骗婚，被炸死</li>
<li>Larry：假老板，一事无成，贪婪</li>
<li>Rhodes：假警察，恶人格</li>
<li>Edward：司机，好人格</li>
<li>Paris：妓女，本来应该炸死的是这个人格，但后来被小男孩杀死</li>
</ol>
<p>最后剩下的就是小男孩了，代表着原罪的本我，装载着全部的怨恨。上面的各种人格，无论是善是恶，其实都是杀人犯成长和回忆的内在投射。所以各种解读其实各有各的道理，我就不添油加醋了。</p>
<p>最后还是提一下首尾呼应的那首诗：</p>
<blockquote>
<p>When I was going up the stairs 当我上楼时<br>I met a man who wasn’t there 碰见一个原本不在那里的人<br>He wasn’t there again today 今天他又不在那里了<br>I wish I wish he’d go away 我希望…我希望他已经离开了 …… </p>
</blockquote>
<p>所以说，有个幸福的家庭和快乐的童年，是多么重要哇。自我认同这个东西出了偏差，想要扭转就好难了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到最后我忽然意识到，迷失自己有两种，一种是不知道自己在哪里，另一种是不知道自己到底是哪个自己。注：高能剧透预警。&lt;/p&gt;
    
    </summary>
    
      <category term="Movie" scheme="http://wdxtub.com/categories/Movie/"/>
    
    
      <category term="悬疑" scheme="http://wdxtub.com/tags/%E6%82%AC%E7%96%91/"/>
    
      <category term="人格" scheme="http://wdxtub.com/tags/%E4%BA%BA%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>【C++ Primer】读书笔记</title>
    <link href="http://wdxtub.com/2017/01/30/cpp-primer-clip/"/>
    <id>http://wdxtub.com/2017/01/30/cpp-primer-clip/</id>
    <published>2017-01-30T02:14:26.000Z</published>
    <updated>2017-01-30T11:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>时隔这么多年又拿起了这本书，简单挑选一些内容作为温故知新的笔记。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.29: 完成初稿</li>
</ul>
<p>C++ 并没有直接定义进行输入或输出的任何语句，这种功能是由标准库提供的。</p>
<p>在写 C++ 程序时，大部分出现空格符的地方可用换行符代替。这条规则的一个例外是字符串字面值中的空格符不能用换行符代替。另一个例外是空格符不允许出现在预处理指示中。</p>
<p>类机制是 C++ 最重要的特征之一。</p>
<p>标准库的头文件用尖括号，非标准库的头文件用双引号括起来。</p>
<p>字符类型有两种：<code>char</code> 和 <code>wchar_t</code>，其中 <code>wchar_t</code> 用于扩展字符集，比如汉字和日语，这些字符集中的一些字符不能用单个 <code>char</code> 表示。</p>
<p>程序不应该依赖未定义行为。</p>
<p>在 C++ 中理解『初始化不是赋值』是必要的。初始化值指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。</p>
<p>直接初始化语法更灵活且效率更高。</p>
<p>通常把一个对象定义在它首次使用的地方是一个很好的方法。</p>
<p>非 const 变量默认为 extern。要使 const 变量能够在其他的文件中访问，必须显式地制定它为 extern。</p>
<p>当引用初始化后，只要该引用存在，它就保持绑定到初始化时指向的对象。不可能将引用绑定到另一个对象。</p>
<p>非 const 引用只能绑定到与该引用同类型的对象。const 引用则可以绑定到不同但相关的类型的对象或绑定到右值。</p>
<p><code>typedef</code> 通常被用于以下三种目的：</p>
<ul>
<li>为了隐藏特定类型的实现，强调使用</li>
<li>简化负责的类型定义，使其更易理解</li>
<li>允许一种类型用于多个目的，同时使得每次使用该类型的目的明确</li>
</ul>
<p>编程新手经常会忘记类定义后面的分号，这是个很普遍的错误！</p>
<p>用 class 和 struct 关键字定义类的唯一差别在于默认访问级别：默认情况下，struct 的成员为 public，而 class 的成员为 private。</p>
<p>头文件应该含有保护符，即使这些头文件不会被其他头文件包含。编写头文件保护符并不困难，而且如果头文件被包含多次，它可以避免难以理解的编译错误。</p>
<p>通常，头文件中应该只定义确实必要的东西。请养成这个好习惯。</p>
<p>任何存储 string 的 size 操作结果的变量必须为 <code>string::size_type</code> 类型。特别重要的是，不要把 size 的返回值赋给一个 int 变量。</p>
<p>vector 不是一种数据类型，而只是一个类模板，可以用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。因此，<code>vector&lt;int&gt;</code> 和 <code>vector&lt;string&gt;</code> 都是数据类型。</p>
<p>现代 C++ 程序应尽量使用 vector 和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。</p>
<p>除非显式地提供元素初值，否则内置类型的局部数组的元素没有初始化。此时，除了给元素赋值外，其他使用这些元素的操作没有定义。</p>
<p>一些编译器允许将数组赋值作为编译器扩展，但是如果希望编写的程序能在不同的编译器上运行，则应该避免使用像数组赋值这类依赖于编译器的非标准功能。</p>
<p>指针和数组容易产生不可预料的错误。其中一部分是概念上的问题：指针用于低级操作，容易产生与繁琐细节相关的错误。其他错误则源于使用指针的语法规则，特别是声明指针的语法。</p>
<p>很多运行时错误都源于使用了未初始化的指针。</p>
<p>如果可能的话，除非所指向的对象已经存在，否则不要先定义指针，这样可避免定义一个未初始化的指针。如果必须分开定义指针和其所指向的对象，则将指针初始化为 0，因为编译器可检测出 0 值的指针，程序可判断该指针并未指向一个对象。</p>
<p>指针的算术操作只有在原指针和计算出来的新指针都指向同一个数组的元素，或指向该数组存储空间的下一单元才是合法的。如果指针指向一对象，我们还可以在指针上加 1 从而获取指向相邻的下一个对象的指针。</p>
<p>C++ 允许计算数组或对象的超出末端的地址，但不允许对此地址进行解引用操作。而计算数组超出末端位置之后或数组首地址之前的地址都是不合法的。</p>
<p>不能使用指向 const 对象的指针修改基础对象，然而如果该指针指向的是一个非 const 对象，可用其他方法修改其所指的对象。</p>
<p>尽管 C++ 支持 C 风格字符串，但不应该在 C++ 程序中使用这个类型。C 风格字符串常常带来许多错误，是导致大量安全问题的根源。</p>
<p>对于动态分配的数组，其元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。</p>
<p>对于位操作符，由于系统不能确保如何处理其操作数的符号位，所以强烈建议使用 unsigned 整型操作数。</p>
<p>一般而言，标准库提供的 bitset 操作更直接、更容易阅读和书写、正确使用的可能性更高。而且，bitset 对象的大小不受 unsigned 数的位数限制。通常来说，bitset 优于整型数据的低级直接位操作。</p>
<p>一旦删除了指针所指向的对象，立即将指针置为 0，这样就非常清除地表明指针不再指向任何对象。</p>
<p>虽然有时候确实需要强制类型转换，但是它们本质上是非常危险的。</p>
<p>使用空语句时应该加上注释，以便任何读这段代码的人都知道该语句是有意省略的。</p>
<p>无关的空语句并非总是无害的。</p>
<p>故意省略 case 后面的 break 语句是很罕见的，因此应该提供一些注释说明其逻辑。</p>
<p>在循环条件中定义的变量在每次循环里都要经历创建和撤销的过程。</p>
<p>如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为 const 引用。</p>
<p>通常，函数不应该有 vector 或其他标准库容器类型的形参。调用含有普通的非引用 vector 形参的函数将会复制 vector 的每一个元素。C++ 程序员倾向于通过传递指向容器中需要处理的元素的迭代器来传递容器。</p>
<p>理解返回引用至关重要的是：千万不能返回局部变量的引用。</p>
<p>定义函数的源文件应该包含声明该函数的头文件。</p>
<p>在 C++ 中，名字查找发生在类型检查之前。</p>
<p>如果指向函数的指针没有初始化，或者具有 0 值，则该指针不能在函数调用中使用。</p>
<p>为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。</p>
<p>使用迭代器编写程序时，必须留意哪些操作会式迭代器失效。使用无效迭代器将会导致严重的运行时错误。</p>
<p>任何 insert 或 push 操作都可能导致迭代器失效。当编写循环将元素插入到 vector 或 deque 容器中时，程序必须确保迭代器在每次循环后都得到更新。</p>
<p>不要存储 end 操作返回的迭代器。添加或删除 deque 或 vector 容器内的元素都会导致存储的迭代器失效。</p>
<p>最简单地来说，类就是定义了一个新的类型和一个新的作用域。</p>
<p>按照与成员声明一致的次序编写构造函数初始化列表十个好主意。此外、尽可能避免使用成员来初始化其他成员。</p>
<p>我们更喜欢使用默认实参，因为它减少代码重复。</p>
<p>如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数。它应该定义自己的构造函数来初始化这些成员。</p>
<p>通常，除非有明显的理由想要定义隐式转换，否则，单形参构造函数应该为 explicit。将构造函数设置为 explicit 可以避免错误，并且当转换有用时，用户可以显式地构造对象。</p>
<p>定义和使用构造函数几乎总是较好的。当我们为自己定义的类型提供一个默认构造函数时，允许编译器自动运行那个构造函数，以保证每个类对象在初次使用之前正确地初始化。</p>
<p>通常，将友元声明成组地放在类定义的开始或结尾是个好主意。</p>
<p>保证对象正好定义一次的最好办法，就是将 static 数据成员的定义放在包含类的非内联成员函数定义的文件中。</p>
<p>为了防止复制，类必须显式声明其复制构造函数为 private。</p>
<p>一般来说，最好显式或隐式定义默认构造函数和复制构造函数。只有不存在其他构造函数时才合成默认构造函数。如果定义类复制构造函数。也必须定义默认构造函数。</p>
<p>当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的指针或实际对象（而不是对象的引用）超出作用域时，才会运行析构函数。</p>
<p>如果类需要析构函数，则它也需要赋值操作符和复制构造函数，这是一个有用的经验法则。</p>
<p>基类通常应将派生类需要重定义的任意函数定义为虚函数。</p>
<p>一旦函数在基类中声明为虚函数，它就一直为虚函数，派生类无法改变该函数为虚函数这一事实。派生类重定义虚函数时，可以使用 virtual 保留字，但不是必须这样做。</p>
<p>只有成员函数中的代码才应该使用作用域操作符覆盖虚函数机制。</p>
<p>通过异常我们能够将问题的检测和问题的解决分离，这样程序的问题检测部分可以不必了解如何处理问题。</p>
<p>可能存在异常的程序以及分配资源的程序应该使用类来管理那些资源。</p>
<p>定义多个不相关类型的命名空间应该使用分离的文件，表示该命名空间定义的每个类型。</p>
<p>using 指示不声明命名空间成员名字的别名，相反，它具有将命名空间成员提升到包含命名空间本身和 using 指示的最近作用域的效果。</p>
<p>using 指示有用的一种情况是，用在命名空间本身的实现文件中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔这么多年又拿起了这本书，简单挑选一些内容作为温故知新的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp 编码风格指南</title>
    <link href="http://wdxtub.com/2017/01/29/cpp-style-guide/"/>
    <id>http://wdxtub.com/2017/01/29/cpp-style-guide/</id>
    <published>2017-01-29T01:33:22.000Z</published>
    <updated>2017-01-29T07:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离我第一次接触 Google Cpp 编码风格指南已经过去了八年，现在再来看看，感觉别有一番风味。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.29: 完成初稿</li>
</ul>
<p>本文来源于 <a href="https://github.com/zh-google-styleguide/zh-google-styleguide" target="_blank" rel="external">Google 开源项目风格指南 (中文版) </a>，版本 4.45。感谢原作者和译者的付出。这里主要是整理一下，方便自己阅读。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.</p>
<p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p>
<p>风格, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p>
<p>使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.</p>
<p>本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.</p>
<p>Google 主导的开源项目均符合本指南的规定.</p>
<p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>通常每一个 <code>.cc</code> 文件都有一个对应的 <code>.h</code> 文件. 也有一些常见例外, 如单元测试代码和只包含 <code>main()</code> 函数的 <code>.cc</code> 文件.</p>
<p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p>
<p>下面的规则将引导你规避使用头文件时的各种陷阱.</p>
<h3 id="Self-contained-头文件"><a href="#Self-contained-头文件" class="headerlink" title="Self-contained 头文件"></a>Self-contained 头文件</h3><blockquote>
<p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code>.</code>h 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code> 头文件的做法.</p>
</blockquote>
<p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 <code>#define</code> 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.</p>
<p>不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 <code>.inc</code> 文件扩展名。</p>
<p>如果 <code>.h</code> 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 <code>.cc</code> 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 <code>-inl.h</code> 文件里（译者注：过去该规范曾提倡把定义放到 <code>-inl.h</code> 里过）。</p>
<p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 <code>.cc</code> 文件里。</p>
<h3 id="define-保护"><a href="#define-保护" class="headerlink" title="#define 保护"></a>#define 保护</h3><blockquote>
<p>所有头文件都应该使用 <code>#define</code> 来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code> .<br>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 <code>foo</code> 中的头文件 <code>foo/src/bar/baz.h</code> 可按如下方式保护:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_BAZ_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_BAZ_H_</span></div><div class="line">…</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></div></pre></td></tr></table></figure>
<h3 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h3><blockquote>
<p>尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。</p>
</blockquote>
<p><strong>定义：</strong></p>
<p>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p>
<p><strong>优点：</strong></p>
<ul>
<li>前置声明能够节省编译时间，多余的 <code>#include</code> 会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够节省不必要的重新编译的时间。 <code>#include</code> 使代码因为头文件中无关的改动而被重新编译多次。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li>
<li>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li>
<li>前置声明来自命名空间 <code>std::</code> 的 symbol 时，其行为未定义。</li>
<li>很难判断什么时候该用前置声明，什么时候该用 <code>#include</code> 。极端情况下，用前置声明代替 <code>includes</code> 甚至都会暗暗地改变代码的含义：</li>
</ul>
<p>如果 <code>#include</code> 被 B 和 D 的前置声明替代，<code>test()</code> 就会调用 <code>f(void*)</code> . </p>
<ul>
<li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 <code>include</code> 冗长。</li>
<li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li>
</ul>
<p><strong>结论</strong>：</p>
<ul>
<li>尽量避免前置声明那些定义在其他项目中的实体.</li>
<li>函数：总是使用 <code>#include</code>.</li>
<li>类模板：优先使用 <code>#include</code>.</li>
</ul>
<p>至于什么时候包含头文件，参见 name-and-order-of-includes。</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><blockquote>
<p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</p>
<p><strong>优点:</strong></p>
<p>只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p>
<p><strong>缺点:</strong></p>
<p>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p>
<p><strong>结论:</strong></p>
<p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<p>另一个实用的经验准则: 内联那些包含循环或 <code>switch</code> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <code>switch</code> 语句从不被执行).</p>
<p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p>
<h3 id="include-的路径及顺序"><a href="#include-的路径及顺序" class="headerlink" title="#include 的路径及顺序"></a>#include 的路径及顺序</h3><blockquote>
<p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.</p>
</blockquote>
<p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <code>.</code> (当前目录) 或 <code>..</code> (上级目录). 例如, <code>google-awesome-project/src/base/logging.h</code> 应该按如下方式包含:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/logging.h"</span></span></div></pre></td></tr></table></figure>
<p>又如, <code>dir/foo.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p>
<ol>
<li><code>dir2/foo2.h</code> (优先位置, 详情如下)</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的 <code>.h</code> 文件</li>
<li>本项目内 <code>.h</code> 文件</li>
</ol>
<p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p>
<p><code>dir/foo.cc</code> 和 <code>dir2/foo2.h</code> 通常位于同一目录下 (如 <code>base/basictypes_unittest.cc</code> 和 <code>base/basictypes.h</code>), 但也可以放在不同目录下.</p>
<p>按字母顺序对头文件包含进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p>
<p>您所依赖的 symbols 被哪些头文件所定义，您就应该包含（include）哪些头文件，forward-declaration 情况除外。比如您要用到 <code>bar.h</code> 中的某个 symbol, 哪怕您所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code> 就够了，不用再管后者所包含的其它内容。</p>
<p>举例来说, <code>google-awesome-project/src/foo/internal/fooserver.cc</code> 的包含次序如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/fooserver.h"</span> <span class="comment">// 优先位置</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hash_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/basictypes.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/commandlineflags.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/bar.h"</span></span></div></pre></td></tr></table></figure>
<p><strong>例外：</strong></p>
<p>有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/fooserver.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/port.h"</span>  <span class="comment">// For LANG_CXX11.</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LANG_CXX11</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// LANG_CXX11</span></span></div></pre></td></tr></table></figure>
<p>译者 (YuleFox) 笔记</p>
<ol>
<li>避免多重包含是学编程时最基本的要求;</li>
<li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li>
<li>内联函数的合理使用可提高代码执行效率;</li>
<li><code>-inl.h</code> 可提高代码可读性 (一般用不到吧:D);</li>
<li>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li>
<li>包含文件的名称使用 <code>.</code> 和 <code>..</code> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</li>
</ol>
<p>译者（acgtyrant）笔记</p>
<ol>
<li>原来还真有项目用 <code>#includes</code> 来插入文本，且其文件扩展名 <code>.inc</code> 看上去也很科学。</li>
<li>Google 已经不再提倡 <code>-inl.h</code> 用法。</li>
<li>注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li>
<li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 <code>.cc</code> 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li>
<li>在 <code>#include</code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code>.h</code> 和本项目内的 <code>.h</code> 是个好习惯。</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><blockquote>
<p>鼓励在 <code>.cc</code> 文件内使用匿名名字空间. 使用具名的名字空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>名字空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.</p>
<p><strong>优点:</strong></p>
<p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 名字空间在这基础上又封装了一层.</p>
<p>举例来说, 两个不同项目的全局作用域都有一个类 <code>Foo</code>, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同名字空间中, <code>project1::Foo</code> 和 <code>project2::Foo</code> 作为不同符号自然不会冲突.</p>
<p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> X &#123;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y &#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>X::Y::foo()</code> 与 <code>X::foo()</code> 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p>
<p><strong>缺点:</strong></p>
<p>名字空间具有迷惑性, 因为它们和类一样提供了额外的 (可嵌套的) 命名轴线.</p>
<p>命名空间很容易令人迷惑，毕竟它们不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p>
<p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</p>
<p><strong>结论:</strong></p>
<p>根据下文将要提到的策略合理使用命名空间.</p>
<h4 id="匿名名字空间"><a href="#匿名名字空间" class="headerlink" title="匿名名字空间"></a>匿名名字空间</h4><p>在 <code>.cc</code> 文件中, 允许甚至鼓励使用匿名名字空间, 以避免运行时的命名冲突:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> &#123;                             <span class="comment">// .cc 文件中</span></div><div class="line"></div><div class="line"><span class="comment">// 名字空间的内容无需缩进</span></div><div class="line"><span class="keyword">enum</span> &#123; kUNUSED, kEOF, kERROR &#125;;         <span class="comment">// 经常使用的符号</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AtEof</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pos_ == kEOF; &#125;   <span class="comment">// 使用本名字空间内的符号 EOF</span></div><div class="line"></div><div class="line">&#125; <span class="comment">// namespace</span></div></pre></td></tr></table></figure>
<p>然而, 与特定类关联的文件作用域声明在该类中被声明为类型, 静态数据成员或静态成员函数, 而不是匿名名字空间的成员. 如上例所示, 匿名空间结束时用注释 <code>// namespace</code> 标识.</p>
<p>不要在 <code>.h</code> 文件中使用匿名名字空间.</p>
<h4 id="具名的名字空间"><a href="#具名的名字空间" class="headerlink" title="具名的名字空间"></a>具名的名字空间</h4><p>具名的名字空间使用方式如下:</p>
<p>用名字空间把文件包含, gflags 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它名字空间:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// .h 文件</span></div><div class="line"><span class="keyword">namespace</span> mynamespace &#123;</div><div class="line"></div><div class="line"><span class="comment">// 所有声明都置于命名空间中</span></div><div class="line"><span class="comment">// 注意不要使用缩进</span></div><div class="line"><span class="keyword">class</span> MyClass &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    …</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&#125; <span class="comment">// namespace mynamespace</span></div><div class="line"><span class="comment">// .cc 文件</span></div><div class="line"><span class="keyword">namespace</span> mynamespace &#123;</div><div class="line"></div><div class="line"><span class="comment">// 函数定义都置于命名空间中</span></div><div class="line"><span class="keyword">void</span> MyClass::Foo() &#123;</div><div class="line">    …</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125; <span class="comment">// namespace mynamespace</span></div></pre></td></tr></table></figure>
<p>通常的 <code>.cc</code> 文件包含更多, 更复杂的细节, 比如引用其他名字空间的类等.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> “a.h”</span></div><div class="line"></div><div class="line">DEFINE_bool(someflag, <span class="literal">false</span>, “dummy flag”);</div><div class="line"></div><div class="line"><span class="keyword">class</span> C;                    <span class="comment">// 全局名字空间中类 C 的前置声明</span></div><div class="line"><span class="keyword">namespace</span> a &#123; <span class="keyword">class</span> A; &#125;    <span class="comment">// a::A 的前置声明</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> b &#123;</div><div class="line"></div><div class="line">…code <span class="keyword">for</span> b…                <span class="comment">// b 中的代码</span></div><div class="line"></div><div class="line">&#125; <span class="comment">// namespace b</span></div></pre></td></tr></table></figure>
<p>不要在名字空间 <code>std</code> 内声明任何东西, 包括标准库的类前置声明. 在 <code>std</code> 名字空间声明实体会导致不确定的问题, 比如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</p>
<p>最好不要使用 <code>using</code> 指示，以保证名字空间下的所有名称都可以正常使用.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 禁止 —— 污染名字空间</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</div></pre></td></tr></table></figure>
<p>在 <code>.cc</code> 文件, <code>.h</code> 文件的函数, 方法或类中, 可以使用 using 声明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 允许: .cc 文件中</span></div><div class="line"><span class="comment">// .h 文件的话, 必须在函数, 方法或类的内部使用</span></div><div class="line"><span class="keyword">using</span> ::foo::bar;</div></pre></td></tr></table></figure>
<p>在 <code>.cc</code> 文件, <code>.h</code> 文件的函数, 方法或类中, 允许使用名字空间别名.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 允许: .cc 文件中</span></div><div class="line"><span class="comment">// .h 文件的话, 必须在函数, 方法或类的内部使用</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</div><div class="line"></div><div class="line"><span class="comment">// 在 .h 文件里</span></div><div class="line"><span class="keyword">namespace</span> librarian &#123;</div><div class="line"><span class="comment">//以下别名在所有包含了该头文件的文件中生效。</span></div><div class="line"><span class="keyword">namespace</span> pd_s = ::pipeline_diagnostics::sidetable;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// namespace alias local to a function (or method).</span></div><div class="line">  <span class="keyword">namespace</span> fbz = ::foo::bar::baz;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">&#125;  <span class="comment">// namespace librarian</span></div></pre></td></tr></table></figure>
<p>注意在 <code>.h</code> 文件的别名对包含了该头文件的所有人可见，所以在公共头文件（在项目外可用）以及它们递归包含的其它头文件里，不要用别名。毕竟原则上公共 API 要尽可能地精简。<br>禁止用内联命名空间</p>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><blockquote>
<p>当公有嵌套类作为接口的一部分时, 虽然可以直接将他们保持在全局作用域中, 但将嵌套类的声明置于<code>名字空间</code>内是更好的选择.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>在一个类内部定义另一个类; 嵌套类也被称为 成员类 (member class).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo &#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Bar是嵌套在Foo中的成员类</span></div><div class="line">    <span class="keyword">class</span> Bar &#123;</div><div class="line">        …</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>优点:</strong></p>
<p>当嵌套 (或成员) 类只被外围类使用时非常有用; 把它作为外围类作用域内的成员, 而不是去污染外部作用域的同名类. 嵌套类可以在外围类中做前置声明, 然后在 <code>.cc</code> 文件中定义, 这样避免在外围类的声明中定义嵌套类, 因为嵌套类的定义通常只与实现相关.</p>
<p><strong>缺点:</strong></p>
<p>嵌套类只能在外围类的内部做前置声明. 因此, 任何使用了  <code>Foo::Bar*</code> 指针的头文件不得不包含类 <code>Foo</code> 的整个声明.</p>
<p><strong>结论:</strong></p>
<p>不要将嵌套类定义成公有, 除非它们是接口的一部分, 比如, 嵌套类含有某些方法的一组选项.</p>
<h3 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h3><blockquote>
<p>使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数.</p>
</blockquote>
<p><strong>优点:</strong></p>
<p>某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在名字空间内可避免污染全局作用域.</p>
<p><strong>缺点:</strong></p>
<p>将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.</p>
<p><strong>结论:</strong></p>
<p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个名字空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用<code>名字空间</code>。</p>
<p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的名字空间内.</p>
<p>如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名 <code>namespaces</code> 或 <code>static</code> 链接关键字 (如 <code>static int Foo() {...}</code>) 限定其作用域.</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><blockquote>
<p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p>
</blockquote>
<p>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line">i = f(); <span class="comment">// 坏——初始化和声明分离</span></div><div class="line"><span class="keyword">int</span> j = g(); <span class="comment">// 好——初始化时声明</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">v.push_back(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></div><div class="line">v.push_back(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 好——v 一开始就初始化</span></div></pre></td></tr></table></figure>
<p>注意, GCC 可正确实现了 <code>for (int i = 0; i &lt; 10; ++i)</code> (<code>i</code> 的作用域仅限 <code>for</code> 循环内), 所以其他 <code>for</code> 循环中可以重新使用 <code>i</code>. 在 <code>if</code> 和 <code>while</code> 等语句中的作用域声明也是正确的, 如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, ‘/’)) str = p + <span class="number">1</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>Warning: 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 低效的实现</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</div><div class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></div><div class="line">    f.DoSomething(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在循环作用域外面声明这类变量要高效的多:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</div><div class="line">    f.DoSomething(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h3><blockquote>
<p>禁止使用 <code>class</code> 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 <code>constexpr</code> 变量除外，毕竟它们又不涉及动态初始化或析构。</p>
</blockquote>
<p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是不确定的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数不涉及（比如 <code>getenv()</code> 或 <code>getpid()</code>）不涉及任何全局变量。（函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。）</p>
<p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 <code>main()</code> 返回还是对 <code>exit()</code> 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 <code>string</code> 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>改善以上析构问题的办法之一是用 <code>quick_exit()</code> 来代替 <code>exit()</code> 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 <code>atexit()</code> 所绑定的任何 handlers. 如果您想在执行 <code>quick_exit()</code> 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 <code>_at_quick_exit()</code>. 如果您想在 <code>exit()</code> 和 <code>quick_exit()</code> 都用上该 handler, 都绑定上去。</p>
<p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 <code>vector</code> (使用 C 数组替代) 和 <code>string</code> (使用 <code>const char []</code>)。</p>
<p>如果您确实需要一个 <code>class</code> 类型的静态或全局变量，可以考虑在 <code>main()</code> 函数或 <code>pthread_once()</code> 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p>
<blockquote>
<p>Note: 上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</p>
</blockquote>
<p>译者 (YuleFox) 笔记</p>
<ol>
<li><code>cc</code> 中的匿名名字空间可避免命名冲突, 限定作用域, 避免直接使用 <code>using</code> 关键字污染命名空间;</li>
<li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code>public</code>;</li>
<li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</li>
<li>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</li>
<li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</li>
</ol>
<p>译者（acgtyrant）笔记</p>
<ol>
<li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li>
<li>匿名名字空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li>
<li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li>
<li>注意别在循环犯大量构造和析构的低级错误。</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.</p>
<h3 id="构造函数的职责"><a href="#构造函数的职责" class="headerlink" title="构造函数的职责"></a>构造函数的职责</h3><blockquote>
<p>不要在构造函数中进行复杂的初始化 (尤其是那些有可能失败或者需要调用虚函数的初始化).</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>在构造函数体中进行初始化操作.</p>
<p><strong>优点:</strong></p>
<p>排版方便, 无需担心类是否已经初始化.</p>
<p><strong>缺点:</strong></p>
<p>在构造函数中执行操作引起的问题有:</p>
<ul>
<li>构造函数中很难上报错误, 不能使用异常.</li>
<li>操作失败会造成对象初始化失败，进入不确定状态.</li>
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</li>
<li>如果有人创建该类型的全局变量 (虽然违背了上节提到的规则), 构造函数将先 main() 一步被调用, 有可能破坏构造函数中暗含的假设条件. 例如, gflags 尚未初始化.</li>
</ul>
<p><strong>结论:</strong></p>
<p>构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 <code>Init()</code> 方法或使用工厂模式.</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote>
<p>如果类中定义了成员变量, 则必须在类中为每个类提供初始化函数或定义一个构造函数. 若未声明构造函数, 则编译器会生成一个默认的构造函数, 这有可能导致某些成员未被初始化或被初始化为不恰当的值.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p><code>new</code> 一个不带参数的类对象时, 会调用这个类的默认构造函数. 用 <code>new[]</code> 创建数组时, 默认构造函数则总是被调用. 在类成员里面进行初始化是指声明一个成员变量的时候使用一个结构例如 <code>int _count = 17</code> 或者 <code>string _name{&quot;abc&quot;}</code> 来替代 <code>int _count</code> 或者 <code>string _name</code> 这样的形式.</p>
<p><strong>优点:</strong></p>
<p>用户定义的默认构造函数将在没有提供初始化操作时将对象初始化. 这样就保证了对象在被构造之时就处于一个有效且可用的状态, 同时保证了对象在被创建时就处于一个显然”不可能”的状态, 以此帮助调试.</p>
<p><strong>缺点:</strong></p>
<p>对代码编写者来说, 这是多余的工作.</p>
<p>如果一个成员变量在声明时初始化又在构造函数中初始化, 有可能造成混乱, 因为构造函数中的值会覆盖掉声明中的值.</p>
<p><strong>结论:</strong></p>
<p>简单的初始化用类成员初始化完成, 尤其是当一个成员变量要在多个构造函数里用相同的方式初始化的时候.</p>
<p>如果你的类中有成员变量没有在类里面进行初始化, 而且没有提供其它构造函数, 你必须定义一个 (不带参数的) 默认构造函数. 把对象的内部状态初始化成一致 / 有效的值无疑是更合理的方式.</p>
<p>这么做的原因是: 如果你没有提供其它构造函数, 又没有定义默认构造函数, 编译器将为你自动生成一个. 编译器生成的构造函数并不会对对象进行合理的初始化.</p>
<p>如果你定义的类继承现有类, 而你又没有增加新的成员变量, 则不需要为新类定义默认构造函数.</p>
<h3 id="显式构造函数"><a href="#显式构造函数" class="headerlink" title="显式构造函数"></a>显式构造函数</h3><blockquote>
<p>对单个参数的构造函数使用 C++ 关键字 <code>explicit</code>.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>通常, 如果构造函数只有一个参数, 可看成是一种隐式转换. 打个比方, 如果你定义了 <code>Foo::Foo(string name)</code>, 接着把一个字符串传给一个以 <code>Foo</code> 对象为参数的函数, 构造函数 <code>Foo::Foo(string name)</code> 将被调用, 并将该字符串转换为一个 <code>Foo</code> 的临时对象传给调用函数. 看上去很方便, 但如果你并不希望如此通过转换生成一个新对象的话, 麻烦也随之而来. 为避免构造函数被调用造成隐式转换, 可以将其声明为 <code>explicit.</code></p>
<p>除单参数构造函数外, 这一规则也适用于除第一个参数以外的其他参数都具有默认参数的构造函数, 例如 <code>Foo::Foo(string name, int id = 42)</code>.</p>
<p><strong>优点:</strong></p>
<p>避免不合时宜的变换.</p>
<p><strong>缺点:</strong></p>
<p>无</p>
<p><strong>结论:</strong></p>
<p>所有单参数构造函数都必须是显式的. 在类定义中, 将关键字 <code>explicit</code> 加到单参数构造函数前: <code>explicit Foo(string name);</code></p>
<p>例外: 在极少数情况下, 拷贝构造函数可以不声明成 <code>explicit</code>. 作为其它类的透明包装器的类也是特例之一. 类似的例外情况应在注释中明确说明.</p>
<p>最后, 只有 std::initializer_list 的构造函数可以是非 explicit, 以允许你的类型结构可以使用列表初始化的方式进行赋值. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType m = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line"><span class="function">MyType <span class="title">MakeMyType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; &#125;</div><div class="line">TakeMyType(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</div></pre></td></tr></table></figure>
<h3 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h3><blockquote>
<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. string 类型就是一个可拷贝类型的例子.</p>
<p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). std::unique_ptr<int> 就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的.</int></p>
<p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.</p>
<p><strong>优点:</strong></p>
<p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器.</p>
<p>拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如 Clone(), CopyFrom() or Swap(), 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过 = 默认. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似省略不必要的拷贝这样的优化它们也更加合适.</p>
<p>移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰.</p>
<p><strong>缺点:</strong></p>
<p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成对象切割. 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误.</p>
<p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.<br>结论:</p>
<p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p>
<p>建议通过 <code>= default</code> 定义拷贝和移动操作. 定义非默认的移动操作目前需要异常. 时刻记得检测默认操作的正确性. 由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <code>public virtual Clone()</code> 和一个 <code>protected</code> 的拷贝构造函数以供派生类实现.</p>
<p>如果你的类不需要拷贝 / 移动操作, 请显式地通过 <code>= delete</code> 或其他手段禁用之.</p>
<h3 id="委派和继承构造函数"><a href="#委派和继承构造函数" class="headerlink" title="委派和继承构造函数"></a>委派和继承构造函数</h3><blockquote>
<p>在能够减少重复代码的情况下使用委派和继承构造函数.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>委派和继承构造函数是由 C++11 引进为了减少构造函数重复代码而开发的两种不同的特性. 通过特殊的初始化列表语法, 委派构造函数允许类的一个构造函数调用其他的构造函数. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">X::X(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name) : name_(name) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">X::X() : X(<span class="string">""</span>) &#123; &#125;</div></pre></td></tr></table></figure>
<p>继承构造函数允许派生类直接调用基类的构造函数, 一如继承基类的其他成员函数, 而无需重新声明. 当基类拥有多个构造函数时这一功能尤其有用. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Base &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Base();</div><div class="line">  Base(<span class="keyword">int</span> n);</div><div class="line">  Base(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s);</div><div class="line">  ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> Base::Base;  <span class="comment">// Base's constructors are redeclared here.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果派生类的构造函数只是调用基类的构造函数而没有其他行为时, 这一功能特别有用.</p>
<p><strong>优点:</strong></p>
<p>委派和继承构造函数可以减少冗余代码, 提高可读性. 委派构造函数对 Java 程序员来说并不陌生.</p>
<p><strong>缺点:</strong></p>
<p>使用辅助函数可以预估出委派构造函数的行为. 如果派生类和基类相比引入了新的成员变量, 继承构造函数就会让人迷惑, 因为基类并不知道这些新的成员变量的存在.</p>
<p><strong>结论:</strong></p>
<p>只在能够减少冗余代码, 提高可读性的前提下使用委派和继承构造函数. 如果派生类有新的成员变量, 那么使用继承构造函数时要小心. 如果在派生类中对成员变量使用了类内部初始化的话, 继承构造函数还是适用的.</p>
<h3 id="结构体-VS-类"><a href="#结构体-VS-类" class="headerlink" title="结构体 VS. 类"></a>结构体 VS. 类</h3><blockquote>
<p>仅当只有数据时使用 <code>struct</code>, 其它一概使用 <code>class</code>.</p>
</blockquote>
<p><strong>说明:</strong></p>
<p>在 C++ 中 struct 和 class 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便未定义的数据类型选择合适的关键字.</p>
<p>struct 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, Initialize(), Reset(), Validate() 等类似的函数外, 不能提供其它功能的函数.</p>
<p>如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class.</p>
<p>为了和 STL 保持一致, 对于仿函数和 trait 特性可以不用 class 而是使用 struct.</p>
<p>注意: 类和结构体的成员变量使用不同的命名规则.</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>使用组合 (composition, YuleFox 注: 这一点也是 GoF 在 &lt;<design patterns="">&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 <code>public</code> 继承.</design></p>
</blockquote>
<p><strong>定义:</strong></p>
<p>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承 (implementation inheritance), 子类继承父类的实现代码; 接口继承 (interface inheritance), 子类仅继承父类的方法名称.</p>
<p><strong>优点:</strong></p>
<p>实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.</p>
<p><strong>缺点:</strong></p>
<p>对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 还要区分基类的实际布局.</p>
<p><strong>结论:</strong></p>
<p>所有继承必须是 <code>public</code> 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p>
<p>不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 <code>Bar</code> 的确 “是一种” Foo, <code>Bar</code> 才能继承 <code>Foo</code>.</p>
<p>必要的话, 析构函数声明为 <code>virtual</code>. 如果你的类有虚函数, 则析构函数也应该为虚函数. 注意 数据成员在任何情况下都必须是私有的.</p>
<p>当重载一个虚函数, 在衍生类中把它明确的声明为 <code>virtual</code>. 理论依据: 如果省略 <code>virtual</code> 关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><blockquote>
<p>真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code>Interface</code> 为后缀的 纯接口类.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>多重继承允许子类拥有多个基类. 要将作为 纯接口 的基类和具有 实现 的基类区别开来.</p>
<p><strong>优点:</strong></p>
<p>相比单继承 (见 继承), 多重实现继承可以复用更多的代码.<br>缺点:</p>
<p>真正需要用到多重 实现 继承的情况少之又少. 多重实现继承看上去是不错的解决方案, 但你通常也可以找到一个更明确, 更清晰的不同解决方案.</p>
<p><strong>结论:</strong></p>
<p>只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀.</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote>
<p>接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制).</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>当一个类满足以下要求时, 称之为纯接口:</p>
<ul>
<li>只有纯虚函数 (“<code>=0</code>”) 和静态函数 (除了下文提到的析构函数).</li>
<li>没有非静态数据成员.</li>
<li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为  <code>protected</code>.</li>
<li>如果它是一个子类, 也只能从满足上述条件并以 <code>Interface</code> 为后缀的类继承.</li>
</ul>
<p>接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 The C++ Programming Language, 3rd edition 第 12.4 节.</p>
<p><strong>优点:</strong></p>
<p>以 <code>Interface</code> 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 多重继承 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</p>
<p><strong>缺点:</strong></p>
<p><code>Interface</code> 后缀增加了类名长度, 为阅读和理解带来不便. 同时，接口特性作为实现细节不应暴露给用户.</p>
<p><strong>结论:</strong></p>
<p>只有在满足上述需要时, 类才以 <code>Interface</code> 结尾, 但反过来, 满足上述需要的类未必一定以 <code>Interface</code> 结尾.</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote>
<p>除少数特定环境外，不要重载运算符.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>一个类可以定义诸如 <code>+</code> 和 <code>/</code> 等运算符, 使其可以像内建类型一样直接操作.</p>
<p><strong>优点:</strong></p>
<p>使代码看上去更加直观, 类表现的和内建类型 (如 int) 行为一致. 重载运算符使 <code>Equals()</code>, <code>Add()</code> 等函数名黯然失色. 为了使一些模板函数正确工作, 你可能必须定义操作符.</p>
<p><strong>缺点:</strong></p>
<p>虽然操作符重载令代码更加直观, 但也有一些不足:</p>
<ul>
<li>混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.</li>
<li>更难定位重载运算符的调用点, 查找 <code>Equals()</code> 显然比对应的 <code>==</code> 调用点要容易的多.</li>
<li>有的运算符可以对指针进行操作, 容易导致 bug. <code>Foo + 4</code> 做的是一件事, 而 <code>&amp;Foo + 4</code> 可能做的是完全不同的另一件事. 对于二者, 编译器都不会报错, 使其很难调试;</li>
<li>重载还有令你吃惊的副作用. 比如, 重载了 <code>operator&amp;</code> 的类不能被前置声明.</li>
</ul>
<p><strong>结论:</strong></p>
<p>一般不要重载运算符. 尤其是赋值操作 (<code>operator=</code>) 比较诡异, 应避免重载. 如果需要的话, 可以定义类似 <code>Equals()</code>, <code>CopyFrom()</code> 等函数.</p>
<p>然而, 极少数情况下可能需要重载运算符以便与模板或 “标准” C++ 类互操作 (如 <code>operator&lt;&lt;(ostream&amp;, const T&amp;)</code>). 只有被证明是完全合理的才能重载, 但你还是要尽可能避免这样做. 尤其是不要仅仅为了在 STL 容器中用作键值就重载 <code>operator==</code> 或 <code>operator&lt;</code>; 相反, 你应该在声明容器的时候, 创建相等判断和大小比较的仿函数类型.</p>
<p>有些 STL 算法确实需要重载 <code>operator==</code> 时, 你可以这么做, 记得别忘了在文档中说明原因.</p>
<p>参考 拷贝构造函数 和 函数重载.</p>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><blockquote>
<p>将 所有 数据成员声明为 <code>private</code>, 并根据需要提供相应的存取函数. 例如, 某个名为 <code>foo_</code> 的变量, 其取值函数是 <code>foo()</code>. 还可能需要一个赋值函数 <code>set_foo()</code>.</p>
</blockquote>
<p>特例是, 静态常量数据成员 (一般写做 kFoo) 不需要是私有成员.</p>
<p>一般在头文件中把存取函数定义成内联函数.</p>
<p>参考 继承 和 函数命名</p>
<h3 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h3><blockquote>
<p>在类中使用特定的声明顺序: <code>public:</code> 在 <code>private:</code> 之前, 成员函数在数据成员 (变量) 前;</p>
</blockquote>
<p>类的访问控制区段的声明顺序依次为: <code>public:</code>, <code>protected:</code>, <code>private:</code>. 如果某区段没内容, 可以不声明.</p>
<p>每个区段内的声明通常按以下顺序:</p>
<ul>
<li><code>typedefs</code> 和枚举</li>
<li>常量</li>
<li>构造函数</li>
<li>析构函数</li>
<li>成员函数, 含静态成员函数</li>
<li>数据成员, 含静态数据成员</li>
</ul>
<p>友元声明应该放在 <code>private</code> 区段. 如果用宏 <code>DISALLOW_COPY_AND_ASSIGN</code> 禁用拷贝和赋值, 应当将其置于 <code>private</code> 区段的末尾, 也即整个类声明的末尾. 参见可拷贝类型和可移动类型.</p>
<p><code>.cc</code> 文件中函数的定义应尽可能和声明顺序一致.</p>
<p>不要在类定义中内联大型函数. 通常, 只有那些没有特别意义或性能要求高, 并且是比较短小的函数才能被定义为内联函数. 更多细节参考 内联函数.</p>
<h3 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h3><blockquote>
<p>倾向编写简短, 凝练的函数.</p>
</blockquote>
<p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
<p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题. 甚至导致难以发现的 bug. 使函数尽量简短, 便于他人阅读和修改代码.</p>
<p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试困难, 或者你需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p>
<p><strong>译者 (YuleFox) 笔记</strong></p>
<ol>
<li>不在构造函数中做太多逻辑相关的初始化;</li>
<li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;</li>
<li>为避免隐式转换, 需将单参数构造函数声明为 <code>explicit</code>;</li>
<li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 <code>private</code> 且无需实现;</li>
<li>仅在作为数据集合时使用 <code>struct</code>;</li>
<li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 <code>virtual</code> 关键字, 虽然编译器允许不这样做;</li>
<li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;</li>
<li>接口类类名以 <code>Interface</code> 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话，声明为 <code>protected</code>;</li>
<li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;</li>
<li>存取函数一般内联在头文件中;</li>
<li>声明次序: <code>public</code> -&gt; <code>protected</code> -&gt; <code>private</code>;</li>
<li>函数体尽量短小, 紧凑, 功能单一;</li>
</ol>
<h2 id="其他-C-特性"><a href="#其他-C-特性" class="headerlink" title="其他 C++ 特性"></a>其他 C++ 特性</h2><h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><blockquote>
<p>所有按引用传递的参数必须加上 const.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明引用参数: <code>int foo(int &amp;val)</code>.</p>
<p><strong>优点:</strong></p>
<p>定义引用参数防止出现 <code>(*pval)++</code> 这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 <code>NULL</code> 指针.</p>
<p><strong>缺点:</strong></p>
<p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
<p><strong>结论:</strong></p>
<p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;in, <span class="built_in">string</span> *out)</span></span>;</div></pre></td></tr></table></figure>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code>const</code> 引用, 输出参数为指针. 输入参数可以是 <code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数，除非用于交换，比如 <code>swap()</code>.</p>
<p>有时候，在输入形参中用 <code>const T*</code> 指针比 <code>const T&amp;</code> 更明智。比如：</p>
<ul>
<li>您会传 null 指针。</li>
<li>函数要把指针或对地址的引用赋值给输入形参。</li>
</ul>
<p>总之大多时候输入形参往往是 <code>const T&amp;</code>. 若用 <code>const T*</code> 说明输入另有处理。所以若您要用 <code>const T*</code>, 则应有理有据，否则会害得读者误解。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><blockquote>
<p>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 <code>std::forward</code>.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, <code>void f(string&amp;&amp; s)</code>; 声明了一个其参数是一个字符串的右值引用的函数.</p>
<p><strong>优点:</strong></p>
<p>用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果 <code>v1</code> 是一个 <code>vector&lt;string&gt;</code>, 则 <code>auto v2(std::move(v1))</code> 将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升.</p>
<p>右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能, 无论其参数是否是临时对象都能正常工作.</p>
<p>右值引用能实现可移动但不可拷贝的类型, 这一特性对那些在拷贝方面没有实际需求, 但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.</p>
<p>要高效率地使用某些标准库类型, 例如 <code>std::unique_ptr</code>, <code>std::move</code> 是必需的.</p>
<p><strong>缺点:</strong></p>
<p>右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</p>
<p><strong>结论:</strong></p>
<p>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 <code>std::forward</code> 功能函数. 你可能会使用 <code>std::move</code> 来表示将值从一个对象移动而不是复制到另一个对象.</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><blockquote>
<p>若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数, 然后用另一个参数类型为 <code>const char*</code> 的函数重载它:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> MyClass &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;text)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *text, <span class="keyword">size_t</span> textlen)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>优点:</strong></p>
<p>通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利.</p>
<p><strong>缺点:</strong></p>
<p>如果函数单单靠不同的参数类型而重载（acgtyrant 注：这意味着参数数量不变），读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。</p>
<p><strong>结论:</strong></p>
<p>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等， 而不是一口气重载多个 <code>Append()</code>.</p>
<h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><blockquote>
<p>我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p>
</blockquote>
<p><strong>优点:</strong></p>
<p>当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</p>
<p><strong>缺点:</strong></p>
<p>缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复（acgtyrant 注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</p>
<p><strong>结论:</strong></p>
<p>由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数（acgtyrant 注：即不能再通过缺省参数来省略参数了）。</p>
<p>其一，位于 <code>.cc</code> 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</p>
<p>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</p>
<p>其三，可以用来模拟变长数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 通过空 AlphaNum 以支持四个形参</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">StrCat</span><span class="params">(<span class="keyword">const</span> AlphaNum &amp;a,</span></span></div><div class="line">              <span class="keyword">const</span> AlphaNum &amp;b = gEmptyAlphaNum,</div><div class="line">              <span class="keyword">const</span> AlphaNum &amp;c = gEmptyAlphaNum,</div><div class="line">              <span class="keyword">const</span> AlphaNum &amp;d = gEmptyAlphaNum);</div></pre></td></tr></table></figure>
<h3 id="变长数组和-alloca"><a href="#变长数组和-alloca" class="headerlink" title="变长数组和 alloca()"></a>变长数组和 <code>alloca()</code></h3><blockquote>
<p>我们不允许使用变长数组和 <code>alloca()</code>.</p>
</blockquote>
<p><strong>优点:</strong></p>
<p>变长数组具有浑然天成的语法. 变长数组和 <code>alloca()</code> 也都很高效.</p>
<p><strong>缺点:</strong></p>
<p>变长数组和 <code>alloca()</code> 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.</p>
<p><strong>结论:</strong></p>
<p>改用更安全的分配器（allocator），就像 <code>std::vector</code> 或 <code>std::unique_ptr&lt;T[]&gt;</code>.</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><blockquote>
<p>我们允许合理的使用友元类及友元函数.</p>
</blockquote>
<p>通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 <code>FooBuilder</code> 声明为 <code>Foo</code> 的友元, 以便 <code>FooBuilder</code> 正确构造 <code>Foo</code> 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.</p>
<p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 <code>public</code>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><blockquote>
<p>我们不使用 C++ 异常.</p>
</blockquote>
<p><strong>优点:</strong></p>
<ul>
<li>异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant 注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。</li>
<li>很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类 C++ 的语言更一脉相承。</li>
<li>有些第三方 C++ 库依赖异常，禁用异常就不好用了。</li>
<li>异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant 注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或 <code>Init()</code> 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态。</li>
<li>在测试框架里很好用。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>在现有函数中添加 <code>throw</code> 语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，<code>f()</code> 调用 <code>g()</code>, <code>g()</code> 又调用 <code>h()</code>, 且 <code>h</code> 抛出的异常被 <code>f</code> 捕获。当心 <code>g</code>, 否则会没妥善清理好。</li>
<li>还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。</li>
<li>异常安全需要RAII和不同的编码实践. 要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说, 为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交” 状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得.</li>
<li>启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。</li>
<li>滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。</li>
</ul>
<p><strong>结论:</strong></p>
<p>从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p>
<p>鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.</p>
<p>我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p>
<p>对于 Windows 代码来说, 有个 特例.</p>
<p>(YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的, 以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理, Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定)</p>
<h3 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h3><blockquote>
<p>我们禁止使用 RTTI.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 <code>typeid</code> 或者 <code>dynamic_cast</code> 完成.</p>
<p><strong>优点:</strong></p>
<p>RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中.</p>
<p>RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用.</p>
<p>在考虑多个抽象对象时 RTTI 也很好用. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> Base::Equal(Base* other) = <span class="number">0</span>;</div><div class="line"><span class="keyword">bool</span> Derived::Equal(Base* other) &#123;</div><div class="line">  Derived* that = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(other);</div><div class="line">  <span class="keyword">if</span> (that == <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>缺点:</strong></p>
<p>在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</p>
<p>随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 <code>switch</code> 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p>
<p><strong>结论:</strong></p>
<p>RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:</p>
<p>虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.</p>
<p>如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行类型判断.</p>
<p>如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 <code>dynamic_cast</code>. 在这种情况下, 使用 <code>dynamic_cast</code> 也是一种替代方案.</p>
<p>基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*data) == <span class="keyword">typeid</span>(D1)) &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeid</span>(*data) == <span class="keyword">typeid</span>(D2)) &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeid</span>(*data) == <span class="keyword">typeid</span>(D3)) &#123;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p>
<p>不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图.</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><blockquote>
<p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用 <code>int y = (int)x</code> 或 <code>int y = int(x)</code> 等转换方式;</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</p>
<p><strong>优点:</strong></p>
<p>C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 <code>(int)3.5</code>), 有时是在做类型转换 (如 <code>(int)&quot;hello&quot;</code>). 另外, C++ 的类型转换在查找时更醒目.</p>
<p><strong>缺点:</strong></p>
<p>恶心的语法.</p>
<p><strong>结论:</strong></p>
<p>不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p>
<ul>
<li>用 <code>static_cast</code> 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</li>
<li>用 <code>const_cast</code> 去掉 <code>const</code> 限定符.</li>
<li>用 <code>reinterpret_cast</code> 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</li>
</ul>
<p>至于 <code>dynamic_cast</code> 参见 运行时类型识别.</p>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><blockquote>
<p>只在记录日志时使用流.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>流用来替代 <code>printf()</code> 和 <code>scanf()</code>.</p>
<p><strong>优点:</strong></p>
<p>有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 <code>printf</code> 也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.</p>
<p><strong>缺点:</strong></p>
<p>流使得 <code>pread()</code> 等功能函数很难执行. 如果不使用 <code>printf</code> 风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 <code>%.*s</code>) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (<code>%1s</code>), 而这一点对于软件国际化很有用.</p>
<p><strong>结论:</strong></p>
<p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code> 之类的代替.</p>
<p>使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p>
<p><strong>拓展讨论:</strong></p>
<p>对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是 <code>printf + read/write</code>. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p>
<p>流的支持者们主张流是不二之选, 但观点并不是那么清晰有力. 他们指出的流的每个优势也都是其劣势. 流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警. 使用流时容易造成的这类错误:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>;   <span class="comment">// 输出地址</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; *<span class="keyword">this</span>;  <span class="comment">// 输出值</span></div></pre></td></tr></table></figure>
<p>由于 <code>&lt;&lt;</code> 被重载, 编译器不会报错. 就因为这一点我们反对使用操作符重载.</p>
<p>有人说 <code>printf</code> 的格式化丑陋不堪, 易读性差, 但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error connecting to '"</span> &lt;&lt; foo-&gt;bar()-&gt;hostname.first</div><div class="line">     &lt;&lt; <span class="string">":"</span> &lt;&lt; foo-&gt;bar()-&gt;hostname.second &lt;&lt; <span class="string">": "</span> &lt;&lt; strerror(errno);</div><div class="line"></div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error connecting to '%s:%u: %s"</span>,</div><div class="line">        foo-&gt;bar()-&gt;hostname.first, foo-&gt;bar()-&gt;hostname.second,</div><div class="line">        strerror(errno));</div></pre></td></tr></table></figure>
<p>你可能会说, “把流封装一下就会比较好了”, 这儿可以, 其他地方呢? 而且不要忘了, 我们的目标是使语言更紧凑, 而不是添加一些别人需要学习的新装备.</p>
<p>每一种方式都是各有利弊, “没有最好, 只有更适合”. 简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 <code>printf + read/write</code>.</p>
<h3 id="前置自增和自减"><a href="#前置自增和自减" class="headerlink" title="前置自增和自减"></a>前置自增和自减</h3><blockquote>
<p>对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>对于变量在自增 (++i 或 i++) 或自减 (–i 或 i–) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).</p>
<p><strong>优点:</strong></p>
<p>不考虑返回值的话, 前置自增 (++i) 通常要比后置自增 (i++) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝. 如果 i 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</p>
<p><strong>缺点:</strong></p>
<p>在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 for 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (i) 在谓语动词 (++) 前.</p>
<p><strong>结论:</strong></p>
<p>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</p>
<h3 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a><code>const</code> 用法</h3><blockquote>
<p>我们强烈建议你在任何可能的情况下都要使用 <code>const</code>. 此外有时改用 C++11 推出的 constexpr 更好。</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>在声明的变量或参数前加上关键字 <code>const</code> 用于指明变量值不可被篡改 (如 <code>const int foo</code> ). 为类中的函数加上 <code>const</code> 限定符表明该函数不会修改类成员变量的状态 (如 <code>class Foo { int Bar(char c) const; };</code>).</p>
<p><strong>优点:</strong></p>
<p>大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</p>
<p><strong>缺点:</strong></p>
<p><code>const</code> 是入侵性的: 如果你向一个函数传入 <code>const</code> 变量, 函数原型声明中也必须对应 <code>const</code> 参数 (否则变量需要 <code>const_cast</code> 类型转换), 在调用库函数时显得尤其麻烦.</p>
<p><strong>结论:</strong></p>
<p><code>const</code> 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 <code>const</code>:</p>
<ul>
<li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 <code>const</code>.</li>
<li>尽可能将函数声明为 <code>const</code>. 访问函数应该总是 <code>const</code>. 其他不会修改任何数据成员, 未调用非 <code>const</code> 函数, 不会返回数据成员非 <code>const</code> 指针或引用的函数也应该声明成 <code>const</code>.</li>
<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <code>const</code>.</li>
</ul>
<p>然而, 也不要发了疯似的使用 <code>const</code>. 像 <code>const int * const * const x;</code> 就有些过了, 虽然它非常精确的描述了常量 <code>x</code>. 关注真正有帮助意义的信息: 前面的例子写成 <code>const int** x</code> 就够了.</p>
<p>关键字 <code>mutable</code> 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.</p>
<p><code>const</code> 的位置:</p>
<p>有人喜欢 <code>int const *foo</code> 形式, 不喜欢 <code>const int* foo</code>, 他们认为前者更一致因此可读性也更好: 遵循了 <code>const</code> 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消大部分你原本想保持的一致性. 将 <code>const</code> 放在前面才更易读, 因为在自然语言中形容词 (<code>const</code>) 是在名词 (<code>int</code>) 之前.</p>
<p>这是说, 我们提倡但不强制 <code>const</code> 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把 <code>const</code> 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)</p>
<h3 id="constexpr-用法"><a href="#constexpr-用法" class="headerlink" title="constexpr 用法"></a><code>constexpr</code> 用法</h3><blockquote>
<p>在 C++11 里，用 <code>constexpr</code> 来定义真正的常量，或实现常量初始化。</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>变量可以被声明成 <code>constexpr</code> 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 <code>constexpr</code>, 以用来定义 <code>constexpr</code> 变量。</p>
<p><strong>优点:</strong></p>
<p>如今 <code>constexpr</code> 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</p>
<p><strong>缺点:</strong></p>
<p>若过早把变量优化成 <code>constexpr</code> 变量，将来又要把它改为常规变量时，挺麻烦的；当前对 <code>constexpr</code> 函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</p>
<p><strong>结论:</strong></p>
<p>靠 <code>constexpr</code> 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 <code>constexpr</code> 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与 <code>constexpr</code> 一起使用。 千万别痴心妄想地想靠 <code>constexpr</code> 来强制代码「内联」。</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><blockquote>
<p>C++ 内建整型中, 仅使用 <code>int</code>. 如果程序中需要不同大小的变量, 可以使用 <code>&lt;stdint.h&gt;</code> 中长度精确的整型, 如 <code>int16_t</code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 <code>int64_t</code>. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。<br>定义:</p>
</blockquote>
<p>C++ 没有指定整型的大小. 通常人们假定 <code>short</code> 是 16 位, <code>int</code> 是 32 位, <code>long</code>是 32 位, <code>long long</code> 是 64 位.</p>
<p><strong>优点:</strong></p>
<p>保持声明统一.</p>
<p><strong>缺点:</strong></p>
<p>C++ 中整型大小因编译器和体系结构的不同而不同.</p>
<p>结论:</p>
<p><code>&lt;stdint.h&gt;</code> 定义了 <code>int16_t</code>, <code>uint32_t</code>, <code>int64_t</code> 等整型, 在需要确保整型大小时可以使用它们代替 <code>short</code>, <code>unsigned long long</code> 等. 在 C 整型中, 只使用 int. 在合适的情况下, 推荐使用标准类型如 <code>size_t</code> 和 <code>ptrdiff_t</code>.</p>
<p>如果已知整数不会太大, 我们常常会使用 <code>int</code>, 如循环计数. 在类似的情况下使用原生类型 <code>int</code>. 你可以认为 <code>int</code> 至少为 32 位, 但不要认为它会多于 32 位. 如果需要 64 位整型, 用 <code>int64_t</code> 或 <code>uint64_t</code>.</p>
<p>对于大整数, 使用 <code>int64_t</code>.</p>
<p>不要使用 <code>uint32_t</code> 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p>
<p>如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。</p>
<p>小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 <code>int</code> 与 <code>unsigned int</code> 运算时，前者被提升为 <code>unsigned int</code> 而有可能溢出），总有意想不到的后果。</p>
<p>关于无符号整数:</p>
<p>有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = foo.Length()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) ...</div></pre></td></tr></table></figure>
<p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p>
<p>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p>
<h3 id="64-位下的可移植性"><a href="#64-位下的可移植性" class="headerlink" title="64 位下的可移植性"></a>64 位下的可移植性</h3><blockquote>
<p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:</p>
</blockquote>
<p>对于某些类型, <code>printf()</code> 的指示符在 32 位和 64 位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 <code>inttypes.h</code> 仿标准风格):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// printf macros for size_t, in the style of inttypes.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __PRIS_PREFIX <span class="meta-string">"z"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __PRIS_PREFIX</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// Use these macros after a % in a printf format string</span></div><div class="line"><span class="comment">// to get correct 32/64 bit behavior, like this:</span></div><div class="line"><span class="comment">// size_t size = records.size();</span></div><div class="line"><span class="comment">// printf("%"PRIuS"\n", size);</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIdS __PRIS_PREFIX <span class="meta-string">"d"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIxS __PRIS_PREFIX <span class="meta-string">"x"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIuS __PRIS_PREFIX <span class="meta-string">"u"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIXS __PRIS_PREFIX <span class="meta-string">"X"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIoS __PRIS_PREFIX <span class="meta-string">"o"</span></span></div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">不要使用</th>
<th style="text-align:center">使用</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>void *</code> (或其他指针类型)</td>
<td style="text-align:center"><code>%lx</code></td>
<td style="text-align:center"><code>%p</code></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>int64_t</code></td>
<td style="text-align:center"><code>%qd, %lld</code></td>
<td style="text-align:center"><code>%&quot;PRId64&quot;</code></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>uint64_t</code></td>
<td style="text-align:center"><code>%qu, %llu, %llx</code></td>
<td style="text-align:center"><code>%&quot;PRIu64&quot;, %&quot;PRIx64&quot;</code></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t</code></td>
<td style="text-align:center"><code>%u</code></td>
<td style="text-align:center"><code>%&quot;PRIuS&quot;, %&quot;PRIxS&quot;</code></td>
<td style="text-align:center">C99 规定 <code>%zu</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ptrdiff_t</code></td>
<td style="text-align:center"><code>%d</code></td>
<td style="text-align:center"><code>%&quot;PRIdS&quot;</code></td>
<td style="text-align:center">C99 规定 <code>%zd</code></td>
</tr>
</tbody>
</table>
<p>注意 <code>PRI*</code> 宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用 PRI* 宏同样可以在 <code>%</code> 后包含长度指示符. 例如, <code>printf(&quot;x = %30&quot;PRIuS&quot;\n&quot;, x)</code> 在 32 位 Linux 上将被展开为 <code>printf(&quot;x = %30&quot; &quot;u&quot; &quot;\n&quot;, x)</code>, 编译器当成 <code>printf(&quot;x = %30u\n&quot;, x)</code> 处理 (Yang.Y 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p>
<p>记住 <code>sizeof(void *) != sizeof(int)</code>. 如果需要一个指针大小的整数要用 <code>intptr_t</code>.</p>
<p>你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 <code>int64_t</code>/<code>uint64_t</code> 成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 <code>__attribute__((packed))</code>. MSVC 则提供了 <code>#pragma pack()</code> 和 <code>__declspec(align())</code> (YuleFox 注, 解决方案的项目属性里也可以直接设置).</p>
<p>创建 64 位常量时使用 <code>LL</code> 或 <code>ULL</code> 作为后缀, 如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int64_t</span> my_value = <span class="number">0</span>×<span class="number">123456789L</span>L;</div><div class="line"><span class="keyword">uint64_t</span> my_mask = <span class="number">3U</span>LL &lt;&lt; <span class="number">48</span>;</div></pre></td></tr></table></figure>
<p>如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 <code>#ifdef _LP64</code> 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化)</p>
<h3 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h3><blockquote>
<p>使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p>
</blockquote>
<p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.</p>
<p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被 <code>const</code> 变量代替. 用宏 “缩写” 长变量名可被引用代替. 用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦 (<code>#define</code> 防止头文件重包含当然是个特例).</p>
<p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 # 字符串化, 用 ## 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p>
<p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:</p>
<ul>
<li>不要在 <code>.h</code> 文件中定义宏.</li>
<li>在马上要使用时才进行 <code>#define</code>, 使用后要立即 <code>#undef</code>.</li>
<li>不要只是对已经存在的宏使用 <code>#undef</code>，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>
<li>不要用 <code>##</code> 处理函数，类和变量的名字。</li>
</ul>
<h3 id="0-nullptr-和-NULL"><a href="#0-nullptr-和-NULL" class="headerlink" title="0, nullptr 和 NULL"></a>0, <code>nullptr</code> 和 <code>NULL</code></h3><blockquote>
<p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>&#39;\0&#39;</code>.</p>
</blockquote>
<p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 这一点是毫无争议的.</p>
<p>对于指针 (地址值), 到底是用 <code>0</code>, <code>NULL</code> 还是 <code>nullptr</code>. C++11 项目用 <code>nullptr</code>; C++03 项目则用 <code>NULL</code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 <code>NULL</code> 的定义比较特殊，可以输出有用的警告，特别是 <code>sizeof(NULL)</code> 就和 <code>sizeof(0)</code> 不一样。</p>
<p>字符 (串) 用 <code>&#39;\0&#39;</code>, 不仅类型正确而且可读性好.</p>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><blockquote>
<p>尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</p>
</blockquote>
<p>使用 <code>sizeof(varname)</code> 是因为当代码中变量类型改变时会自动更新. 您或许会用 <code>sizeof(type)</code> 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Struct data;</div><div class="line">Struct data; <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(Struct));</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (raw_size &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</div><div class="line">    LOG(ERROR) &lt;&lt; <span class="string">"compressed record not big enough for count: "</span> &lt;&lt; raw_size;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><blockquote>
<p>用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>
</blockquote>
<p><strong>定义：</strong></p>
<p>C++11 中，若变量被声明成 <code>auto</code>, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用 <code>auto</code> 来复制初始化或绑定引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</div><div class="line">...</div><div class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>];  <span class="comment">// 创建一份 v[0] 的拷贝。</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>];  <span class="comment">// s2 是 v[0] 的一个引用。</span></div></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<p>C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">sparse_hash_map&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator iter = m.find(val);</div></pre></td></tr></table></figure>
<p>返回类型好难读，代码目的也不够一目了然。重构其：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> iter = m.find(val);</div></pre></td></tr></table></figure>
<p>好多了。</p>
<p>没有 <code>auto</code> 的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::ErrorStatus(<span class="string">"xyz"</span>);</div></pre></td></tr></table></figure>
<p>有了 <code>auto</code>, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p>
<p><strong>缺点：</strong></p>
<p>类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> i = x.Lookup(key);</div></pre></td></tr></table></figure>
<p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p>
<p>程序员必须会区分 <code>auto</code> 和 <code>const auto&amp;</code> 的不同之处，否则会复制错东西。</p>
<p><code>auto</code> 和 C++11 列表初始化的合体令人摸不着头脑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 圆括号。</span></div><div class="line"><span class="keyword">auto</span> y&#123;<span class="number">3</span>&#125;;  <span class="comment">// 大括号。</span></div></pre></td></tr></table></figure>
<p>它们不是同一回事——<code>x</code> 是 <code>int</code>, <code>y</code> 则是 <code>std::initializer_list&lt;int&gt;</code>. 其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types, 它涉及到 C++ 鲜为人知的坑：<a href="http://stackoverflow.com/a/17794965/1546088" target="_blank" rel="external">Why is vector<bool> not a STL container?</bool></a>）也有大同小异的陷阱。</p>
<p>如果在接口里用 <code>auto</code>, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。</p>
<p><strong>结论：</strong></p>
<p><code>auto</code> 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 <code>auto</code> 变量。</p>
<p><code>auto</code> 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><blockquote>
<p>你可以用列表初始化。</p>
</blockquote>
<p>早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> Point &#123; <span class="keyword">int</span> x; <span class="keyword">int</span> y; &#125;;</div><div class="line">Point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div></pre></td></tr></table></figure>
<p>C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Vector 接收了一个初始化列表。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v&#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 不考虑细节上的微妙差别，大致上相同。</span></div><div class="line"><span class="comment">// 您可以任选其一。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 可以配合 new 一起用。</span></div><div class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// map 接收了一些 pair, 列表初始化大显神威。</span></div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"2"</span>&#125;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 初始化列表也可以用在返回类型上的隐式转换。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test_function() &#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化列表可迭代。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在函数调用里用列表初始化。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFunction2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;&#125;</div><div class="line">TestFunction2(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</div></pre></td></tr></table></figure>
<p>用户自定义类型也可以定义接收 <code>std::initializer_list&lt;T&gt;</code> 的构造函数和赋值运算符，以自动列表初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> MyType &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// std::initializer_list 专门接收 init 列表。</span></div><div class="line">  <span class="comment">// 得以值传递。</span></div><div class="line">  MyType(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; init_list) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : init_list) append(i);</div><div class="line">  &#125;</div><div class="line">  MyType&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; init_list) &#123;</div><div class="line">    clear();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : init_list) append(i);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">MyType m&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</div></pre></td></tr></table></figure>
<p>最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收 <code>std::initializer_list&lt;T&gt;</code> 的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">double</span> d&#123;<span class="number">1.23</span>&#125;;</div><div class="line"><span class="comment">// MyOtherType 没有 std::initializer_list 构造函数，</span></div><div class="line"> <span class="comment">// 直接上接收常规类型的构造函数。</span></div><div class="line"><span class="keyword">class</span> MyOtherType &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyOtherType</span><span class="params">(<span class="built_in">string</span>)</span></span>;</div><div class="line">  MyOtherType(<span class="keyword">int</span>, <span class="built_in">string</span>);</div><div class="line">&#125;;</div><div class="line">MyOtherType m = &#123;<span class="number">1</span>, <span class="string">"b"</span>&#125;;</div><div class="line"><span class="comment">// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。</span></div><div class="line">MyOtherType m&#123;<span class="string">"b"</span>&#125;;</div></pre></td></tr></table></figure>
<p>千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;;        <span class="comment">// d 即是 std::initializer_list&lt;double&gt;</span></div><div class="line"><span class="keyword">auto</span> d = <span class="keyword">double</span>&#123;<span class="number">1.23</span>&#125;;  <span class="comment">// 善哉 -- d 即为 double, 并非 std::initializer_list.</span></div></pre></td></tr></table></figure>
<p>至于格式化，参见 braced-initializer-list-format.</p>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><blockquote>
<p>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p>
</blockquote>
<p><strong>定义：</strong></p>
<p>Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::sort(v.begin(), v.end(), [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</div><div class="line">    <span class="keyword">return</span> Weight(x) &lt; Weight(y);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>C++11 首次提出 Lambdas, 还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper） <code>std::function</code>.</p>
<p><strong>优点：</strong></p>
<ul>
<li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li>
<li>Lambdas, <code>std::functions</code> 和 <code>std::bind</code> 可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</li>
<li>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</li>
</ul>
<p><strong>结论：</strong></p>
<ul>
<li>按 format 小用 lambda 表达式怡情。</li>
<li>禁用默认捕获，捕获都要显式写出来。打比方，比起 <code>[=](int x) {return x + n;}</code>, 您该写成 <code>[n](int x) {return x + n;}</code> 才对，这样读者也好一眼看出 <code>n</code> 是被捕获的值。</li>
<li>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。</li>
<li>如果可读性更好，就显式写出 lambda 的尾置返回类型，就像 <code>auto</code>.</li>
</ul>
<h3 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h3><blockquote>
<p>不要使用复杂的模板编程</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>模板编程指的是利用 C++ 模板实例化机制是图灵完备性, 可以被用来实现编译时刻的类型判断的一系列编程技巧</p>
<p><strong>优点:</strong></p>
<p>模板编程能够实现非常灵活的类型安全的接口和极好的性能, 一些常见的工具比如 Google Test, <code>std::tuple</code>, <code>std::function</code> 和 <code>Boost.Spirit</code>. 这些工具如果没有模板是实现不了的</p>
<p><strong>缺点:</strong></p>
<ul>
<li>模板编程所使用的技巧对于使用 C++不是很熟练的人是比较晦涩, 难懂的. 在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和 维护起来都很麻烦</li>
<li>模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候, 即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示. 导致这个编译出错信息看起来非常难以理解.</li>
<li>大量的使用模板编程接口会让重构工具(Visual Assist X, Refactor for C++等等)更难发挥用途. 首先模板的代码会在很多上下文里面扩展开来, 所以很难确认重构对所有的这些展开的代码有用, 其次有些重构工具只对已经做过模板类型替换的代码的AST 有用. 因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构.</li>
</ul>
<p><strong>结论:</strong></p>
<ul>
<li>模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此模板编程最好只用在少量的基础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉</li>
<li>在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非 C++ 程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程. 如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板, 或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载, 那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用</li>
<li>如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴漏. 你最好只在实现里面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性. 并且你应该在这些使用模板的代码上写尽可能详细的注释. 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代码大概是什么样子的. 还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为这些出错信息也是你的接口的一部分, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解, 并且用户很容易知道如何修改这些错误</li>
</ul>
<h3 id="Boost-库"><a href="#Boost-库" class="headerlink" title="Boost 库"></a>Boost 库</h3><blockquote>
<p>只使用 Boost 中被认可的库.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>Boost 库集 是一个广受欢迎, 经过同行鉴定, 免费开源的 C++ 库集.</p>
<p><strong>优点:</strong></p>
<p>Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针。</p>
<p><strong>缺点:</strong></p>
<p>某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术, 以及过度 “函数化” 的编程风格.</p>
<p><strong>结论:</strong></p>
<p>为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前允许使用以下库:</p>
<ul>
<li>Call Traits : <code>boost/call_traits.hpp</code></li>
<li>Compressed Pair : <code>boost/compressed_pair.hpp</code></li>
<li>&lt;The Boost Graph Library (BGL) : <code>boost/graph</code>, except serialization (<code>adj_list_serialize.hpp</code>) and parallel/distributed algorithms and data structures(<code>boost/graph/parallel/*</code> and <code>boost/graph/distributed/*</code>)</li>
<li>Property Map : <code>boost/property_map.hpp</code></li>
<li>The part of Iterator that deals with defining iterators: <code>boost/iterator/iterator_adaptor.hpp</code>, <code>boost/iterator/iterator_facade.hpp</code>, and <code>boost/function_output_iterator.hpp</code></li>
<li>The part of Polygon that deals with Voronoi diagram construction and doesn’t depend on the rest of Polygon: <code>boost/polygon/voronoi_builder.hpp</code>, <code>boost/polygon/voronoi_diagram.hpp</code>, and <code>boost/polygon/voronoi_geometry_type.hpp</code></li>
<li>Bimap : <code>boost/bimap</code></li>
<li>Statistical Distributions and Functions : <code>boost/math/distributions</code></li>
<li>Multi-index : <code>boost/multi_index</code></li>
<li>Heap : <code>boost/heap</code></li>
<li>The flat containers from Container: <code>boost/container/flat_map</code>, and <code>boost/container/flat_set</code></li>
</ul>
<p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p>
<p>以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：</p>
<ul>
<li>Pointer Container : <code>boost/ptr_container</code>, 改用 std::unique_ptr</li>
<li>Array : <code>boost/array.hpp</code>, 改用 std::array</li>
</ul>
<h3 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h3><blockquote>
<p>适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。</p>
</blockquote>
<p><strong>定义：</strong></p>
<p>C++11 有众多语言和库上的<a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="external">变革</a>。</p>
<p><strong>优点：</strong></p>
<p>在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++ 编译器支持。它标准化很多我们早先就在用的 C++ 扩展，简化了不少操作，大大改善了性能和安全。</p>
<p><strong>缺点：</strong></p>
<p>C++11 相对于前身，复杂极了：1300 页 vs 800 页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。</p>
<p>和 Boost 库 一样，有些 C++11 扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。</p>
<p><strong>缺点：</strong></p>
<p>C++11 特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11 特性之外，以下特性最好不要用：</p>
<ul>
<li>尾置返回类型，比如用 <code>auto foo() -&gt; int</code> 代替 <code>int foo()</code>. 为了兼容于现有代码的声明风格。</li>
<li>编译时合数 <code>&lt;ratio&gt;</code>, 因为它涉及一个重模板的接口风格。</li>
<li><code>&lt;cfenv&gt;</code> 和 <code>&lt;fenv.h&gt;</code> 头文件，因为编译器尚不支持。</li>
<li>默认 lambda 捕获。</li>
</ul>
<p>译者（acgtyrant）笔记</p>
<ol>
<li>实际上，<a href="http://www.zhihu.com/question/24439516/answer/27858964" target="_blank" rel="external">缺省参数会改变函数签名的前提是改变了它接收的参数数量</a>，比如把 <code>void a()</code> 改成 <code>void a(int b = 0)</code>, 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li>
<li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li>
<li>我还发现 <a href="http://www.zhihu.com/question/24439516/answer/27896004" target="_blank" rel="external">滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少</a>。</li>
<li><code>friend</code> 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 <code>.cc</code> 文件加以定义。</li>
<li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li>
<li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考 声明顺序 。</li>
<li><a href="http://www.zhihu.com/question/22889420" target="_blank" rel="external">对使用 C++ 异常处理应具有怎样的态度？</a> 非常值得一读。</li>
<li>注意初始化 <code>const</code> 对象时，必须在初始化的同时值初始化。</li>
<li>用断言代替无符号整型类型，深有启发。</li>
<li><code>auto</code> 在涉及迭代器的循环语句里挺常用。</li>
<li><a href="http://stackoverflow.com/questions/11215227/should-the-trailing-return-type-syntax-style-become-the-default-for-new-c11-pr" target="_blank" rel="external">Should the trailing return type syntax style become the default for new C++11 programs?</a> 讨论了 auto 与尾置返回类型一起用的全新编码风格，值得一看。</li>
</ol>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>最重要的一致性规则是命名管理. 命名风格快速获知名字代表是什么东东: 类型? 变量? 函数? 常量? 宏 … ? 甚至不需要去查找类型声明. 我们大脑中的模式匹配引擎可以非常可靠的处理这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重, 所以不管你怎么想, 规则总归是规则.</p>
<h3 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h3><blockquote>
<p>函数命名，变量命名，文件命名要有描述性；少用缩写。</p>
</blockquote>
<p>尽可能给有描述性的命名，别心疼空间，毕竟让代码易于新读者理解很重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> price_count_reader;    <span class="comment">// 无缩写</span></div><div class="line"><span class="keyword">int</span> num_errors;            <span class="comment">// “num” 本来就很常见</span></div><div class="line"><span class="keyword">int</span> num_dns_connections;   <span class="comment">// 人人都知道 “DNS” 是啥</span></div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> n;                     <span class="comment">// 莫名其妙。</span></div><div class="line"><span class="keyword">int</span> nerr;                  <span class="comment">// 怪缩写。</span></div><div class="line"><span class="keyword">int</span> n_comp_conns;          <span class="comment">// 怪缩写。</span></div><div class="line"><span class="keyword">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是啥意思。</span></div><div class="line"><span class="keyword">int</span> pc_reader;             <span class="comment">// "pc" 有太多可能的解释了。</span></div><div class="line"><span class="keyword">int</span> cstmr_id;              <span class="comment">// 有删减若干字母。</span></div></pre></td></tr></table></figure>
<h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><blockquote>
<p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>). 按项目约定来. 如果并没有项目约定，<code>_</code> 更好。</p>
</blockquote>
<p>可接受的文件命名:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">* my_useful_class.cc</div><div class="line">* my-useful-<span class="keyword">class</span>.cc</div><div class="line">* myusefulclass.cc</div><div class="line">* muusefulclass_test.cc <span class="comment">// ``_unittest`` 和 ``_regtest`` 已弃用。</span></div></pre></td></tr></table></figure>
<p>C++ 文件要以 <code>.cc</code> 结尾, 头文件以 <code>.h</code> 结尾. 专门插入文本的文件则以 <code>.inc</code> 结尾，参见 Self-contained 头文件。</p>
<p>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 <code>db.h</code>.</p>
<p>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比 <code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类 <code>FooBar</code>.</p>
<p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短, 就直接放在 <code>.h</code> 中.</p>
<h3 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h3><blockquote>
<p>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p>
</blockquote>
<p>所有类型命名 —— 类, 结构体, 类型定义 (<code>typedef</code>), 枚举 —— 均使用相同约定. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// classes and structs</span></div><div class="line"><span class="keyword">class</span> UrlTable &#123; ...</div><div class="line"><span class="keyword">class</span> UrlTableTester &#123; ...</div><div class="line"><span class="keyword">struct</span> UrlTableProperties &#123; ...</div><div class="line"></div><div class="line"><span class="comment">// typedefs</span></div><div class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, <span class="built_in">string</span>&gt; PropertiesMap;</div><div class="line"></div><div class="line"><span class="comment">// enums</span></div><div class="line"><span class="keyword">enum</span> UrlTableErrors &#123; ...</div></pre></td></tr></table></figure>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><blockquote>
<p>变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member</code>.</p>
</blockquote>
<p>普通变量命名:</p>
<p>举例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">string</span> table_name;  <span class="comment">// 可 - 用下划线。</span></div><div class="line"><span class="built_in">string</span> tablename;   <span class="comment">// 可 - 全小写。</span></div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">string</span> tableName;   <span class="comment">// 差 - 混合大小写。</span></div></pre></td></tr></table></figure>
<p>类数据成员：</p>
<p>不管是静态的还是非静态的，类数据成员都可以和普通变量一样, 但要接下划线。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> TableInfo &#123;</div><div class="line">  ...</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="built_in">string</span> table_name_;  <span class="comment">// 可 - 尾后加下划线。</span></div><div class="line">  <span class="built_in">string</span> tablename_;   <span class="comment">// 可。</span></div><div class="line">  <span class="keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 可。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>结构体变量:</p>
<p>不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> UrlTableProperties &#123;</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">int</span> num_entries;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构体与类的讨论参考 结构体 vs. 类 一节.</p>
<p>全局变量:</p>
<p>对全局变量没有特别要求, 少用就好, 但如果你要用, 可以用 <code>g_</code> 或其它标志作为前缀, 以便更好的区分局部变量.</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><blockquote>
<p>在全局或类里的常量名称前加 <code>k</code>: <code>kDaysInAWeek</code>. 且除去开头的 <code>k</code> 之外每个单词开头字母均大写。</p>
</blockquote>
<p>所有编译时常量, 无论是局部的, 全局的还是类中的, 和其他变量稍微区别一下. <code>k</code> 后接大写字母开头的单词:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</div></pre></td></tr></table></figure>
<p>这规则适用于编译时的局部作用域常量，不过要按变量规则来命名也可以。</p>
<h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><blockquote>
<p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>.</p>
</blockquote>
<p>常规函数:</p>
<p>函数名的每个单词首字母大写, 没有下划线。</p>
<p>如果您的某函数出错时就要直接 crash, 那么就在函数名加上 OrDie. 但这函数本身必须集成在产品代码里，且平时也可能会出错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">AddTableEntry()</div><div class="line">DeleteUrl()</div><div class="line">OpenFileOrDie()</div></pre></td></tr></table></figure>
<p>取值和设值函数:</p>
<p>取值（Accessors）和设值（Mutators）函数要与存取的变量名匹配. 这儿摘录一个类, <code>num_entries_</code> 是该类的实例变量:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> MyClass &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        ...</div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">num_entries</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> num_entries_; &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_num_entries</span><span class="params">(<span class="keyword">int</span> num_entries)</span> </span>&#123; num_entries_ = num_entries; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">int</span> num_entries_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其它非常短小的内联函数名也可以用小写字母, 例如. 如果你在循环中调用这样的函数甚至都不用缓存其返回值, 小写命名就可以接受.</p>
<h3 id="名字空间命名"><a href="#名字空间命名" class="headerlink" title="名字空间命名"></a>名字空间命名</h3><blockquote>
<p>名字空间用小写字母命名, 并基于项目名称和目录结构: <code>google_awesome_project.</code></p>
</blockquote>
<p>关于名字空间的讨论和如何命名, 参考 名字空间 一节.</p>
<h3 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h3><blockquote>
<p>枚举的命名应当和 常量 或 宏 一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>.</p>
</blockquote>
<p>单独的枚举值应该优先采用 常量 的命名方式. 但 宏 方式的命名也可以接受. 枚举名 <code>UrlTableErrors</code> (以及 <code>AlternateUrlTableErrors</code>) 是类型, 所以要用大小写混合的方式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> UrlTableErrors &#123;</div><div class="line">    kOK = <span class="number">0</span>,</div><div class="line">    kErrorOutOfMemory,</div><div class="line">    kErrorMalformedInput,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">enum</span> AlternateUrlTableErrors &#123;</div><div class="line">    OK = <span class="number">0</span>,</div><div class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</div><div class="line">    MALFORMED_INPUT = <span class="number">2</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>2009 年 1 月之前, 我们一直建议采用 宏 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
<h3 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h3><blockquote>
<p>你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p>
</blockquote>
<p>参考 预处理宏; 通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(x) ...</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_ROUNDED 3.0</span></div></pre></td></tr></table></figure>
<h3 id="命名规则的特例"><a href="#命名规则的特例" class="headerlink" title="命名规则的特例"></a>命名规则的特例</h3><blockquote>
<p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
</blockquote>
<ul>
<li><code>bigopen()</code>: 函数名, 参照 <code>open()</code> 的形式</li>
<li><code>uint</code>: <code>typedef</code></li>
<li><code>bigpos</code>: <code>struct</code> 或 <code>class</code>, 参照 <code>pos</code> 的形式</li>
<li><code>sparse_hash_map</code>: STL 相似实体; 参照 STL 命名约定</li>
<li><code>LONGLONG_MAX</code>: 常量, 如同 <code>INT_MAX</code></li>
</ul>
<p>译者（acgtyrant）笔记</p>
<p>感觉 Google 的命名约定很高明，比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 <code>query_result</code>, 区分度很好；再次，类内变量以下划线结尾，那么就可以直接传入同名的形参，比如 <code>TextQuery::TextQuery(std::string word) : word_(word) {}</code> , 其中 <code>word_</code> 自然是类内私有成员。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码本身应该是自文档化. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</p>
<p>你写的注释是给代码读者看的: 下一个需要理解你的代码的人. 慷慨些吧, 下一个人可能就是你!</p>
<h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h3><blockquote>
<p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p>
</blockquote>
<p><code>//</code> 或 <code>/* */</code> 都可以; 但 <code>//</code> 更 常用. 要在如何注释及注释风格上确保统一.</p>
<h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><blockquote>
<p>在每一个文件开头加入版权公告, 然后是文件内容描述.</p>
</blockquote>
<p>法律公告和作者信息:</p>
<p>每个文件都应该包含以下项, 依次是:</p>
<ul>
<li>版权声明 (比如, Copyright 2008 Google Inc.)</li>
<li>许可证. 为项目选择合适的许可证版本 (比如, Apache 2.0, BSD, LGPL, GPL)</li>
<li>作者: 标识文件的原始作者.</li>
</ul>
<p>如果你对原始作者的文件做了重大修改, 将你的信息添加到作者信息里. 这样当其他人对该文件有疑问时可以知道该联系谁.</p>
<p>文件内容:</p>
<p>紧接着版权许可和作者信息之后, 每个文件都要用注释描述文件内容.</p>
<p>通常, <code>.h</code> 文件要对所声明的类的功能和用法作简单说明. <code>.cc</code> 文件通常包含了更多的实现细节或算法技巧讨论, 如果你感觉这些实现细节或算法技巧讨论对于理解 <code>.h</code> 文件有帮助, 可以将该注释挪到 <code>.h</code>, 并在 <code>.cc</code> 中指出文档在 <code>.h</code>.</p>
<p>不要简单的在 <code>.h</code> 和 <code>.cc</code> 间复制注释. 这种偏离了注释的实际意义.</p>
<h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><blockquote>
<p>每个类的定义都要附带一份注释, 描述类的功能和用法.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Iterates over the contents of a GargantuanTable.  Sample usage:</span></div><div class="line"><span class="comment">//    GargantuanTable_Iterator* iter = table-&gt;NewIterator();</span></div><div class="line"><span class="comment">//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) &#123;</span></div><div class="line"><span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//    delete iter;</span></div><div class="line"><span class="keyword">class</span> GargantuanTable_Iterator &#123;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果你觉得已经在文件顶部详细描述了该类, 想直接简单的来上一句 “完整描述见文件顶部” 也不打紧, 但务必确保有这类注释.</p>
<p>如果类有任何同步前提, 文档说明之. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
<h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><blockquote>
<p>函数声明处注释描述函数功能; 定义处描述函数实现.</p>
</blockquote>
<p>函数声明:</p>
<p>注释位于声明之前, 对函数功能及用法进行描述. 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p>
<p>函数声明处注释的内容:</p>
<ul>
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>如果函数分配了空间, 需要由调用者释放.</li>
<li>参数是否可以为 <code>NULL</code>.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ul>
<p>举例如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Returns an iterator for this table.  It is the client's</span></div><div class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></div><div class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></div><div class="line"><span class="comment">// on which the iterator was created has been deleted.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This method is equivalent to:</span></div><div class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></div><div class="line"><span class="comment">//    iter-&gt;Seek("");</span></div><div class="line"><span class="comment">//    return iter;</span></div><div class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></div><div class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></div><div class="line"><span class="comment">// and avoid the extra seek.</span></div><div class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="keyword">const</span></span>;</div></pre></td></tr></table></figure>
<p>但也要避免罗罗嗦嗦, 或做些显而易见的说明. 下面的注释就没有必要加上 “returns false otherwise”, 因为已经暗含其中了:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Returns true if the table cannot hold any more entries.</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTableFull</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以 “destroys this object” 这样的注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
<p>函数定义:</p>
<p>每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要.</p>
<p>不要 从 <code>.h</code> 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
<h3 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h3><blockquote>
<p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
</blockquote>
<p>类数据成员:</p>
<p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 <code>NULL</code> 或 <code>-1</code> 等警戒值, 须加以说明. 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Keeps track of the total number of entries in the table.</span></div><div class="line">    <span class="comment">// Used to ensure we do not go over the limit. -1 means</span></div><div class="line">    <span class="comment">// that we don't yet know how many entries the table has.</span></div><div class="line">    <span class="keyword">int</span> num_total_entries_;</div></pre></td></tr></table></figure>
<p>全局变量:</p>
<p>和数据成员一样, 所有全局变量也要注释说明含义及用途. 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumTestCases = <span class="number">6</span>;</div></pre></td></tr></table></figure>
<h3 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h3><blockquote>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
</blockquote>
<p>代码前注释:</p>
<p>巧妙或复杂的代码段前要加注释. 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Divide result by two, taking into account that x</span></div><div class="line"><span class="comment">// contains the carry from the add.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result-&gt;size(); i++) &#123;</div><div class="line">    x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</div><div class="line">    (*result)[i] = x &gt;&gt; <span class="number">1</span>;</div><div class="line">    x &amp;= <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>行注释:</p>
<p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></div><div class="line">mmap_budget = max&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;length());</div><div class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))</div><div class="line">    <span class="keyword">return</span>;  <span class="comment">// Error already logged.</span></div></pre></td></tr></table></figure>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">DoSomething();                  <span class="comment">// Comment here so the comments line up.</span></div><div class="line">DoSomethingElseThatIsLonger();  <span class="comment">// Comment here so there are two spaces between</span></div><div class="line">                                <span class="comment">// the code and the comment.</span></div><div class="line">&#123; <span class="comment">// One space before comment when opening a new scope is allowed,</span></div><div class="line">  <span class="comment">// thus the comment lines up with the following comments and code.</span></div><div class="line">  DoSomethingElse();  <span class="comment">// Two spaces before line comments normally.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NULL, true/false, 1, 2, 3…:</p>
<p>向函数传入 <code>NULL</code>, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意. 例如, 对比:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</div><div class="line">                                  <span class="number">10</span>,</div><div class="line">                                  <span class="literal">false</span>,</div><div class="line">                                  <span class="literal">NULL</span>);  <span class="comment">// What are these arguments??</span></div></pre></td></tr></table></figure>
<p>和:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</div><div class="line">                                  <span class="number">10</span>,     <span class="comment">// Default base value.</span></div><div class="line">                                  <span class="literal">false</span>,  <span class="comment">// Not the first time we're calling this.</span></div><div class="line">                                  <span class="literal">NULL</span>);  <span class="comment">// No callback.</span></div></pre></td></tr></table></figure>
<p>或使用常量或描述性变量:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDefaultBaseValue = <span class="number">10</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">bool</span> kFirstTimeCalling = <span class="literal">false</span>;</div><div class="line">Callback *null_callback = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</div><div class="line">                                  kDefaultBaseValue,</div><div class="line">                                  kFirstTimeCalling,</div><div class="line">                                  null_callback);</div></pre></td></tr></table></figure>
<p>不允许:</p>
<p>注意 永远不要 用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 现在, 检查 b 数组并确保 i 是否存在,</span></div><div class="line"><span class="comment">// 下一个元素是 i+1.</span></div><div class="line">...        <span class="comment">// 天哪. 令人崩溃的注释.</span></div></pre></td></tr></table></figure>
<h3 id="标点-拼写和语法"><a href="#标点-拼写和语法" class="headerlink" title="标点, 拼写和语法"></a>标点, 拼写和语法</h3><blockquote>
<p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
</blockquote>
<p>注释的通常写法是包含正确大小写和结尾句号的完整语句. 短一点的注释 (如代码行尾注释) 可以随意点, 依然要注意风格的一致性. 完整的语句可读性更好, 也可以说明该注释是完整的, 而不是一些不成熟的想法.</p>
<p>虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有所帮助.</p>
<h3 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h3><blockquote>
<p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释.</p>
</blockquote>
<p><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code> 格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span></div><div class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></div><div class="line">如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November <span class="number">2005</span>”), 或者一个明确的事项 (“Remove <span class="keyword">this</span> code when all clients can handle XML responses.”).</div></pre></td></tr></table></figure>
<h3 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h3><blockquote>
<p>通过弃用注释（DEPRECATED comments）以标记某接口点（interface points）已弃用。</p>
</blockquote>
<p>您可以写上包含全大写的 <code>DEPRECATED</code> 的注释，以标记某接口为弃用状态。注释可以放在接口声明前，或者同一行。</p>
<p>在 <code>DEPRECATED</code> 一词后，留下您的名字，邮箱地址以及括号补充。</p>
<p>仅仅标记接口为 <code>DEPRECATED</code> 并不会让大家不约而同地弃用，您还得亲自主动修正调用点（callsites），或是找个帮手。</p>
<p>修正好的代码应该不会再涉及弃用接口点了，着实改用新接口点。如果您不知从何下手，可以找标记弃用注释的当事人一起商量。</p>
<p>译者 (YuleFox) 笔记</p>
<ol>
<li>关于注释风格，很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>代码风格和格式确实比较随意, 但一个项目中所有人遵循同一风格是非常容易的. 个体未必同意下述每一处格式规则, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人能很轻松的阅读和理解代码.</p>
<p>另外, 我们写了一个 <a href="http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el" target="_blank" rel="external">emacs 配置文件</a> 来帮助你正确的格式化代码.</p>
<h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><blockquote>
<p>每一行代码字符数不超过 80.</p>
</blockquote>
<p>我们也认识到这条规则是有争议的, 但很多已有代码都已经遵照这一规则, 我们感觉一致性更重要.</p>
<p><strong>优点:</strong></p>
<p>提倡该原则的人主张强迫他们调整编辑器窗口大小很野蛮. 很多人同时并排开几个代码窗口, 根本没有多余空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 为什么要改变呢?</p>
<p><strong>缺点:</strong></p>
<p>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 很轻松的可以显示更多代码.</p>
<p><strong>结论:</strong></p>
<p>80 个字符是最大值.</p>
<p><strong>特例:</strong></p>
<ul>
<li>如果一行注释包含了超过 80 字符的命令或 URL, 出于复制粘贴的方便允许该行超过 80 字符.</li>
<li>包含长路径的 <code>#include</code> 语句可以超出80列. 但应该尽量避免.</li>
<li>头文件保护 可以无视该原则.</li>
</ul>
<h3 id="非-ASCII-字符"><a href="#非-ASCII-字符" class="headerlink" title="非 ASCII 字符"></a>非 ASCII 字符</h3><blockquote>
<p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p>
</blockquote>
<p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符要少用. 特殊情况下可以适当包含此类字符. 如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p>
<p>十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 <code>&quot;\xEF\xBB\xBF&quot;</code> 在 Unicode 中是 零宽度 无间断 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p>
<p>(Yang.Y 注: <code>&quot;\xEF\xBB\xBF&quot;</code> 通常用作 UTF-8 with BOM 编码标记)</p>
<p>用 <code>u8</code> 前缀以把带 <code>uXXXX</code> 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上，因为如果编译器不把源代码识别成 UTF-8, 输出就会出错。</p>
<p>别用 C++11 的 <code>char16_t</code> 和 <code>char32_t</code>, 它们和 UTF-8 文本没有关系，<code>wchar_t</code> 同理，除非您写的代码要调用 Windows API, 后者有用到 <code>wchar_t</code> 扩展。</p>
<h3 id="空格还是制表位"><a href="#空格还是制表位" class="headerlink" title="空格还是制表位"></a>空格还是制表位</h3><blockquote>
<p>只使用空格, 每次缩进 2 个空格.</p>
</blockquote>
<p>我们使用空格缩进. 不要在代码中使用制符表. 你应该设置编辑器将制符表转为空格.</p>
<h3 id="函数声明与定义"><a href="#函数声明与定义" class="headerlink" title="函数声明与定义"></a>函数声明与定义</h3><blockquote>
<p>返回类型和函数名在同一行, 参数也尽量放在同一行，如果放不下就对形参分行。</p>
</blockquote>
<p>函数看上去像这样:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123;</div><div class="line">    DoSomething();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果同一行文本太多, 放不下所有参数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,</div><div class="line">                                             Type par_name3) &#123;</div><div class="line">    DoSomething();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>甚至连第一个参数都放不下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ReturnType LongClassName::ReallyReallyReallyLongFunctionName(</div><div class="line">        Type par_name1,  <span class="comment">// 4 空格缩进</span></div><div class="line">        Type par_name2,</div><div class="line">        Type par_name3) &#123;</div><div class="line">    DoSomething();  <span class="comment">// 2 空格缩进</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意以下几点:</p>
<ul>
<li>如果返回类型和函数名在一行放不下，分行。</li>
<li>如果返回类型那个与函数声明或定义分行了，不要缩进。</li>
<li>左圆括号总是和函数名在同一行;</li>
<li>函数名和左圆括号间没有空格;</li>
<li>圆括号与参数间没有空格;</li>
<li>左大括号总在最后一个参数同一行的末尾处;</li>
<li>如果其它风格规则允许的话，右大括号总是单独位于函数最后一行，或者与左大括号同一行。</li>
<li>右大括号和左大括号间总是有一个空格;</li>
<li>函数声明和定义中的所有形参必须有命名且一致;</li>
<li>所有形参应尽可能对齐;</li>
<li>缺省缩进为 2 个空格;</li>
<li>换行后的参数保持 4 个空格的缩进;</li>
<li>如果有些参数没有用到, 在函数定义处将参数名注释起来:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 接口中形参恒有命名。</div><div class="line">class Shape &#123;</div><div class="line"> public:</div><div class="line">  virtual void Rotate(double radians) = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 声明中形参恒有命名。</div><div class="line">class Circle : public Shape &#123;</div><div class="line"> public:</div><div class="line">  virtual void Rotate(double radians);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义中注释掉无用变量。</div><div class="line">void Circle::Rotate(double /*radians*/) &#123;&#125;</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 差 - 如果将来有人要实现，很难猜出变量是干什么用的。</span></div><div class="line"><span class="keyword">void</span> Circle::Rotate(<span class="keyword">double</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="Lambda-表达式-1"><a href="#Lambda-表达式-1" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><blockquote>
<p>其它函数怎么格式化形参和函数体，Lambda 表达式就怎么格式化；捕获列表同理。</p>
</blockquote>
<p>若用引用捕获，在变量名和 &amp; 之间不留空格。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line"><span class="keyword">auto</span> add_to_x = [&amp;x](<span class="keyword">int</span> n) &#123; x += n; &#125;;</div></pre></td></tr></table></figure>
<p>短 lambda 就写得和内联函数一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; blacklist = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; digits = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</div><div class="line">digits.erase(<span class="built_in">std</span>::remove_if(digits.begin(), digits.end(), [&amp;blacklist](<span class="keyword">int</span> i) &#123;</div><div class="line">                <span class="keyword">return</span> blacklist.find(i) != blacklist.end();</div><div class="line">            &#125;),</div><div class="line">            digits.end());</div></pre></td></tr></table></figure>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><blockquote>
<p>要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。</p>
</blockquote>
<p>函数调用遵循如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> retval = DoSomething(argument1, argument2, argument3);</div></pre></td></tr></table></figure>
<p>如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> retval = DoSomething(averyveryveryverylongargument1,</div><div class="line">                          argument2, argument3);</div></pre></td></tr></table></figure>
<p>参数也可以放在次行，缩进四格：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (...) &#123;</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  <span class="keyword">if</span> (...) &#123;</div><div class="line">    DoSomething(</div><div class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></div><div class="line">        argument3, argument4);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>把多个参数放在同一行，是为了减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办：</p>
<p>如果一些参数本身就是略复杂的表达式，且降低了可读性。那么可以直接创建临时变量描述该表达式，并传递给函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> my_heuristic = scores[x] * y + bases[x];</div><div class="line"><span class="keyword">bool</span> retval = DoSomething(my_heuristic, x, y, z);</div></pre></td></tr></table></figure>
<p>或者放着不管，补充上注释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> retval = DoSomething(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></div><div class="line">                          x, y, z);</div></pre></td></tr></table></figure>
<p>如果某参数独立成行，对可读性更有帮助的话，就这么办。</p>
<p>此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></div><div class="line">my_widget.Transform(x1, x2, x3,</div><div class="line">                    y1, y2, y3,</div><div class="line">                    z1, z2, z3);</div></pre></td></tr></table></figure>
<h3 id="列表初始化格式"><a href="#列表初始化格式" class="headerlink" title="列表初始化格式"></a>列表初始化格式</h3><blockquote>
<p>您平时怎么格式化函数调用，就怎么格式化 列表初始化。</p>
</blockquote>
<p>如果列表初始化伴随着名字，比如类型或变量名，您可以当名字是函数、{} 是函数调用的括号来格式化它。反之，就当它有个长度为零的名字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 一行列表初始化示范。</span></div><div class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</div><div class="line">functioncall(&#123;foo, bar&#125;);</div><div class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p&#123;foo, bar&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 当不得不断行时。</span></div><div class="line">SomeFunction(</div><div class="line">    &#123;<span class="string">"assume a zero-length name before &#123;"</span>&#125;,</div><div class="line">    some_other_function_parameter);</div><div class="line">SomeType variable&#123;</div><div class="line">    some, other, values,</div><div class="line">    &#123;<span class="string">"assume a zero-length name before &#123;"</span>&#125;,</div><div class="line">    SomeOtherType&#123;</div><div class="line">        <span class="string">"Very long string requiring the surrounding breaks."</span>,</div><div class="line">        some, other values&#125;,</div><div class="line">    SomeOtherType&#123;<span class="string">"Slightly shorter string"</span>,</div><div class="line">                  some, other, values&#125;&#125;;</div><div class="line">SomeType variable&#123;</div><div class="line">    <span class="string">"This is too long to fit all in one line"</span>&#125;;</div><div class="line">MyType m = &#123;  <span class="comment">// 注意了，您可以在 &#123; 前断行。</span></div><div class="line">    superlongvariablename1,</div><div class="line">    superlongvariablename2,</div><div class="line">    &#123;<span class="keyword">short</span>, interior, <span class="built_in">list</span>&#125;,</div><div class="line">    &#123;interiorwrappinglist,</div><div class="line">     interiorwrappinglist2&#125;&#125;;</div></pre></td></tr></table></figure>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><blockquote>
<p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.</p>
</blockquote>
<p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<p>最常见的是没有空格的格式. 哪种都可以, 但 保持一致性. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在徘徊的话, 就不要加空格了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) &#123;  圆括号里没空格紧邻。</div><div class="line">  ...  <span class="comment">// 2 空格缩进。</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行。</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你更喜欢在圆括号内部加空格:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></div><div class="line">  ...  <span class="comment">// 2 空格缩进。</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行。</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(condition)     <span class="comment">// 差 - IF 后面没空格。</span></div><div class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 差 - &#123; 前面没空格。</span></div><div class="line"><span class="keyword">if</span>(condition)&#123;    <span class="comment">// 变本加厉地差。</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 可 - IF 和 &#123; 都与空格紧邻。</span></div></pre></td></tr></table></figure>
<p>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> Foo();</div><div class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> Bar();</div></pre></td></tr></table></figure>
<p>如果语句有 <code>else</code> 分支则不允许:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 不可以这样子 - 当有 ELSE 分支时 IF 块却只有一行</span></div><div class="line"><span class="keyword">if</span> (x) DoThis();</div><div class="line"><span class="keyword">else</span> DoThat();</div></pre></td></tr></table></figure>
<p>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition)</div><div class="line">  DoSomething();  <span class="comment">// 2 空格缩进。</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">  DoSomething();  <span class="comment">// 2 空格缩进。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有。</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">    foo;</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">    bar;</div><div class="line"></div><div class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有。</span></div><div class="line"><span class="keyword">if</span> (condition)</div><div class="line">    foo;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    bar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 只要其中一个分支用了大括号，两个分支都要用上大括号。</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">  foo;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  bar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="循环和开关选择语句"><a href="#循环和开关选择语句" class="headerlink" title="循环和开关选择语句"></a>循环和开关选择语句</h3><blockquote>
<p><code>switch</code> 语句可以使用大括号分段，以表明 cases 之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用 <code>{}</code> 或 <code>continue</code>.</p>
</blockquote>
<p><code>switch</code> 语句中的 <code>case</code> 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<p>如果有不满足 <code>case</code> 条件的枚举值, <code>switch</code> 应该总是包含一个 <code>default</code> 匹配 (如果有输入值没有 <code>case</code> 去处理, 编译器将报警). 如果 <code>default</code> 应该永远执行不到, 简单的加条 <code>assert</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> (var) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></div><div class="line">    ...      <span class="comment">// 4 空格缩进</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">default</span>: &#123;</div><div class="line">    assert(<span class="literal">false</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在单语句循环里，括号可用可不用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i)</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"I love you\n"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"I take it back\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>空循环体应使用 <code>{}</code> 或 <code>continue</code>, 而不是一个简单的分号.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition) &#123;</div><div class="line">  <span class="comment">// 反复循环直到条件失效。</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体。</span></div><div class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑。</span></div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition);  <span class="comment">// 差 - 看起来仅仅只是 while/loop 的部分之一。</span></div></pre></td></tr></table></figure>
<h3 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h3><blockquote>
<p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*</code>, <code>&amp;</code>) 之后不能有空格.</p>
</blockquote>
<p>下面是指针和引用表达式的正确使用范例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">x = *p;</div><div class="line">p = &amp;x;</div><div class="line">x = r.y;</div><div class="line">x = r-&gt;y;</div></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>在访问成员时, 句点或箭头前后没有空格.</li>
<li>指针操作符 <code>*</code> 或 <code>&amp;</code> 后没有空格.</li>
</ul>
<p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 好样的，空格前置。</span></div><div class="line"><span class="keyword">char</span> *c;</div><div class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp;str;</div><div class="line"></div><div class="line"><span class="comment">// 好样的，空格后置。</span></div><div class="line"><span class="keyword">char</span>* c;    <span class="comment">// 但别忘了 "char* c, *d, *e, ...;"!</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; str;</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格。</span></div></pre></td></tr></table></figure>
<p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</p>
<h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><blockquote>
<p>如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.<br>下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</div><div class="line">    a_third_thing == a_fourth_thing &amp;&amp;</div><div class="line">    yet_another &amp; last_one) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 上例的逻辑与 (<code>&amp;&amp;</code>) 操作符均位于行尾. 这格式在 Google 里很常见，您要把所有操作符放在开头也可以。可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外直接用符号形式的操作符，比如 <code>&amp;&amp;</code> 和 <code>~</code>, 不要用词语形式的 <code>and</code> 和 <code>compl</code>.</p>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><blockquote>
<p><code>return</code> 表达式里时没必要都用圆括号。</p>
</blockquote>
<p>假如您写 <code>x = epr</code> 时本来就会加上括号，那 <code>return expr;</code> 也可如法炮制。</p>
<p>函数返回时不要使用圆括号:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">return</span> result;                  <span class="comment">// 返回值很简单，没有圆括号。</span></div><div class="line"><span class="comment">// 可以用圆括号把复杂表达式圈起来，改善可读性。</span></div><div class="line"><span class="keyword">return</span> (some_long_condition &amp;&amp;</div><div class="line">        another_condition);</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">return</span> (value);                <span class="comment">// 毕竟您从来不会写 var = (value);</span></div><div class="line"><span class="keyword">return</span>(result);                <span class="comment">// return 可不是函数！</span></div></pre></td></tr></table></figure>
<h3 id="变量及数组初始化"><a href="#变量及数组初始化" class="headerlink" title="变量及数组初始化"></a>变量及数组初始化</h3><blockquote>
<p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可.</p>
</blockquote>
<p>您可以用 <code>=</code>, <code>()</code> 和 <code>{}</code>, 以下都对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</div><div class="line"><span class="keyword">int</span> x&#123;<span class="number">3</span>&#125;;</div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Some Name"</span>)</span></span>;</div><div class="line"><span class="built_in">string</span> name = <span class="string">"Some Name"</span>;</div><div class="line"><span class="built_in">string</span> name&#123;<span class="string">"Some Name"</span>&#125;;</div></pre></td></tr></table></figure>
<p>请务必小心列表初始化 {…} 用 <code>std::initializer_list</code> 构造函数初始化出的类型。非空列表初始化就会优先调用 <code>std::initializer_list</code>, 不过空列表初始化除外，后者原则上会调用默认构造函数。为了强制禁用 <code>std::initializer_list</code> 构造函数，请改用括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">100</span>, <span class="number">1</span>);  <span class="comment">// A vector of 100 1s.</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// A vector of 100, 1.</span></div></pre></td></tr></table></figure>
<p>此外，列表初始化不允许整型类型的四舍五入，这可以用来避免一些类型上的编程失误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pi</span><span class="params">(<span class="number">3.14</span>)</span></span>;  <span class="comment">// 可 -- pi == 3.</span></div><div class="line"><span class="keyword">int</span> pi&#123;<span class="number">3.14</span>&#125;;  <span class="comment">// Compile error: narrowing conversion.</span></div></pre></td></tr></table></figure>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><blockquote>
<p>预处理指令不要缩进, 从行首开始.</p>
</blockquote>
<p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 可 - directives at beginning of line</span></div><div class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 -- 行开头起。</span></span></div><div class="line">    DropEverything();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    BackToNormal();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 差 - indented directives</span></div><div class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</div><div class="line">    <span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING  <span class="comment">// 错了！ "#if" 应该放在行开头</span></span></div><div class="line">    DropEverything();</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span>                <span class="comment">// 错了！ "#endif" 不要缩进</span></span></div><div class="line">    BackToNormal();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="类格式"><a href="#类格式" class="headerlink" title="类格式"></a>类格式</h3><blockquote>
<p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每次缩进 1 个空格.</p>
</blockquote>
<p>类声明 (对类注释不了解的话, 参考 类注释) 的基本格式如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> MyClass : <span class="keyword">public</span> OtherClass &#123;</div><div class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有 1 空格缩进!</span></div><div class="line">  MyClass();  <span class="comment">// 照常，2 空格缩进。</span></div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</div><div class="line">  ~MyClass() &#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_some_var</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> some_var_;</div><div class="line">  <span class="keyword">int</span> some_other_var_;</div><div class="line">  DISALLOW_COPY_AND_ASSIGN(MyClass);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意事项:</p>
<ul>
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>
<li>关键词 <code>public:</code>, <code>protected:</code>, <code>private:</code> 要缩进 1 个空格.</li>
<li>除第一个关键词 (一般是 <code>public</code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>
<li>这些关键词后不要保留空行.</li>
<li><code>public</code> 放在最前面, 然后是 <code>protected</code>, 最后是 <code>private</code>.</li>
<li>关于声明顺序的规则请参考 声明顺序 一节.</li>
</ul>
<h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><blockquote>
<p>构造函数初始值列表放在同一行或按四格缩进并排几行.</p>
</blockquote>
<p>下面两种初始值列表方式都可以接受:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 当全放在一行合适时：</span></div><div class="line">MyClass::MyClass(<span class="keyword">int</span> var) : some_var_(var), some_other_var_(var + <span class="number">1</span>) &#123;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 如果要断成多行，缩进四格，冒号放在第一行初始化句：</span></div><div class="line">MyClass::MyClass(<span class="keyword">int</span> var)</div><div class="line">    : some_var_(var),             <span class="comment">// 4 空格缩进</span></div><div class="line">      some_other_var_(var + <span class="number">1</span>) &#123;  <span class="comment">// 对准</span></div><div class="line">  ...</div><div class="line">  DoSomething();</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="名字空间格式化"><a href="#名字空间格式化" class="headerlink" title="名字空间格式化"></a>名字空间格式化</h3><blockquote>
<p>名字空间内容不缩进.</p>
</blockquote>
<p>名字空间 不要增加额外的缩进层次, 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> &#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确。命名空间内没有额外的缩进。</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;  <span class="comment">// namespace</span></div></pre></td></tr></table></figure>
<p>不要缩进名字空间:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 错，缩进多余了。</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;  <span class="comment">// namespace</span></div></pre></td></tr></table></figure>
<p>声明嵌套命名空间时，每命名空间都独立成行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> foo &#123;</div><div class="line"><span class="keyword">namespace</span> bar &#123;</div></pre></td></tr></table></figure>
<h3 id="水平留白"><a href="#水平留白" class="headerlink" title="水平留白"></a>水平留白</h3><blockquote>
<p>水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白.</p>
</blockquote>
<p>常规:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前恒有空格。</span></div><div class="line">  ...</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格。</span></div><div class="line"><span class="keyword">int</span> x[] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 大括号内部可与空格紧邻也不可，不过两边都要加上。</span></div><div class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格。</span></div><div class="line"><span class="keyword">class</span> Foo : <span class="keyword">public</span> Bar &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// 至于内联函数实现，在大括号内部加上空格并编写实现。</span></div><div class="line">  Foo(<span class="keyword">int</span> b) : Bar(), baz_(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话，不加空格。</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开。</span></div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（确信没有其他人在处理). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p>
<p>循环和条件语句:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格。</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格。</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格。</span></div><div class="line"><span class="keyword">switch</span> (i) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</div><div class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻。</span></div><div class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号，但这很少见。总之要一致。</span></div><div class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</div><div class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格，； 前可以加个空格。</span></div><div class="line"><span class="keyword">switch</span> (i) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格。</span></div><div class="line">    ...</div><div class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码，加个空格。</span></div></pre></td></tr></table></figure>
<p>操作符:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 赋值操作系统前后恒有空格。</span></div><div class="line">x = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// 其它二元操作符也前后恒有空格，不过对 factors 前后不加空格也可以。</span></div><div class="line"><span class="comment">// 圆括号内部不紧邻空格。</span></div><div class="line">v = w * x + y / z;</div><div class="line">v = w*x + y/z;</div><div class="line">v = w * (x + z);</div><div class="line"></div><div class="line"><span class="comment">// 在参数和一元操作符之间不加空格。</span></div><div class="line">x = <span class="number">-5</span>;</div><div class="line">++x;</div><div class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>模板和转换:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 尖叫括号(&lt; and &gt;) 不与空格紧邻，&lt; 前没有空格，&gt;( 之间也没有。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; x;</div><div class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);</div><div class="line"></div><div class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以，但要保持一致。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span> *&gt; x;</div><div class="line"><span class="built_in">set</span>&lt;<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;&gt; x;        <span class="comment">// 在 C++11 代码里可以这样用了。</span></div><div class="line"><span class="built_in">set</span>&lt;<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; &gt; x;       <span class="comment">// C++03 中要在 &gt; &gt; 里留个空格。</span></div><div class="line"></div><div class="line"><span class="comment">// 您或许可以在 &lt; &lt; 里加上一对对称的空格。</span></div><div class="line"><span class="built_in">set</span>&lt; <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; &gt; x;</div></pre></td></tr></table></figure>
<h3 id="垂直留白"><a href="#垂直留白" class="headerlink" title="垂直留白"></a>垂直留白</h3><blockquote>
<p>垂直留白越少越好.</p>
</blockquote>
<p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p>
<p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 取决于你的判断. 但通常是垂直留白越少越好.</p>
<p>空行心得如下：</p>
<ul>
<li>函数体内开头或结尾的空行可读性微乎其微。</li>
<li>在多重 if-else 块里加空行或许有点可读性。</li>
</ul>
<p>译者 (YuleFox) 笔记</p>
<ol>
<li>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</li>
<li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li>
<li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</li>
<li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li>
<li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</li>
<li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</li>
<li><code>.</code>/<code>-&gt;</code> 操作符前后不留空格, <code>*</code>/<code>&amp;</code> 不要前后都留, 一个就可, 靠左靠右依各人喜好;</li>
<li>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</li>
<li>初始化用 <code>=</code> 还是 <code>()</code> 依个人喜好, 统一就好;</li>
<li><code>return</code> 不要加 <code>()</code>;</li>
<li>水平/垂直留白不要滥用, 怎么易读怎么来.</li>
<li>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (.cc 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然.</li>
</ol>
<p>译者（acgtyrant）笔记</p>
<ol>
<li>80 行限制事实上有助于避免代码可读性失控，比如超多重嵌套块，超多重函数调用等等。</li>
<li>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码，不像奇葩的 Windows.</li>
<li>Google 强调有一对 if-else 时，不论有没有嵌套，都要有大括号。Apple 正好 <a href="http://coolshell.cn/articles/11112.html" target="_blank" rel="external">有栽过跟头</a> .</li>
<li>其实我主张指针／地址操作符与变量名紧邻，<code>int* a, b vs int *a, b</code>, 新手会误以为前者的 <code>b</code>是 <code>int *</code> 变量，但后者就不一样了，高下立判。</li>
<li>在这风格指南里我才刚知道 C++ 原来还有所谓的 <a href="http://en.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="external">Alternative operator representations</a>, 大概没人用吧。</li>
<li>注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事，我就差点混淆了它们的翻译。</li>
<li>事实上，如果您熟悉英语本身的书写规则，就会发现该风格指南在格式上的规定与英语语法相当一脉相承。比如普通标点符号和单词后面还有文本的话，总会留一个空格；特殊符号与单词之间就不用留了，比如 <code>if (true)</code> 中的圆括号与 <code>true</code>.</li>
<li>本风格指南没有明确规定 void 函数里要不要用 return 语句，不过就 Google 开源项目 leveldb 并没有写；此外从 <a href="http://stackoverflow.com/questions/9316717/is-a-blank-return-statement-at-the-end-of-a-function-whos-return-type-is-void-ne" target="_blank" rel="external">Is a blank return statement at the end of a function whos return type is void necessary?</a> 来看，<code>return;</code> 比 <code>return ;</code> 更约定俗成（事实上 cpplint 会对后者报错，指出分号前有多余的空格），且可用来提前跳出函数栈。</li>
</ol>
<h2 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h2><p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p>
<h3 id="现有不合规范的代码"><a href="#现有不合规范的代码" class="headerlink" title="现有不合规范的代码"></a>现有不合规范的代码</h3><blockquote>
<p>对于现有不符合既定编程风格的代码可以网开一面.</p>
</blockquote>
<p>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心可以与代码原作者或现在的负责人员商讨, 记住, 一致性 包括原有的一致性.</p>
<h3 id="Windows-代码"><a href="#Windows-代码" class="headerlink" title="Windows 代码"></a>Windows 代码</h3><blockquote>
<p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.<br>如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p>
</blockquote>
<ul>
<li>不要使用匈牙利命名法 (比如把整型变量命名成 <code>iNum</code>). 使用 Google 命名约定, 包括对源文件使用 <code>.cc</code> 扩展名.</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 <code>DWORD</code>, <code>HANDLE</code> 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 但还是尽量使用原有的 C++ 类型, 例如, 使用 <code>const TCHAR *</code> 而不是 <code>LPCTSTR</code>.</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有 warnings 当作 errors 处理.</li>
<li>不要使用 <code>#pragma once</code>; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 <code>#ifndef SRC_DIR_BAR_H_</code>, 参考 #define 保护 一节).</li>
<li>除非万不得已, 不要使用任何非标准的扩展, 如 <code>#pragma</code> 和 <code>__declspec</code>. 允许使用 <code>__declspec(dllimport)</code> 和 <code>__declspec(dllexport)</code>; 但你必须通过宏来使用, 比如 <code>DLLIMPORT</code> 和 <code>DLLEXPORT</code>, 这样其他人在分享使用这些代码时很容易就去掉这些扩展.</li>
</ul>
<p>在 Windows 上, 只有很少的一些情况下, 我们可以偶尔违反规则:</p>
<ul>
<li>通常我们 禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 <code>_ATL_NO_EXCEPTIONS</code> 以禁用异常. 你要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 启用编译器异常也可以. (注意这只是为了编译 STL, 自己代码里仍然不要含异常处理.)</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 <code>StdAfx.h</code> 或 <code>precompile.h</code> 的文件. 为了使代码方便与其他项目共享, 避免显式包含此文件 (<code>precompile.cc</code>), 使用 <code>/FI</code> 编译器选项以自动包含.</li>
<li>资源头文件通常命名为 <code>resource.h</code>, 且只包含宏的, 不需要遵守本风格指南.</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote>
<p>运用常识和判断力, 并 保持一致.</p>
</blockquote>
<p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 if 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (<code>*</code>) 围成一个盒子状, 你同样要这么做.</p>
<p>风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示了全局的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也影响阅读, 所以要尽量避免.</p>
<p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离我第一次接触 Google Cpp 编码风格指南已经过去了八年，现在再来看看，感觉别有一番风味。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
      <category term="风格" scheme="http://wdxtub.com/tags/%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>【C++ 编程思想】读书笔记</title>
    <link href="http://wdxtub.com/2017/01/29/thinking-in-cpp-clip/"/>
    <id>http://wdxtub.com/2017/01/29/thinking-in-cpp-clip/</id>
    <published>2017-01-28T23:43:32.000Z</published>
    <updated>2017-01-29T01:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文源自我大学时阅读本书的笔记，算是对自己的『温故知新』。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.29: 完成初稿</li>
</ul>
<h2 id="第1章-对象导言"><a href="#第1章-对象导言" class="headerlink" title="第1章 对象导言"></a>第1章 对象导言</h2><p>本章将介绍面向对象程序设计(OOP)的基本概念，包括OOP开发方法的概述。</p>
<h3 id="1-1-抽象的过程"><a href="#1-1-抽象的过程" class="headerlink" title="1.1 抽象的过程"></a>1.1 抽象的过程</h3><p>所有的程序语言都提供抽象。可以说，人们能解决的问题的复杂性直接与抽象的类型和质量有关。汇编语言时对底层机器的小幅度抽象。其后的许多所谓“命令式”语言(例如Fortran、Basic和C)都是对汇编语言的抽象。OPP允许程序员用问题本市的术语来描述问题，而不是用要运行解决方案的计算机的术语来描述问题。每个对象看上去像一台小计算机，它有状态，有可执行的运算。这似乎是现实世界中对象的很好类比，它们都有特性和行为。</p>
<p>面向对象语言的五个基本特性：</p>
<ol>
<li>万物皆对象。</li>
<li>程序就是一组对象，对象之间通过发送消息互相通知做什么。</li>
<li>每个对象都有它子集的由其他对象构成的存储区。</li>
<li>每个对象都有一个类型。</li>
<li>一个特定类型的所有对象都能接收相同的消息。</li>
</ol>
<h3 id="1-2-对象有一个接口"><a href="#1-2-对象有一个接口" class="headerlink" title="1.2 对象有一个接口"></a>1.2 对象有一个接口</h3><p>创建抽象数据类型是面向对象程序设计的基本思想。抽象数据类型几乎能完全像内部类型一样工作。</p>
<p>类描述了一组有相同特性(数据元素)和相同行为(功能)的对象，因此类实际上就是数据类型。面向对象程序设计的难题之一，是在问题空间中的元素和解空间中的对象之间建立一对一的映射。</p>
<p>必须有一种方法能向对象作出请求，使得它能做某些事情。可以向对象发出的请求是由它的接口(interface)定义的，而接口由类型确定。接口规定我们能向特定的对象发出什么请求。然后，必须有代码满足这种请求，再加上隐藏的数据，就组成了实现(implementation)。</p>
<h3 id="1-3-实现的隐藏"><a href="#1-3-实现的隐藏" class="headerlink" title="1.3 实现的隐藏"></a>1.3 实现的隐藏</h3><p>C++语言使用了三个明确的关键字来设置类中的边界：public、private 和 protected。public 意味着随后的定义对所有人都可用。相反，private 关键字则意味着，除了该类型的创建者和该类型的内部成员函数之外，任何人都不能访问这些定义。继承的类可以访问 protected 成员，但不能访问 private 成员。</p>
<h3 id="1-4-实现的重用"><a href="#1-4-实现的重用" class="headerlink" title="1.4 实现的重用"></a>1.4 实现的重用</h3><p>代码重用是面向对象程序设计语言的最大优点之一。可以用任何数量和类型的其他对象组成新类，通过组合得到新类所希望的功能。因为这是由已经存在的类组成新类，所以称为组合(composition)【或者更通常称为聚合(aggregation)】。组合常常被称为“has-a(有)”关系。</p>
<p>当创建新类时，程序员应当首先考虑组合，因为它更简单和更灵活。如果采用组合的方法，设计将变得清晰。</p>
<h3 id="1-5-继承：重用接口"><a href="#1-5-继承：重用接口" class="headerlink" title="1.5 继承：重用接口"></a>1.5 继承：重用接口</h3><p>克服许多困难去创造一个类，并随后强制性地创造一个有类似功能地全新地类，似乎很愚蠢。如果能选取已存在地类、克隆它，然后对这个克隆增加和修改，则是再好不过地事。这是继承(inheritance)带来地好处，缺点是，如果原来的类(称为基类、超类或父类)被修改，则这个修改过的“克隆”(称为派生类、继承类或子类)也会表现出这些改变。</p>
<p>当我们从已经存在的类型来继承时，我们就创造了一个新类型。这个新类性不仅包含那个已经存在的类型的所有成员，还复制了这个基类的接口，这意味着这个派生类与这个基类是相同类型的。 </p>
<p>有两种方法能使新派生类区别于原始基类。第一种相当直接，简单地向派生类添加全新的函数。这些新函数不是基类接口的一部分。着意味着，这个基类不能做我们希望它做的事情，所以必须添加函数。</p>
<p>虽然继承有时意味着向接口添加新函数，但这未必真的需要。是新类有别于基类的第二个和更重要的方法是，改变已经存在的基类函数的行为，这称为重载(overriding)这个函数。为了重载函数，可以简单地再派生类中创建新定义。相当于说：“我正再使用同一个接口函数，但是我希望它为我做不同的事情。”</p>
<p><strong>1.5.1 is-a 关系和 is-like-a 关系</strong></p>
<p>只重载基类(并且不添加基类中没有的新成员函数)的继承意味着派生类和基类是完全相同的类型，因为它们有相同的接口。结果是，我们可以用派生类的对象代替基类的对象。因此这被认为是纯代替(pure substitution)，常常被称为代替原则(substitution principle)。这种情况下，我们常把基类和派生类直接的关系看作是一个“is-a(是)”关系。</p>
<p>有时需要向一个派生类型添加新的接口元素，这样就扩展了接口并创建了新类型。这个新类型仍然可以代替这个基类，但这个代替不是完美的，因为这些新函数不能从基类访问，这可以描述为“is-like-a(像)”关系。</p>
<h3 id="1-6-具有多态性的可互换对象"><a href="#1-6-具有多态性的可互换对象" class="headerlink" title="1.6 具有多态性的可互换对象"></a>1.6 具有多态性的可互换对象</h3><p>如果试图把派生类型的对象看做是比它们自身更一般的基本类型(圆形看做形体，自行车看做车辆)，这里就有一个问题：如果一个函数告诉一个一般的形体去绘制它子集，或者告诉一个一般的车辆去行驶，则编译器再编译时就不能确切地知道应当执行哪段代码。同样地问题是，消息发送时，程序员并不想知道将执行哪段代码。编译器不能确切地知道执行哪段代码，那么它应该怎么办呢？</p>
<p>在面向对象的程序设计中，答案非常新奇：编译器并不做传统意义上的函数调用。非OOP编译器产生的函数调用会导致与被调用代码的早捆绑(early binding)，其意思是：编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。</p>
<p>在OOP中，知道程序运行时，编译器才能确定执行代码的地址，所以，当消息被发送给一般对象时，需要采用其他的方案。为了解决这一问题，面向对象语言采用晚捆绑(late binding)的思想。当给对象发送消息时，在程序运行时才去确定被调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回值的类型检查【其中不采用这种处理方式的语言称为弱类型(weakly typed)语言】，但是它并不知道将执行的确切代码。</p>
<p>为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的二进制代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址(详见第15章)。这样每个对象就能根据这段二进制代码的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应当做什么。</p>
<p>我们可以用关键字 virtual 声明他希望某个函数有晚捆绑的灵活性。在 C++ 中，必须记住添加 virtual 关键字，因为根据规定，默认情况下成员函数不能动态捆绑。virtual 函数(虚函数)可用来表示出在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。</p>
<p>我们把处理派生类型就如同处理其基类型的过程称为向上类型转换(upcasting)。编译器和运行系统可以处理这些细节，我们只需要知道它会这样做和知道如何用它设计程序就行了。如果一个成员函数是virtual的，则当我们给一个对象发送消息时，这个对象将做正确的事情，即使是在有向上类型转换的情况下。</p>
<h3 id="1-7-创建和销毁对象"><a href="#1-7-创建和销毁对象" class="headerlink" title="1.7 创建和销毁对象"></a>1.7 创建和销毁对象</h3><p>对象的数据存放在何处？如何控制对象的生命期？不同的设计语言有不同的处理方式。C++ 才去的方法是把效率控制作为最重要的问题，所以它为程序员提供了一个选择。为了最大化运行速度，通过将对象存放在栈中或静态存储区域中，存储和生命期可以在编写程序时确定。栈是内存中的一个区域，可以直接由微处理器在程序执行期间存放数据。在栈中的变量有时称自动变量(automatic variable)或局部变量(scoped variable)。静态存储区简单说是内存的一个固定块，在程序开始执行以前分配。使用栈或静态存储区，可以快速分配和释放，但是我们因此也牺牲了灵活性。</p>
<p>第二种方法是在称为堆(heap)的区域动态创建对象。用这种方法，可以直到运行时还不知道需要多少个对象，它们的生命期是什么和他们的准确数据类型是什么。这些决定是在程序运行之中作出的。如果需要心的对象，直接使用new关键字让它在堆上生成。当使用结束时，用关键字delete释放。</p>
<p>另一个问题是对象的生命期。如果在栈上或在静态存储上创建一个对象，编译器决定这个对象持续多长时间并能自动销毁它。然后，如果在堆上创建它，编译器则不知道它的生命期。在C++中，程序员必须编程决定何时销毁此对象。作为一个替换，运行环境可以提供一个称为垃圾收集器(garbage collector)的功能。当然，使用垃圾收集器编写程序是非常方便的，但是它需要所有应用软件能承受垃圾收集器的存在及垃圾收集的系统开销。</p>
<h3 id="1-8-异常处理：应对错误"><a href="#1-8-异常处理：应对错误" class="headerlink" title="1.8 异常处理：应对错误"></a>1.8 异常处理：应对错误</h3><p>从程序设计语言出现开始，错误处理就是最重要的问题之一。因为设计一个好的错误处理方案非常困难，许多语言忽略这个问题，将这个问题转交给库的设计者，而库的设计者往往采取不彻底的措施，即可以在许多情况下起作用，但很容易被绕考，通常是被忽略。</p>
<p>异常处理(exception handling)将错误处理直接与程序设计语言甚至有时是操作系统联系起来。异常是一个对象，它在出错的地方被抛出，并且被一段用以处理特定类型错误的异常处理代码(exception handler)所接收。异常处理似乎是另一个并行的执行路径，在出错的时候被调用。由于它使用一个单独的执行路径，它并不需要干涉正常的执行代码。因为不需经常检查错误，代码可以很简洁。另外，异常并不同于一个由函数返回的错误值或标记，后两者可以被忽略，而异常不能被忽略，必须保证它们在某些点上进行处理。最后，异常提供了一个从错误状态中进行可靠恢复的方法。除了从这个程序中退出以外，我们常常还可以作出正确的设置，并且回复程序执行，这有助于产生更健壮的系统。</p>
<h3 id="1-9-分析和设计"><a href="#1-9-分析和设计" class="headerlink" title="1.9 分析和设计"></a>1.9 分析和设计</h3><p>方法(method)［通常称为方法论(methodology)］是一系列的过程和探索，用以降低程序设计问题的复杂性。</p>
<p>经历开发过程时，最重要的问题是：不要迷路。如果不定因素不止一个，在没有创建一个能工作的原型之前，不要计划它将用多长时间和花费多少，这里的自由度太大了。</p>
<p>应当牢记我们正在努力寻找的是什么：</p>
<ul>
<li>什么是对象(如何将项目分成多个组成部分？)</li>
<li>它们的接口是什么？(需要向每个对象发送什么信息？)</li>
</ul>
<p>整个过程可以分5个阶段完成，阶段0只是使用一些结构的初始约定。</p>
<p><strong>1.9.1 第0阶段：制定计划</strong></p>
<p>我们必须首先决定在此过程中应当有哪些步骤。无论建造什么系统，不管如何复杂，都有其基本的目的，有其要处理的业务，有所满足的基本需要。通过各种观察，我们将最终找出它的核心，通常简单而又直接。</p>
<p>这个相当重要，因为它设定了项目的基调，这是一种任务陈述。我们不必一开始就让它正确，但是要不停地努力使其越来越正确。</p>
<p><strong>1.9.2 第1阶段：我们在做什么</strong></p>
<p>这一阶段我们有必要把注意力始终放在核心问提上：确定这个系统要做什么。为此，最有价值的工具是一组所谓的“用例(use case)”。用例之明了系统中的关键特性，它们将展现我们使用的一些节本的类。它们实际上是对类似于下列问题的描述性回答：</p>
<ul>
<li>“谁将使用这个系统？”</li>
<li>“执行者用这个系统做什么？”</li>
<li>“执行者如何用这个系统工作？”</li>
<li>“如果其他人也做这件事，或者同一个执行者有不同的目标，该怎么办？(揭示变化)”</li>
<li>“当使用这个系统时，会发生什么问题？(揭示异常)”</li>
</ul>
<p>只要符合用户的使用感受，系统实际上如何实现并不重要。</p>
<p><strong>1.9.3 第2阶段：我们将如何建立对象</strong></p>
<p>在这一阶段，我们必须作出设计，描述这些类和它们如何交互。确定类和交互的出色技术就是：<br>类职责协同(Class-Responsibility-Collaboration，CRC)卡片。</p>
<p>这个技术非常简单：只要有一组小空白卡片，在上面书写。每张卡片描述一个类，所写的内容有：</p>
<ul>
<li>类的名字。体现类行为的本质，一目了然的作用。</li>
<li>类的职责。它应当做什么。通常，它可以仅由成员函数的名字陈述。</li>
<li>类的协同：它与其他类有哪些交互？如果一张小卡片上放不下类所需要的信息，那么这个类就太复杂了(或者是考虑过细了，或者应当创建多个类)。理想的类应该一目了然。</li>
</ul>
<p>对象开发准则：</p>
<ul>
<li>让特定问题生成一个类，然后在解决其他问题期间让这个类生长和成熟。</li>
<li>记住，发现所需要的类(和它们的接口)，是设计系统的主要内容。如果已经有了那些类，这个项目就不困难了。</li>
<li>不要强迫自己在一开始就知道每一件事情，应当不断学习。</li>
<li>开始编程，让一部分能够运行，这样就可以证明或否定已生成的设计。不要害怕过程型大杂烩式的代码──类的隔离性可以控制它们。坏的类不会破坏好的类。</li>
<li>尽量保持简单。具有明显用途的不太清楚的对象比很复杂的接口好。从小的和简单的类开始，当我们对它有了较好的理解时再拓展这个类接口，但是很难从一个类中删去元素。</li>
</ul>
<p><strong>1.9.4 第3阶段：创建核心</strong></p>
<p>这是从粗线条设计向便宜和执行可执行代码体的最初转换阶段，特别是，它将证明或者否定我们的体系结构。这不是一遍的过程，而是反复地建立系统的一系列步骤的开始。</p>
<p><strong>1.9.5 第4阶段：迭代用例</strong></p>
<p>一旦代码框架运行起来，我们增加的每一组特征本身就是一个小项目。在一次迭代(iteration)期间，我们增加一组特征，一次迭代是一个相当短的开发时期。</p>
<p>理想情况下，每次迭代为一到三个星期，在这个期间的最后，我们得到一个集成的、测试过的、比前一周期有更多功能的系统。</p>
<p>通过这些过程，我们可以更早地揭露和解决严重问题，客户有足够的机会改变它们的意见，程序员会更满意，能更精确地掌握项目。</p>
<p><strong>1.9.6 第5阶段：进化</strong></p>
<p>这是开发周期中，传统上称为“维护”的一个阶段。我们不可能第一次就使软件正确，所以应当为学习、返工和修改留有余地。</p>
<p>“使软件正确”的意思不只是使程序按照要求和用例工作，还意味着我们理解代码的内部结构，并且认识到它能很好地协同工作，没有拙笨的语法和过大的对象，也没有难看的暴露的代码。</p>
<p><strong>1.9.7 计划的回报</strong></p>
<p>提出一个漂亮的方案感觉上更接近于艺术，而不是技术。精致总是有回报的，这不是一种虚浮的追求。它不仅给除了一个容易建造和调试的程序，而且容易理解和维护，这就是其经济价值的体现。</p>
<h3 id="1-10-极限编程-eXtreme-Programming-XP"><a href="#1-10-极限编程-eXtreme-Programming-XP" class="headerlink" title="1.10 极限编程(eXtreme Programming,XP)"></a>1.10 极限编程(eXtreme Programming,XP)</h3><p>XP既是程序设计工作的哲学，又是做程序设计的一组原则。有两个原则最重要：“先写测试”和“结对编程”。</p>
<p>先写测试有两个及其重要的作用：</p>
<ul>
<li>它强制类的接口有清楚的定义。</li>
<li>能在每次编连软件时运行这些测试。</li>
</ul>
<p>结对编程(pair programming)反对深植于我们心中的个人主义，一个人编写代码时另一个人在思考。思考者的头脑中保持总体概念，不仅是手头问题这一段，而且还有XP指导方针。这种结对方式，使事情顺畅、有章可循。</p>
<h2 id="第2章-对象的创建与使用"><a href="#第2章-对象的创建与使用" class="headerlink" title="第2章 对象的创建与使用"></a>第2章 对象的创建与使用</h2><h3 id="2-1-语言的翻译过程"><a href="#2-1-语言的翻译过程" class="headerlink" title="2.1 语言的翻译过程"></a>2.1 语言的翻译过程</h3><p>任何一种计算机语言都要从某种人们理解的形式(源代码)转化成计算机能执行的形式(机器指令)。通常，翻译器分为两类：解释器(interpreter)和编译器(compiler)。</p>
<p><strong>解释器(interpreter)</strong></p>
<p>将源代码转化成一些动作并立即执行这些动作。使用解释器有许多好处。从写代码到执行代码的转换几乎能立即完成，并且源代码总是显存，所以一旦出现错误，解释器能很容易地指出。另外的优点是较好的交互性和适于快速程序开发。</p>
<p>做大项目时候就有某些局限性。要求一次输入整个源代码，一旦出现错误，就很难调试。</p>
<p><strong>编译器(compiler)</strong></p>
<p>编译器直接把源代码转化成汇编语言或机器指令。某些语言可以分别编译各段程序，最后使用连接器(linker)把各段程序连接成一个完整的可执行程序。这个过程称为分段编译(separate compilation)。</p>
<p>某些语言(特别是C/C++)编译时，首先要对源代码执行预处理。预处理器(preprocessor)是一个简单的程序，用程序员(利用预处理器指令)定义好的模式代替源代码中的模式。</p>
<p>编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元并把它们按树形结构组织起来。有时候会在编译的第一遍和第二遍之间使用全局优化器(global optimizer)来生成更短、更快的代码。</p>
<p>编译的第二遍由代码生成器(code generator)遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。</p>
<p>类型检查(type checking)是编译器在第一遍中完成的。类型检查是检查函数参数是否正确使用，以防止许多程序设计错误。由于类型检查是在编译阶段而不是程序运行阶段进行的，所以称之为静态类型检查(static type checking)。在C++里可以不使用静态类型检查。我们可以自己做动态类型检查──这只需要写一些代码。</p>
<h2 id="第3章-C-中的C"><a href="#第3章-C-中的C" class="headerlink" title="第3章 C++中的C"></a>第3章 C++中的C</h2><h3 id="3-1-指定存储空间分配"><a href="#3-1-指定存储空间分配" class="headerlink" title="3.1 指定存储空间分配"></a>3.1 指定存储空间分配</h3><p><strong>3.1.1 全局变量</strong></p>
<p>全局变量是在所有函数体的外部定义的，程序的所有部分(甚至其他文件中的代码)都可以使用。全局变量不受作用域的影响，总是可用的(也就是说，全局变量的生命期一直到程序的结束)。如果在一个文件中存在全局变量，那么这个文件可以使用这个数据。</p>
<p><strong>3.1.2 局部变量</strong></p>
<p>局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量(automatic variable)，因为它们在进入作用域时自动生成，离开作用域时自动消失。<br>寄存器变量是一种局部变量，最好避免使用关键字register。</p>
<p><strong>3.1.3 静态变量</strong></p>
<p>关键字static有一些独特的意义。通常，函数中定义的局部变量在函数作用域结束时小时。当再次调用这个函数时，会重新创建该变量的存储空间，其值会被重新初始化。如果想使局部变量的值在程序的整个生命期里仍然存在，就可以定义函数的局部变量为static，并给它一个初始值。初始化只在函数第一次调用时执行，函数调用之间变量的值保持不变。用这种方式，函数可以“记住”函数调用之间的一些信息片段。</p>
<p>static变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易地改变。这会使错误局部化。</p>
<p>static的第二层意思和前面的含义相关，即“在某个作用域外不可访问”。当应用static于函数名和所有函数外部的变量时，它的意思是“在文件的外部不可以使用这个名字”。函数名或变量是局部于文件的；我们说它具有文件作用域(file scope)。即使在另一个文件用extern声明，连接器也不会找到它。</p>
<p><strong>3.1.4 外部变量</strong></p>
<p>extern关键字告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它，这个变量或函数可能在另一个文件中或者在当前文件的后面定义。</p>
<p><strong>连接(linkage)</strong></p>
<p>连接用连接器所见的方式描述存储空间。连结方式有两种：内部连接(internal linkage)和外部连接(external linkage)。内部连接意味着只对正被编译的文件创建存储空间。用内部连接，别的文件可以使用相同的标识符或全局变量，连接器不会发现冲突──也就是为每一个标识符创建单独的存储空间。在C和C++中，内部连接是由关键字static指定的。</p>
<p>外部连接意味着所有被编译过的文件创建一片单独的存储空间。一旦创建存储空间，连接器必须解决所有对这片存储空间的引用。</p>
<h3 id="3-2-运算符及其使用"><a href="#3-2-运算符及其使用" class="headerlink" title="3.2 运算符及其使用"></a>3.2 运算符及其使用</h3><p>所有的运算符都会从它们的操作数中产生一个值。除了赋值、自增、自减运算符之外，运算符所产生的值不会修改操作数。修改操作数被称为副作用(side effect)。一般使用修改操作数的运算就是为了产生这种副作用。</p>
<p><strong>3.2.1 逗号运算符</strong></p>
<p>可以作为一个运算符用于分隔表达式。在这种情况下，它只产生最后一个表达式的值。在逗号分隔的列表中，其余的表达式的计算只完成它们的副作用。</p>
<p>通常，除了作为一个分隔符，逗号最好不作他用，因为人们不习惯把它看作是运算符。</p>
<h2 id="第4章-数据抽象"><a href="#第4章-数据抽象" class="headerlink" title="第4章 数据抽象"></a>第4章 数据抽象</h2><p>库只是他人已经写好的一些代码，按照某种方式包装在一起。通常，最小的包是带有拓展名(如lib)的文件和向编译器声明库中有什么的一个或多个头文件。在跨越多种体系结构的平台(例如Linux和Unix)上，通常，提供库的最明智的方法是使用源代码，这样它就能在心的目标机上被重新配置和编译。</p>
<p>所以，库大概是改进生产效率的最重要的方法。C++的主要设计目标之一就是使库使用起来更加容易。</p>
<h3 id="4-1-什么是对象"><a href="#4-1-什么是对象" class="headerlink" title="4.1 什么是对象"></a>4.1 什么是对象</h3><p>在C++中，对象就是变量，它的最纯正的定义是“一块存储区”(更明确的说法是，“对象必须有惟一的标识”，在C++中是一个惟一的地址)。它是一块空间，在这里能存放数据，而且还隐含着对这些数据进行处理的操作。</p>
<h3 id="4-2-抽象数据类型"><a href="#4-2-抽象数据类型" class="headerlink" title="4.2 抽象数据类型"></a>4.2 抽象数据类型</h3><p>将数据连同函数捆绑在一起的能力可以用于创建新的数据类型。这常常被称为封装(encapsulation)。称为抽象数据类型(abstract data type)，也许这是因为它能允许从问题空间抽象概念到解空间。对抽象数据类型[有时称为用户定义类型(user-defined type)]的类型检查就像对内建类型的类型检查一样严格。</p>
<h3 id="4-3-头文件"><a href="#4-3-头文件" class="headerlink" title="4.3 头文件"></a>4.3 头文件</h3><p>头文件是我们和我们的库的用户之间的合约。这份合约描述了我们的数据结构，为函数调用贵点了参数和返回值。</p>
<p>通过要求我们在使用结构和函数之前声明所有这些结构和函数，在定义成员函数之前声明这些成员函数，编译器强制履行这个合约。</p>
<p>放到头文件中的基本原则是“只限于声明”，即只限于对编译器的信息，不涉及通过生成代码或创建变量而分配存储的任何信息。</p>
<p><strong>4.3.1 头文件的标准</strong></p>
<p>对于包含结构的每个头文件，应当首先检查这个头文件是否已经包含在特定的cpp文件中，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_FLAG</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_FLAG</span></div><div class="line"><span class="comment">// Type declaration here...</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HEADER_FLAG</span></span></div></pre></td></tr></table></figure>
<p>防止多次包含的这些预处理器语句常常称为包含守卫(include guard)。</p>
<h2 id="第5章-隐藏实现"><a href="#第5章-隐藏实现" class="headerlink" title="第5章 隐藏实现"></a>第5章 隐藏实现</h2><h3 id="5-1-设置限制"><a href="#5-1-设置限制" class="headerlink" title="5.1 设置限制"></a>5.1 设置限制</h3><p>在任何关系中，设立相关各方面都遵从的边界是很重要的。需要控制对结构成员的访问有两个理由：一是让客户程序员远离一些它们不需要使用的工具，这些工具对数据类型内部的处理来说是必需的，但对客户程序员解决特定问题的接口却不是必须的。另一个理由是允许库的设计者改变struct的内部实现，而不必担心会对客户程序员产生影响。</p>
<h3 id="5-2-C-的访问控制"><a href="#5-2-C-的访问控制" class="headerlink" title="5.2 C++的访问控制"></a>5.2 C++的访问控制</h3><p>引进了三个访问说明符(access specifier)：public、private和protected。无论什么时候使用访问说明符，后面必须加一个冒号。</p>
<ul>
<li><code>public</code> 意味着在其后声明的所有成员可以被所有的人访问。</li>
<li><code>private</code> 关键字则意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问。</li>
<li><code>protected</code> 与 <code>private</code> 基本相似，只有一点不同：继承的结构可以访问 protected 成员，但不能访问 private 成员。</li>
</ul>
<h3 id="5-3-友元"><a href="#5-3-友元" class="headerlink" title="5.3 友元"></a>5.3 友元</h3><p>如果想允许显示地不属于当前结构的一个成员函数访问当前结构中的数据，可以在该结构内部声明这个函数为friend(友元)。注意，一个 friend 必须在一个结构内声明，这一点很重要。</p>
<p><strong>5.3.1 嵌套友元</strong></p>
<p>嵌套的结构并不能自动获得访问private成员的权限。要获得访问私有成员的权限，必须存手特定的规则：首先声明(而不定义)一个嵌套的结构，然后声明它是全局范围使用的一个friend，最后定义这个结构。结构的定义必须与friend声明分开，否则编译器将不把它看做成员。</p>
<p><strong>5.3.2 它是纯面向对象的吗</strong></p>
<p>C++ 不是完全的面向对象语言，而只是一个混合产品。增加 friend 关键字就是为了用来解决一些实际问题。这也说明了这种语言是不纯的。毕竟 C++ 语言的设计目的是使用，而不是追求理想的抽象。</p>
<h3 id="5-4-对象布局"><a href="#5-4-对象布局" class="headerlink" title="5.4 对象布局"></a>5.4 对象布局</h3><p>访问说明符是结构的一部分，它们并不影响从这个结构创建的对象。程序开始运行之前，所有的访问说明信息都消失了。访问说明信息通常是在编译期间消失的。</p>
<p>一般说来，在程序员编写程序时，依赖特定实现的任何东西都是不合适的。如确有必要，这些特定实现部分应封装在一个结构之内，这样当环境改变时，只需修改一个地方就行了。</p>
<h3 id="5-5-类"><a href="#5-5-类" class="headerlink" title="5.5 类"></a>5.5 类</h3><p>访问控制通常是指实现细节的隐藏(implementation hiding)。将函数包含到一个结构内(常称为封装)来产生一种带数据和操作的数据类型，由访问控制在该数据类型之内确定边界。</p>
<p>然后在 C+ +中的 class 逐渐变成了一个非必要的关键字。它和 struct 的每个方面都是一样的，除了 class 中的成员默认为 private，而 struct 中的成员默认为 public。</p>
<h3 id="5-6-句柄类"><a href="#5-6-句柄类" class="headerlink" title="5.6 句柄类"></a>5.6 句柄类</h3><p>C++ 中的访问控制允许将实现部分与接口部分分开，但实现部分的隐藏是不完全的。编译器仍然必须知道一个对象所有部分的声明。但 C++ 要尽可能多地在编译期间作静态类型检查。这意味着尽早捕获错误，也意味着程序具有更高的效率。然后包含似有实现部分会带来两个影响：一是既是客户程序员不能轻易地访问私有实现部分，但可以看到它；二是造成一些不必要的重复编译。</p>
<p><strong>5.6.1 隐藏实现</strong></p>
<p>有些项目不可让最终客户程序员看到其实现部分，就有必要把一个变一号的实际结构放在实现文件中，而不是让其暴露在头文件中。</p>
<p><strong>5.6.2 减少重复编译</strong></p>
<p>在我们的编译环境中，当一个文件被修改，或它所依赖的头文件被修改时，项目管理员需要重复编译该文件。这意味着程序员无论何时修改了一个类，无论修改的是公共的接口部分，还是私有成员的声明部分，他都必须再次编译包含头文件的所有文件。这就是通常所说的易碎的基类问题(fragile base-class problem)。对于一个大的项目而言，在开发初期这可能非常难以处理，因为内部实现部分可能需要经常改动。如果这个项目非常大，用于编译的时间过多可能妨碍项目的快速转型。</p>
<p>解决这个问题的技术有时称为句柄类(handle class)或称为“Cheshire cat”。有关实现的任何东西都消失了，只剩一个单指针“smile”。该指针指向一个结构，该结构的定义与其所有的成员函数的定义一同出现在实现文件中。这样，只要接口部分不改变，头文件就不需变动，而实现部分可以按需要任意更改，完成后只需要对实现文件进行重新编译，然后重新连接到项目中。</p>
<h2 id="第6章-初始化与清除"><a href="#第6章-初始化与清除" class="headerlink" title="第6章 初始化与清除"></a>第6章 初始化与清除</h2><p>C++中，初始化和清楚的概念是简化库的使用的关键所在，并可以减少那些在客户程序员忘记去完成这些操作时会引起的细微错误。</p>
<h3 id="6-1-用构造函数确保初始化"><a href="#6-1-用构造函数确保初始化" class="headerlink" title="6.1 用构造函数确保初始化"></a>6.1 用构造函数确保初始化</h3><p>类的设计者可以通过提供一个叫做构造函数(constructor)的特殊函数来保证每个对象都被初始化。如果一个类有构造函数，编译器在创建对象时就自动调用这一函数。构造函数的名字与类的名字一样。这样的函数在初始化时会被自动调用。</p>
<p>构造函数和析构函数是两个非常特殊的函数：它们没有返回值。</p>
<p>在程序中创建和消除一个对象的行为非常特殊，就像出生和死亡，而且总是由编译器来调用这些函数以确保它们被执行。如果它们有返回值，要么编译器必须知道如何处理返回值，要么就只能由客户程序员子集来显式的调用构造函数与析构函数，这样一来，安全性就被破坏了。</p>
<h3 id="6-2-用析构函数确保清除"><a href="#6-2-用析构函数确保清除" class="headerlink" title="6.2 用析构函数确保清除"></a>6.2 用析构函数确保清除</h3><p>在一个库中，对于一个曾经用过的对象，如果不做处理，对象就永远不会消失。在C++中，清除就像初始化一样重要，它通过析构函数来保证清除的执行。</p>
<p>析构函数的语言与构造函数一样，用类的名字作为函数名。然而析构函数前面加上一个代字号(～)，以和构造函数区别。</p>
<p>当对象超出它的作用域时，编译器将自动调用析构函数。</p>
<h3 id="6-3-清除定义块"><a href="#6-3-清除定义块" class="headerlink" title="6.3 清除定义块"></a>6.3 清除定义块</h3><p>在C++中，应该在尽可能靠近变量的使用点处定义变量，并在定义时就初始化。这是出于安全性的考虑，通过减少变量在块中的生命周期，就可以减少该变量在块的其他地方被误用的机会。</p>
<h3 id="6-4-集合初始化"><a href="#6-4-集合初始化" class="headerlink" title="6.4 集合初始化"></a>6.4 集合初始化</h3><p>集合(aggregate)就是多个事物聚集在一起。这个定义包括混合类型的集合。</p>
<h3 id="6-5-默认构造函数"><a href="#6-5-默认构造函数" class="headerlink" title="6.5 默认构造函数"></a>6.5 默认构造函数</h3><p>默认构造函数(default constructor)就是不带任何参数的构造函数。一旦有了一个构造函数，编译器就会确保不关在什么情况下它总是会被调用。</p>
<p>尽管编译器会创建一个默认的构造函数，但是编译器合成的构造函数的行为很少是我们期望的。我们应该把这个特征看成是一个安全网，但尽量少用它。一般说来，应该明确地定义子集的构造函数，而不让编译器来完成。</p>
<h2 id="第7章-函数重载与默认参数"><a href="#第7章-函数重载与默认参数" class="headerlink" title="第7章 函数重载与默认参数"></a>第7章 函数重载与默认参数</h2><p>能使名字方便使用，是任何程序设计语言的一个重要特征。</p>
<p>尽管函数重载对构造函数来说是必须的，但是它仍然是一个通用的方便手段，并可以与任意函数一起使用。另外，函数重载意味着，我们有两个库，它们都有同名的函数，只要它们的参数列表不同就不会发生冲突。</p>
<h3 id="7-1-名字修饰"><a href="#7-1-名字修饰" class="headerlink" title="7.1 名字修饰"></a>7.1 名字修饰</h3><p>可以对不同的函数用同样的名字，只要求函数的参数不同，编译器会修饰这些名字、范围和参数来产生内部名以供它和连接器使用。</p>
<p><strong>7.1.1 用返回值重载</strong></p>
<p>仅仅依靠返回值来重载函数实在过于微妙，所以在 C++ 中禁止这样做。</p>
<p><strong>7.1.2 类型安全连接</strong></p>
<p>对名字修饰还可以带来一个额外的好处。在 C 中，如果用户错误地声明了一个函数，或者更糟糕地，一个函数还没声明就调用了，而编译器则按照函数被调用的方式去推断函数的声明。若这样的推断不正确，那么就会变成一个很难发现的错误。</p>
<p>在 C++ 中，所有的恶函数在被使用前都必须事先声明，因此出现上述情况的机会大大减少了。名字修饰会给我们提供一个安全网，这也就是人们常说的类型安全连接(type-safe linkage)。</p>
<h3 id="7-2-默认参数"><a href="#7-2-默认参数" class="headerlink" title="7.2 默认参数"></a>7.2 默认参数</h3><p>默认参数(default argument)是在函数声明时就已给定的一个值，如果在调用函数时没有指定这一参数的值，编译器就会自动地插上这个值。</p>
<p>在使用默认参数时必须记住两条规则。第一，只有参数列表的后部参数才是可默认的，也就是说，不可以在一个默认参数后面又跟一个非默认的参数。第二，一旦在一个函数调用中开始使用默认参数，那么这个参数后面的所有参数都必须是默认的。</p>
<p>默认参数只能放在函数声明中，通常在一个头文件中。编译器必须在使用该函数之前知道默认值。有时人们为了阅读方便在函数定义处放上你一些默认的注释值。</p>
<h2 id="第8章-常量"><a href="#第8章-常量" class="headerlink" title="第8章 常量"></a>第8章 常量</h2><p>常量概念(由关键字const表示)是为了使程序员能够在变和不变之间画一条界线。这在C++程序设计项目中提供了安全性和可控性。</p>
<h3 id="8-1-指针"><a href="#8-1-指针" class="headerlink" title="8.1 指针"></a>8.1 指针</h3><p>可以使指针成为 const。当处理 const 指针时，编译器仍将努力避免存储分配并进行常量折叠。如果程序员以后想在程序代码中改变 const 这种指针的使用，编译器将给出通知。这大大增加了安全性。</p>
<p>当使用带有指针的 const 时，有两种选择：const 修饰指针正指向的对象，或者 const 修饰在指针里存储的地址。</p>
<p><strong>8.1.1 指向const的指针</strong></p>
<p>定义指针的技巧是在标识符的开始处读它并从里向外读。<code>const</code> 修饰“最靠近”它的那个。如：<code>const int* u;</code> 可以读成：<code>u</code> 是一个指针，它指向一个 <code>const int</code>。</p>
<h3 id="8-2-const-指针"><a href="#8-2-const-指针" class="headerlink" title="8.2 const 指针"></a>8.2 const 指针</h3><p>使指针本身称为一个 const 指针，必须把 cons t标明的部分放在 <code>*</code> 的右边。如：<code>int d = 1; int * const w = &amp;d;</code> 可以读成 <code>w</code> 是一个 <code>const</code> 指针指向一个 <code>int</code>。<br>因为指针本身现在是 <code>const</code>指针，编译器要求给它一个初始值，这个值在指针生命期内不变。然而要改变它所指向的值是可以的：<code>*w = 2;</code></p>
<p>当然也可以把一个const指针指向一个const对象。</p>
<p>如果可能的话，一行只定义一个指针，并尽可能在定义时初始化。</p>
<p><strong>8.1.3 赋值和类型检查</strong></p>
<p>可以把一个非const对象的地址赋给一个const指针，因为也许有时不想改变某些可以改变的东西。然后不能把一个const对象的地址赋给一个非const指针，因为这样做可能通过被赋值的指针改变这个对象的值。</p>
<h3 id="8-3-函数参数和返回值"><a href="#8-3-函数参数和返回值" class="headerlink" title="8.3 函数参数和返回值"></a>8.3 函数参数和返回值</h3><p><strong>8.3.1 传递 const 值</strong></p>
<p>如果函数是按值传递，则可用指定参数是 const 的。这里参数不能被改变。所以它其实是函数创建者的工具，而不是函数调用者的工具。</p>
<p>为了不使调用者很小，在函数内部用 const 限定参数优于在参数表里用 const 限定参数。可以用一个指针来实现，但更好的语法形式是“引用”。简而言之，引用相一个被自动间接引用的常量指针，它的作用是成为对象的别名。为建立一个引用，在定义里使用 <code>&amp;</code>。</p>
<p><strong>8.3.2 返回 const 值</strong></p>
<p>如果一个函数的返回值是一个常量(const)，这就约定了函数框架里的原变量不会被修改。另外，因为这是按值返回的，所以这个变量被制成副本，舍得初值不会被返回值所修改。</p>
<p>对于内部类型来说，按值返回的是否是一个 const，是无关紧要的，所以按值返回一个内部类型时，应该去掉 const，从而不使客户程序员混淆。</p>
<p>当处理用户定义的类型时，按值返回常量是很重要的。如果一个函数按值返回一个类对象为 const时，那么这个函数的返回值不能是一个左值(不能被赋值或修改)。</p>
<p><strong>8.3.3 传递和返回地址</strong></p>
<p>如果传递或返回一个地址(一个指针或一个引用)，客户程序员去取地址并修改其初值是可能的。如果使这个指针或者引用成为 const，就会阻止这类事的发生，这是非常重要的事情，事实上，无论什么时候传递一个地址给一个函数，都应该尽可能用 const 修饰它。如果不这样做，就不能以 const 指针参数的方式使用这个函数。</p>
<h3 id="8-4-类"><a href="#8-4-类" class="headerlink" title="8.4 类"></a>8.4 类</h3><p><strong>8.4.1 类里的 const</strong></p>
<p>常数表达式使用常量的地方之一是在类里。典型的例子是在一个类里建立一个数组，并用 <code>const</code> 代替 <code>#define</code> 设置数组大小。数组大小一直隐藏在类里，这样，如果用 size 表示数组大小，就可以把 size 这个名字用在另一个类里而不发生冲突。</p>
<p>读者可能认为合乎逻辑的选择是把一个 const 放在类里。但这样不会产生预期的效果。在一个类里，const 又部分恢复到它在C语言中的含义。它在每个类对象里分配存储并代表一个值，这个值一旦被初始化以后就不能改变。在一个类里使用 const 意味着“在这个对象生命期内，它是一个常量”。然而，对这个常量来讲，每个不同的对象可以含有一个不同的值。</p>
<p>这样，在一个类里建立一个普通的(非static的)const时，不能给它初值。这个初始化工作比须在构造函数里进行，当然，要在构造函数的某个特别的地方进行。因为 const 必须在建立它的地方被初始化，所以在构造函数的主体里，const 必定已被初始化了。否则，就只有等待，直到在构造函数主体以后的某个地方给它初始化，这意味着过一会儿才给 const 初始化。当然，无法防止在构造函数主体的不同地方改变 const 的值。</p>
<p><strong>构造函数初始化列表</strong></p>
<p>在构造函数里有个专门初始化的地方，这就是构造函数初始化列表(constructor initializer list)，起初用在机成立。构造函数初始化列表是一个出现在函数参数表和冒号后，但在构造函数主体开头的花括号前的“函数调用列表”。这提醒人们，表里的初始化发生在构造函数的任何代码执行之前。这是初始化所有 <code>const</code> 的地方，若 <code>size</code> 是 <code>Fred</code> 类的一个 <code>const</code> 成员的话，其正确形式是：<code>Fred::Fred(int sz) : size(sz){}</code></p>
<p>把一个内部类型风装载一个类里以保证用构造函数初始化，这是很有用的。</p>
<p><strong>8.4.2 编译期间类里的常量</strong></p>
<p>若要让类有编译期间的常量成员，就要求使用另外一个关键字 <code>static</code>。在这种情况下，关键字<code>static</code> 意味着“不管类的对象被创建多少次，都只有一个实例”。因此，一个内部类型的 <code>static const</code> 可以看作一个编译期间的常量。</p>
<p>必须在 <code>static const</code> 定义的地方对它进行初始化。</p>
<p><strong>8.4.3 const对象和成员函数</strong></p>
<p>如果声明一个成员函数为 <code>const</code> (修饰符 <code>const</code> 放在函数参数表的后面)，则等于告诉编译器该成员函数可以为一个 <code>const</code> 对象所调用。一个没有被明确声明为 <code>const</code> 的成员函数被堪称是将要修改数据成员的函数，而且编译器不允许它为一个 <code>const</code> 对象所调用。</p>
<p>关键字 <code>const</code> 必须同样的方式重复出现在定义里，否则编译器把它看成一个不同的函数！</p>
<p>一个 <code>const</code> 成员函数调用 <code>const</code> 和非 <code>const</code> 对象是安全的，因此，可以把它看做成员函数的最一般形式。不修改数据成员的任何函数都应该把它们声明为 <code>const</code>，这样它可以和 <code>const</code> 对象一起使用。</p>
<h3 id="8-5-volatile"><a href="#8-5-volatile" class="headerlink" title="8.5 volatile"></a>8.5 volatile</h3><p><code>volatile</code> 的语法与 const 是一样的，但是 volatile 的意思是“在编译器认识的范围外，这个数据可以被改变”。不知何故，环境正在改变数据(可能通过多任务、多线程或者中断处理)，所以，<code>volatile</code> 告诉编译器不要擅自作出有关该数据的任何假定，优化期间尤其如此。</p>
<h2 id="第9章-内联函数"><a href="#第9章-内联函数" class="headerlink" title="第9章 内联函数"></a>第9章 内联函数</h2><p>C++ 从 C 中集成的一个重要特征是效率。加入 C++ 的效率显著地低于 C 的效率，那么就会有很大一批程序员不去使用它。</p>
<p>为了既保持预处理器宏的效率又增加安全性、而且还能像一般成员函数一样可以在类里访问自如，C++ 引入了内联函数(inline function)</p>
<h3 id="9-1-预处理器的缺陷"><a href="#9-1-预处理器的缺陷" class="headerlink" title="9.1 预处理器的缺陷"></a>9.1 预处理器的缺陷</h3><p>预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器的行为一样。</p>
<h3 id="9-2-内联函数"><a href="#9-2-内联函数" class="headerlink" title="9.2 内联函数"></a>9.2 内联函数</h3><p>在解决 C++ 中宏访问 <code>private</code> 类成员的问题过程中，所有和预处理器宏有关的问题也随之排除了。这是通过使宏被编译器控制来实现的。在 C++ 中，宏的概念是作为内联函数(inline function)来实现的，而内联函数无论从哪一方面上说都是真正的函数。</p>
<p>任何在类中定义的函数自动成为内联函数，但也可以在非类的函数前面加上inline关键字使之称为内联函数。但为了使之有效，必须使函数体和声明结合在一起，否则，编译器将它作为普通函数对待。</p>
<p>一般应该把内联定义放在头文件里。当编译器看到这个定义时，它把函数类型(函数名+返回值)和函数体放到符号表里。当使用函数时，编译器检查以确保调用是正确的且返回值被正确使用，然后将函数调用替换为函数体，因而消除了开销。内联代码的确占用空间，但假如函数较小，这实际上比为了一个普通函数调用而产生的代码(参数压栈和执行CALL)占用的空间还小。</p>
<p><strong>9.2.1 类内部的内联函数</strong></p>
<p>类内部的内联函数节省了在外部定义成员函数的额外步骤，所以我们一定想在类声明内每一处都使用内联函数。但应记住，使用内联函数的目的是减少函数调用的开销。但是，假如函数较大，由于需要在调用函数的每一处重复复制代码，这样将使代码膨胀，在速度方面获得的好处就会减少。</p>
<p><strong>9.2.2 访问函数</strong></p>
<p>在类中内联函数的最重要的使用之一是用做访问函数(access function)。这是一个小函数，它容许读或修改对象状态──即一个或几个内部变量。即最通常所说的set与get方法(修改器和访问器)。</p>
<h3 id="9-3-内联函数和编译器"><a href="#9-3-内联函数和编译器" class="headerlink" title="9.3 内联函数和编译器"></a>9.3 内联函数和编译器</h3><p>对于函数，编译器在它的符号表里放入函数类型(即包括名字和参数类型的函数原型及函数的返回类型)。另外，当编译器看到内联函数和对内联函数体的分析没有发现错误时，就将对应于函数体的代码也放入符号表。代码是以源程序形式存放还是以编译过的汇编指令形式存放取决于编译器。</p>
<p>当调用一个内联函数时，编译器首先确保调用正确，即所有的参数类型必须满足：要么与函数参数表中的参数类型一样，要么编译器能够将其转换为正确类型，并且返回值在目标表达式里应该是正确类型或可改变为正确类型。</p>
<p><strong>9.3.1 限制</strong></p>
<p>有两种编译器不能执行内联的情况。在这些情况下，它就像对非内联函数一样，根据内联函数定义和为函数建立存储空间，简单地将其转换为函数的普通形式。</p>
<p>加入函数太复杂，编译器将不能执行内联。这取决于特定的编译器，但对大多数编译器这时都回放弃内联方式，因为这时内联可能不能提高任何效率。一般地，任何种类的循环都被认为太复杂。</p>
<p>内联仅是编译器的一个建议，编译器不会被强迫内联任何代码。一个好的编译器将会内联小的、简单的函数，同时明智地忽略那些太复杂的内联。这将给我们想要的结果──具有宏效率的函数调用的真正语义学。</p>
<p><strong>9.3.2 向前引用</strong></p>
<p>当一个内联函数在类中向前引用一个还没有声明的函数时，是可以正常工作的，因为C++语言规定：只有在类声明结束后，其中的内联函数才会被计算。</p>
<h2 id="第10章-名字控制"><a href="#第10章-名字控制" class="headerlink" title="第10章 名字控制"></a>第10章 名字控制</h2><p>创建名字是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量的名字。</p>
<p>关于 <code>static</code> 的所有使用最基本的概念是指“位置不变的某个东西”，不管这里是指在内存中的物理位置还是指在文件中的可见性。</p>
<h3 id="10-1-来自-C-语言中的静态元素"><a href="#10-1-来自-C-语言中的静态元素" class="headerlink" title="10.1 来自 C 语言中的静态元素"></a>10.1 来自 C 语言中的静态元素</h3><p>在 C 和 C++ 中，static 都有两种基本的含义，并且这两种含义经常是相互冲突的：</p>
<ul>
<li>在固定的地址上进行存储分配，也就是说对象是在一个特殊的静态数据区(static data area)上创建的，而不是每次函数调用时在堆栈上产生的。这也是静态存储的概念。</li>
<li>对一个特定的编译单位来说是局部的。这样，<code>static</code> 控制名字的可见性(visibility)，所以这个名字在这个单元或类外是不可见的。这也描述了连接的概念，它决定连接器将看到哪些名字。</li>
</ul>
<p><strong>10.1.1 函数内部的静态变量</strong></p>
<p>通常，在函数体内定义一个局部变量时，编译器在每次函数调用时使堆栈的指针下移到一个适当的位置，为这些局部变量非配内存。如果这个变量又一个初始化表达式，那么每当程序运行到此处，初始化就被执行。</p>
<p>然而，有时想在两次函数调用之间保留一个变量的值，可以通过定义一个全局变量来实现，但这样一来，这个变量就不仅仅只受到这个函数的控制。C和C++都允许在函数内部定义一个static对象，这个对象将存储在静态数据区中，而不是在堆栈中。这个对象只在第一次调用是初始化一次，以后它将在两次函数调用之间保持它的值。</p>
<p><strong>10.1.2 控制连接</strong></p>
<p>一般情况下，在文件作用域(file scope)内的所有名字(即不嵌套在类或函数中的名字)对程序中的所有翻译单元来说都是可见的。这就是所谓的外部连接(external linkage)，因为在连接时这个名字对连接器来说是可见的，对单独的翻译单元来说，它是外部的。全局变量和普通函数都有外部连接。</p>
<p>在文件作用域内，一个被明确声明为 <code>static</code> 的对象或函数的名字对翻译单元来说是局部于该单元的。这些名字有内部连接(internal linkage)。</p>
<p>内部连接的一个好处是这个名字可以放在一个头文件中。</p>
<h2 id="第11章-引用和拷贝构造函数"><a href="#第11章-引用和拷贝构造函数" class="headerlink" title="第11章 引用和拷贝构造函数"></a>第11章 引用和拷贝构造函数</h2><h3 id="11-1-C-中的指针"><a href="#11-1-C-中的指针" class="headerlink" title="11.1 C++ 中的指针"></a>11.1 C++ 中的指针</h3><p>C 不允许随便地把一个类型的指针赋给另一个类型，但允许通过 <code>void*</code> 来实现。由于 C 的这种功能允许把任何一种类型看做别的类型处理，这就在类型系统中流下了一个大的漏洞。C++ 不允许这样做，如果真想把某种类型当作别的类型处理，则必须显示地使用类型转换。</p>
<h3 id="11-2-C-中的引用"><a href="#11-2-C-中的引用" class="headerlink" title="11.2 C++ 中的引用"></a>11.2 C++ 中的引用</h3><p>引用(reference)(&amp;)就像能自动地被编译器间接引用的常量型指针。它常用于函数的参数表中和函数的返回值，但也可以独立使用。</p>
<p>使用引用时有一定的规则：</p>
<ul>
<li>当引用被创建时，它必须被初始化(指针则可以在任何时候被初始化)。</li>
<li>一旦一个引用被初始化为指向一个对象，它就不能改变为另一个对象的引用(指针则可以在任何时候指向另一个对象)。</li>
<li>不可能有NULL引用。必须确保引用是和一块合法的存储单元关联。</li>
</ul>
<p><strong>11.2.1 函数中的引用</strong></p>
<p>最经常看见引用的地方是在函数参数和返回值中。当引用被用做函数参数时，在函数内任何对引用的更改将对函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。</p>
<p>如果从函数中返回一个引用，必须像从函数中返回一个指针来一样对待。当函数返回时，无论引用关连的是什么都应该存在，否则，将不知道指向哪一个内存。</p>
<p>若想要改变指针本身而不是它所指向的内容，函数参数变成指针的引用，用不着取得指针的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>*&amp; i)</span></span>&#123;i++&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> *i = <span class="number">0</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	increment(i);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>1.2.2 参数传递准则</strong></p>
<p>当给函数传递参数时，人们习惯上是通过常量引用来传递。这种简单习惯可以大大提高效率：传值方式需要调用构造函数和析构函数，然而，如果不想改变参数，则可以通过常量引用传递，它仅需要将地址压栈。</p>
<h3 id="11-3-拷贝构造函数"><a href="#11-3-拷贝构造函数" class="headerlink" title="11.3 拷贝构造函数"></a>11.3 拷贝构造函数</h3><p>这是一个更令人混淆的概念，常被称为X(X&amp;)(“X引用的X”)，在函数调用时，这个构造函数是控制通过传值方式传递和返回用户定义类型的根本所在。这是很重要的。</p>
<p><strong>11.3.1 按值传递和返回</strong></p>
<p>在 C 和 C++ 中，参数是从右向左进栈的，然后调用函数，调用代码负责清理栈中的参数。但是要注意，通过按值传递方式传递参数时，编译器简单地将参数拷贝压栈──编译器知道拷贝有多大，并知道如何对参数压栈，对它们正确拷贝。</p>
<h2 id="第13章-动态对象创建"><a href="#第13章-动态对象创建" class="headerlink" title="第13章 动态对象创建"></a>第13章 动态对象创建</h2><p>有时我们能知道程序中对象的确切数量、类型和生命期。但情况不总是这样。为了解决这个普遍的编程问题，在运行时可以创建和销毁对象是最基本的要求。C 提供了动态内存分配(dynamic memory allocation)函数 <code>malloc()</code> 和 <code>free()</code>，这些函数在运行时从堆(也称自由内存)中分配存储单元。</p>
<p>然而，在C++中这些函数将不能很好的运行。因为构造函数不允许我们向它传递内存地址来进行初始化。</p>
<p>C++ 是如何保证正确的初始化和清理，有允许我们在堆上动态创建对象呢？</p>
<p>答案是，使动态对象称为语言的核心。<code>malloc</code> 和 <code>free</code> 是库函数，因此不在编译器控制范围之内。然而，如果我们有一个完成动态内存分配及初始化组合动作的运算符和另一个完成清理及释放内存组合动作的运算符，编译器仍可以保证所有对象的构造函数和析构函数会被调用。</p>
<h3 id="13-1-对象创建"><a href="#13-1-对象创建" class="headerlink" title="13.1 对象创建"></a>13.1 对象创建</h3><p>当创建一个C++对象，会发生两件事：</p>
<ul>
<li>为对象分配内存。</li>
<li>调用构造函数来初始化那个内存。</li>
</ul>
<p>到目前为止，因该确保步骤2一定发生。C++强迫这样做是因为未初始化的对象是程序出错的主要原因。对象在那里和如何创建无关紧要──构造函数总是需要被调用。</p>
<p>然而，步骤1可以用几种方式或在可选择的时间发生：</p>
<ol>
<li>在静态存储区域，存储空间在程序开始之前就可以分配。这个存储空间在整个程序运行期间都存在。</li>
<li>无论何时到达一个特殊的执行点(左大括号)时，存储单元都可以在栈上被创建。除了执行点(右大括号)，这个存储单元自动被释放。这些栈分配运算内置于处理器的指令集中，非常有效。然而，在写程序时，必须知道需要多少个存储单元，以便编译器生成正确的指令。</li>
<li>存储单元也可以从一块称为堆(也被称为自由存储单元)的地方分配。这被称为动态内存分配。在运行时调用程序分配这些内存。这意味着可以在任何时候决定分配内存及分配多少内存。当然也需负责决定何时释放内存。这块内存的生存期由我们选择决定──而不受范围决定。</li>
</ol>
<p><strong>13.1.1 C 从堆中获取存储单元的方法</strong></p>
<p>为了在运行时动态分配内存，如 <code>malloc()</code> 和 <code>free()</code>。这些函数是有效的但较原始的，需要编程人员理解和小心使用。例如，必须对分配的空间进行显式地类型转换，还需要自行调用初始化的函数(构造函数并不能被显式地调用)。这很容易出错。所以，C 程序设计者常常在静态内存区域使用虚拟内存机制分配很大的变量数组以避免使用动态内存分配。为了在 C++ 中使得一般的程序员可以安全使用库函数而不费力，所以 C 的动态内存方法是不可接受的。</p>
<p><strong>13.1.2 operator new</strong></p>
<p>C++ 中的解决方案是把船舰一个对象所需的所有动作都结合在一个称为 new 的运算符里。当用new(new的表达式)创建一个对象时，它就在堆里为对象分配内存并为这块内存调用构造函数。等价于调用 <code>malloc()</code> 函数并调用构造函数。返回一个指向该对象的this指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType *fp = <span class="keyword">new</span> MyType;</div></pre></td></tr></table></figure>
<p>默认的 new 还进行检查以确信在传递地址给构造函数之前内存分配是成功的，所以不必显式地确定调用是否成功。</p>
<p>我们可以看到，在堆里创建对象的过程变得简单了──只是一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。这样在堆里创建一个对象何在栈里创建一个对象一样容易。</p>
<p><strong>13.1.3 operator delete</strong></p>
<p>delete 表达式首先调用析构函数，然后释放内存(常调用free())。正如 new 表达式返回一个指向对象的指针一样，delete 表达式需要一个对象的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">delete</span> fp；</div></pre></td></tr></table></figure>
<p><code>delete</code> 只用于删除由 <code>new</code> 创建的对象。</p>
<p><strong>13.1.4 内存管理的开销</strong></p>
<p>当在堆栈里自动创建对象时，对象的大小和它们的生存期被准确地内置在生成的代码里，这是因为编译器知道确切的类型、数量和范围。而在堆里创建的对象还包括另外的时间和空间的开销。以下是一个典型情况：</p>
<p>调用 <code>malloc()</code>，即从堆里搜索一块足够大的内存来满足请求，可以通过检查按某种方式排列的映射或目录来实现，这样的映射或目录用以显示内存的使用情况。这个过程很快但可能要试探几次，所以它可能是不确定的──即每次运行 <code>malloc()</code>并不是花费了相同的时间。</p>
<h3 id="13-2-用于数组的-new-和-delete"><a href="#13-2-用于数组的-new-和-delete" class="headerlink" title="13.2 用于数组的 new 和 delete"></a>13.2 用于数组的 new 和 delete</h3><p>在栈或堆上创建一个对象数组是同样容易的。但这里有一个限制条件：由于不带参数的构造函数必须被每一个对象调用，所以除了在栈上整体初始化外还必须有一个默认的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType *fp = <span class="keyword">new</span> MyType[<span class="number">100</span>];</div><div class="line">MyType *fp2 = <span class="keyword">new</span> MyType;</div></pre></td></tr></table></figure>
<p>我们知道其实fp和fp2是数组的起始地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">delete</span> fp2; <span class="comment">// OK</span></div><div class="line"><span class="keyword">delete</span> fp; <span class="comment">// Not the desired effect</span></div></pre></td></tr></table></figure>
<p>对于 fp 来说，另外 99 个析构函数没有调用，正确应该这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">delete</span> []fp；</div></pre></td></tr></table></figure>
<p>空的方括号告诉编译器产生代码，该代码的任务是将从数组创建时存放在某处的对象数量取回，并为数组的所有对象调用析构函数。</p>
<p><strong>13.2.1 使指针更像数组</strong></p>
<p>上面定义的 fp 可以被修改指向任何类型，但这对于一个数组的起始地址来说没有什么意义。一般来讲，把它定义为常量会更好些，因为这样任何修改指针的企图都会被认为出错。</p>
<p>使得指针指向的int不能修改(指针可以修改)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="keyword">const</span>* q = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];   or</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>* q = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div></pre></td></tr></table></figure>
<p>使得指针不能被修改(数组可以修改)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> q = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div></pre></td></tr></table></figure>
<h3 id="13-3-耗尽内存"><a href="#13-3-耗尽内存" class="headerlink" title="13.3 耗尽内存"></a>13.3 耗尽内存</h3><p>当 <code>operator new()</code> 找不到组够大的连续内存块来安排对象时，一个称为 new-handler 的特殊函数将会被调用。首先，检查指向函数的指针，如果指针非 0，那么它指向的函数将被调用。<br> new-handler 的默认动作是产生一个异常(throw an exception)。</p>
<h2 id="第14章-继承和组合"><a href="#第14章-继承和组合" class="headerlink" title="第14章 继承和组合"></a>第14章 继承和组合</h2><p>C++ 中最重要的特征之一是代码重用。但是如果希望更进一步，就不能仅仅用拷贝代码和修改代码的方法，而是要做更多的工作。</p>
<p>关键技巧是使用这些类，但不修改已存在的代码。第一种方法很直接：我们简单地在心类中创建已存在类的对象。因为新类是由已存在的类的对象组合而成，所以这种方法称为组合(composition)。</p>
<p>第二种方法要复杂些。我们创建一个新类作为一个已存在类的类型。我们不修改已存在的类，而是采取这个已存在类的形式，并将代码加入其中。这种巧妙方法称为继承(inheritance)，其中大量的工作是由编译器完成。继承是面向对象程序设计的基石。</p>
<p>在语法上和行为上，组合和继承大部分是相似的。</p>
<h3 id="14-1-组合语法"><a href="#14-1-组合语法" class="headerlink" title="14.1 组合语法"></a>14.1 组合语法</h3><p>直接把子对象放入新对象的组成中即可。</p>
<p>访问嵌入对象(称为子对象)的成员的成员函数只需再一次的成员选择。更常见的是把嵌入的对象设为私有，因此它们将称为内部实现的一部分(这意味着如果我们原因，可以改变这个实现)。新类的公有接口函数包括了对嵌入对象的使用，但没有必要模仿这个对象的接口。</p>
<h3 id="14-2-继承语法"><a href="#14-2-继承语法" class="headerlink" title="14.2 继承语法"></a>14.2 继承语法</h3><p>当继承时，我们会发现“这个新类很像原来的类”。我们规定，在代码中和原来一样给出该类的名字，但在类的左括号的前面，加一个冒号和基类的名字(对于多重继承，要给出多个基类名，它们之间用逗号分开)。当昨晚这些时，将会自动地得到基类中的所用数据成员和成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Y：<span class="keyword">public</span> X&#123;<span class="comment">//......&#125;</span></div></pre></td></tr></table></figure>
<p>我们可以看到 <code>Y</code> 对 <code>X</code> 进行了继承，这意味着Y将包含X中的所有数据成员和成员函数。所有X中的私有成员在Y中仍然是私有的，因为Y对X进行了继承并不意味着Y可以不遵守保护机制。</p>
<p>这里基类前面是 <code>public</code>。由于在继承时，基类中所有的成员都是被预设为私有的，所以如果基类的前面没有 <code>public</code>，这意味着基类的所有公有成员将在派生类中变为私有的。这显然不是所希望的，我们希望基类中的所有公有成员在派生类中仍是公有的，这可以在继承时通过使用关键字 <code>public</code> 来实现。</p>
<p>倘若 <code>X</code> 和 <code>Y</code> 类中均有一个 <code>set()</code> 函数，那么将会使用 <code>Y</code> 中重新定义的版本。这也就是说，如果不想使用某个继承而来的函数，我们可以改变它的内容。然而，当我们重新定义了一个函数之后，仍可能想调用基类的函数，为了调用基类 <code>X</code> 的 <code>set()</code> 函数，必须使用作用域运算符来显示地表明基类名。</p>
<h3 id="14-3-构造函数的初始化列表"><a href="#14-3-构造函数的初始化列表" class="headerlink" title="14.3 构造函数的初始化列表"></a>14.3 构造函数的初始化列表</h3><p>在 C++ 中保证正确的初始化是多么重要，这一点在组合和继承中也是一样。当创建一个对象时，编译器确保调用了所有子对象的构造函数。</p>
<p>但是，如果子对象没有默认构造函数或如果想改变构造函数的某个默认参数，就会出现问题，因为这个新类的构造函数没有权利访问这个子对象的私有数据成员，所以不能直接对它们初始化。</p>
<p>解决的方法很简单：对于子函数调用构造函数，C++ 为此提供了专门的语法，即构造函数的初始化表达式表。构造函数的初始化表达式的形式模仿继承活动。</p>
<p>对于继承，我们把基类至于冒号和这个类体的左括号之间。而在构造函数的初始化表达式中，可以将对子对象构造函数的调用语句放在构造函数参数表和冒号之后，在函数体的左括号之前。对于从 <code>Bar</code> 继承来的类 <code>MyType</code>，如果 <code>Bar</code> 的构造函数只有一个 <code>int</code> 型参数，则可以表示为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType::MyType(<span class="keyword">int</span> i) : Bar(i) &#123; <span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p><strong>14.3.1 成员对象初始化</strong></p>
<p>对于组合，也可以对成员对象使用同样语法，只是所给出的不是类名，而是对象的名字。如果在初始化表达式表中有多个构造函数的调用，应当用逗号加以隔开：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType2::MyType(<span class="keyword">int</span> i) : Bar(i), m(i+<span class="number">1</span>) &#123; <span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>这是类 <code>MyType2</code> 构造函数的开头，该类是从 <code>Bar</code> 继承来的，并且包含一个称为m的成员对象。请注意，虽然可以在这个构造函数的初始化表达式表中看到基类的类型，但只能看到成员对象的标识符。</p>
<p><strong>14.3.2 在初始化表达式中的内部类型</strong></p>
<p>构造函数的初始化表达式表允许我们显式地调用成员对象的构造函数。它的主要思想是，在进入新类的构造函数体之前调用所有其他的构造函数。这样，对于子对象的成员函数所做的任何调用都总是转到了这个被初始化的对象中。即使编译器可以隐藏地调用默认的构造函数，但在没有对所有的成员对象和基类对象的构造函数进行调用之前，就没有办法进入该构造函数体。这是 C++ 的一个强化的机制，它确保了，如果没有调用对象的构造函数，就别想向下进行。</p>
<p>对于哪些没有构造函数的内部类型嵌入对象，这一切会怎么样？</p>
<p>为了使语法一致，可以把内部类型看做这样一种类型，它只有一个取单个参数的构造函数，而这个参数与正在初始化的变量类型相同。于是可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">float</span> f;</div><div class="line">	<span class="keyword">char</span> c;</div><div class="line">	<span class="keyword">char</span>* s;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	X() : i(<span class="number">7</span>), f(<span class="number">1.4</span>), c(‘x’), s(“howdy”) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些“伪构造函数调用”操作可以进行简单的赋值。这种方法很方便，并且具有良好的编码风格。甚至在类之外创建内部类型的变量是，也可以使用伪构造函数语法。</p>
<p>这使得内部类型的操作有点类似于对象，但是这些并不是真正的构造函数。特别地，如果没有显式的进行伪构造函数调用，初始化是不会执行的。</p>
<h3 id="14-4-组合和继承的联合"><a href="#14-4-组合和继承的联合" class="headerlink" title="14.4 组合和继承的联合"></a>14.4 组合和继承的联合</h3><p>还可以把组合和继承放在一起使用。</p>
<p><strong>自动析构函数调用</strong></p>
<p>虽然常常需要在初始化表达式表中显式构造函数调用，但并不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且它并不取任何参数。然而，编译器仍要保证所有的析构函数被调用，这意味着，在整个层次中的所有析构函数中，从派生类最底层的析构函数开始调用，一直到根层。</p>
<p><strong>14.4.1 构造函数和析构函数调用的次序</strong></p>
<p>构造是从类层次的最根处开始，而在每一层，首先会调用基类构造函数，然后调用成员对象构造函数。调用析构函数则严格按照构造函数相反的次序──这是很重要的，因为要考虑潜在的相关性(对于派生类中的构造函数和析构函数，必须假设基类子对象仍然可供使用并且已经被构造了──或者还未被消除)。</p>
<p>另一个有趣现象是，对于成员对象，构造函数调用的次序完全不受构造函数的初始化表达式表中的次序影响。该次序是由成员对象在类中声明的次序所决定的。</p>
<h3 id="14-5-名字隐藏"><a href="#14-5-名字隐藏" class="headerlink" title="14.5 名字隐藏"></a>14.5 名字隐藏</h3><p>如果继承一个类并且对它的成员函数重新进行定义，可能会出现两种情况：</p>
<p>第一种是正如在基类中所进行的定义一样，在派生类的定义中明确地定义操作和返回类型。这称之为对普通成员函数的重定义(redefining)，而如果基类的成员函数是虚函数的情况，又可称之为重写(overriding)。</p>
<p>任何时候重新定义了基类中的一个重载函数，在新类之中所有其他版本则被自动地隐藏了。</p>
<p>如果通过修改基类中一个成员函数的操作与/或返回类型来改变了基类的接口，我们就没有使用继承通常所提供的功能，而是按另一种方式来重用了该类。这并不一定意味着做错了，只是由于继承的最终目标是为了实现多态性(polymorphism)。</p>
<h3 id="14-6-非自动继承的函数"><a href="#14-6-非自动继承的函数" class="headerlink" title="14.6 非自动继承的函数"></a>14.6 非自动继承的函数</h3><p>不是所有的函数都能自动地从基类继承到派生类中的。构造函数和析构函数用来处理对象的创建和析构操作，但它们只知道对它们的特定层次上的的对象做些什么。所以，在该类以下各个层次中的所有构造函数和析构函数都必须被调用，也就是说，构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。</p>
<p>另外，<code>operator=</code> 也不能被继承，因为它完成类似于构造函数的活动。</p>
<p><strong>14.6.1 继承和静态成员函数</strong></p>
<p>静态(static)成员函数与非静态成员函数的共同点：</p>
<ul>
<li>它们均可被继承到派生类中。</li>
<li>如果我们重新定义了一个静态成员，所有在基类中的其他重载函数会被隐藏。</li>
<li>如果我们改变了基类中一个函数的特征，所有使用该函数名字的基类版本都将会被隐藏。然而，静态(static)成员函数不可以是虚函数(virtual)。</li>
</ul>
<h3 id="14-7-组合与继承的选择"><a href="#14-7-组合与继承的选择" class="headerlink" title="14.7 组合与继承的选择"></a>14.7 组合与继承的选择</h3><p>组合通常是在希望新类内部具有已存在类的功能时使用，而不是希望已存在类作为它的接口。这就是说，嵌入一个对象用以实现新类的功能，而新类的用户看到的是新定义的接口而不是来自老类的接口。为此，在新类的内部嵌入已存在的 <code>private</code> 对象。</p>
<p>有时，又希望允许类用户直接访问新类的组成，这就让成员对象是 <code>public</code>。由于成员对象使用自己的访问控制，所以是安全的，而当用户了结了我们所做的组装工作时，会更容易理解接口。</p>
<p>is-a 关系用继承表达，has-a 关系用组合表达。</p>
<p><strong>14.7.1 子类型设置</strong></p>
<p>如果由一个已存在的类创建一个新类，并且希望这个类的每件东西都进来，就称为子类型化(subtyping)。这个新类与已存在的类有着严格相同的接口(希望增加任何我们想要加入的其他成员函数)，所以能在已经用过这个已存在的类的任何地方使用这个新类，这就是必须使用继承的地方。</p>
<p><strong>14.7.2 私有继承</strong></p>
<p>通过在基类表中去掉 <code>public</code> 或通过显式地声明 <code>private</code>，可以私有地继承基类。当私有继承时，我们是“照此实现”；也就是说，创建的新类具有基类的所有数据和功能，但这些功能是隐藏的，所以它只是部分的内部实现。该类的用户访问不到这些内部功能，并且一个对象不能被看做是这个基类的实例。</p>
<p>为了完整性，<code>private</code> 继承被包含在该语言中。但是通常希望使用组合而不是 <code>private</code> 继承。</p>
<p><strong>14.7.2.1 对私有继承成员公有化</strong></p>
<p>私有继承时，基类的所有 <code>public</code> 成员都变成了 <code>private。如果希望其中的任何一个是可视的，只要用派生类的</code>public` 部分声明它们的名字即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">using</span> Pet::eat;</div></pre></td></tr></table></figure>
<p>其中 <code>Pet</code> 是私有继承的类，这样就可以使用 <code>Pet</code> 类中的 <code>eat</code> 成员函数。</p>
<p>这样，如果想要隐藏基类的部分功能，则 <code>private</code> 继承是有用的。注意给出一个重载函数的名字将使基类中的所有它的重载版本公有化。</p>
<p>在使用 <code>private</code> 继承取代组合之前，应当仔细考虑，当与运行时类型标识相连时，私有继承特别复杂。</p>
<h3 id="14-8-protected"><a href="#14-8-protected" class="headerlink" title="14.8 protected"></a>14.8 protected</h3><p>实际项目中，有时希望某些东西隐藏起来，但仍允许其派生类的成员访问，此时可用 <code>protected</code>。它的意思是：“就这个类的用户而言，它是 <code>private</code> 的，但它可被从这个类继承来的任何类使用”。</p>
<p>最好让数据成员是 <code>private</code>，因为我们应该保留改变内部实现的权利。然后才能通过 <code>protected</code> 成员函数控制对该类的继承者的访问。</p>
<p><strong>14.8.1 protected</strong></p>
<p>保护继承的派生类意味着对其他类来说是“照此实现”，但它是对于派生类和友元是“is-a”。它是不常用的，它的存在只是为了语言的完备性。</p>
<h3 id="14-9-运算符的重载与继承"><a href="#14-9-运算符的重载与继承" class="headerlink" title="14.9 运算符的重载与继承"></a>14.9 运算符的重载与继承</h3><p>除了赋值运算符以外，其余的运算符可以自动地继承到派生类中。</p>
<h3 id="14-10-多重继承"><a href="#14-10-多重继承" class="headerlink" title="14.10 多重继承"></a>14.10 多重继承</h3><p>直到我们已经很好地学会程序设计并完全理解这个语言时，我们才能试着去用多重继承。不管我们如何认为我们必须用多重继承，我们总是能通过单继承完成。</p>
<p>多重继承引起很多含糊的可能性。</p>
<h3 id="14-11-渐增式开发"><a href="#14-11-渐增式开发" class="headerlink" title="14.11 渐增式开发"></a>14.11 渐增式开发</h3><p>继承和组合的优点之一是它支持渐增式开发(incremental development)，它允许在已存在的代码中引进代码，而不会给原来的代码带来错误。</p>
<p>认识到程序开发就像人的学习过程一样，是一个渐增的过程，这是很重要的。我们能做尽可能多的分析，但当开始一个项目时，我们仍不可能知道所有的答案。</p>
<p>记住，继承首先是表示一种关系，即“新类属于老类的类型(a type of)”。我们的程序不应当关心怎样怎样摆布位，而应当关心如何创建和处理各类型的对象，以便用问题空间的术语表示模型。</p>
<h3 id="14-12-向上类型转换"><a href="#14-12-向上类型转换" class="headerlink" title="14.12 向上类型转换"></a>14.12 向上类型转换</h3><p>继承最重要的方面不是它为新类提供了成员函数，而是它是基类与新类之间的关系，这种关系可被描述为：“新类属于原有类的类型”。</p>
<p>这个描述不仅仅是一种想象的解释继承的方法──它直接由编译器支持。将新类的引用或指针转变成基类的引用或指针的活动被称为向上类型转换(upcasting)。</p>
<p><strong>14.12.1 为什么要“向上类型转换”</strong></p>
<p>这个术语的引入是有其历史原因的，而且它也与类继承图的传统画法有关：在顶部是根，向下生长。</p>
<p>向上类型转换总是安全的。因为是从更专门的类型到更一般的类型──对于这个类接口可能出现的唯一事情是它失去成员函数，而不是获得它们。这就是编译器允许向上类型转换而不需要显式地说明或做其他标记的原因。</p>
<p><strong>14.12.2 向上类型转换和拷贝构造函数</strong></p>
<p>必须记住无论何时我们在创建了子集的拷贝构造函数时，都要正确地调用基类拷贝构造函数(正如编译器所作的)。</p>
<h2 id="第15章-多态性和虚函数"><a href="#第15章-多态性和虚函数" class="headerlink" title="第15章 多态性和虚函数"></a>第15章 多态性和虚函数</h2><ul>
<li>多态性(在C++中通过虚函数来实现)是面向对象程序设计语言中数据抽象和继承之外的第三个基本特性。</li>
<li>多态性(polymorphism)提供了接口与具体实现之间的另一层隔离，从而将“what”与“how”分离开来。多态性改善了代码的组织性和可读性，同时也使创建的程序具有可拓展性。</li>
<li>封装(encapsulation)通过组合特性和行为来生成心的数据类型。访问控制通过使细节数据设为 private，将接口从具体实现中分离开来。</li>
</ul>
<h3 id="15-1-C-程序员的演变"><a href="#15-1-C-程序员的演变" class="headerlink" title="15.1 C++ 程序员的演变"></a>15.1 C++ 程序员的演变</h3><p>C程序员可以用三步演变为C++程序员。</p>
<ul>
<li>第一步：简单地把C++作为一个“更好的C”。</li>
<li>第二步：进入“基于对象”的C++。</li>
<li>第三步：了解和使用虚函数，这是理解面向对象程序设计的转折点。不用虚函数，就等于还不懂得面向对象程序设计(OOP)，虚函数增强了类型概念，而不只是在结构内部隐蔽地封装代码。</li>
</ul>
<h3 id="15-2-向上类型转换"><a href="#15-2-向上类型转换" class="headerlink" title="15.2 向上类型转换"></a>15.2 向上类型转换</h3><p>取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这被称为向上类型转换(upcasting)，因为继承树的绘制方式是以基类为顶点的。</p>
<h3 id="15-3-捆绑"><a href="#15-3-捆绑" class="headerlink" title="15.3 捆绑"></a>15.3 捆绑</h3><p>把函数体与函数调用相联系称为捆绑(binding)。当捆绑在程序运行之前(由编译器和连接器)完成时，这称为早捆绑(early binding)。C编译只有一种函数调用方式，就是早捆绑。晚捆绑(late binding)意味着捆绑根据对象的类型，发生在运行时。晚捆绑又称为动态捆绑(dynamic binding)或运行时捆绑(runtime binding)。对于一种编译语言，编译器并不知道实际的对象类型，但它插入能找到和调用正确函数体的代码。</p>
<h3 id="15-4-虚函数"><a href="#15-4-虚函数" class="headerlink" title="15.4 虚函数"></a>15.4 虚函数</h3><p>对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数时使用virtual关键字。晚捆绑支队virtual函数起作用，而且只在使用含有virtual函数的基类的地址时发生，尽管它们也可以在更早的基类中定义。</p>
<p>为了创建一个像virtual这样的成员函数，可以简单地在声明这个函数时使用virtual关键字。仅仅在声明的时候需要使用关键字virtual，定义时并不需要。如果一个函数在基类中被声明为virtual，那么在所有的派生类中它都是virtual的。在派生类中virtual函数的重定义通常称为重写(overriding)。</p>
<p>注意，仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。</p>
<p><strong>15.4.1 拓展性</strong></p>
<p>在一个设计风格良好的OOP程序中，大多数甚至所有的函数都可以沿用基类的某个模型，只需与基类接口通信。这样的程序是可拓展的(extensible)，因为可以通过从公共基类继承新数据类型而增加新功能。操作基类接口的函数完全不需要改变就可以适合于这些新类。</p>
<h3 id="15-5-C-如何实现晚捆绑"><a href="#15-5-C-如何实现晚捆绑" class="headerlink" title="15.5 C++如何实现晚捆绑"></a>15.5 C++如何实现晚捆绑</h3><p>关键字 <code>virtual</code> 告诉编译器它不应当执行早捆绑，相反，它应当自动安装对于实现晚捆绑必需的所有机制。</p>
<p>为了达到这个目的，典型的编译器对每个包含虚函数的类创建一个表(VTABLE)。在VTABLE中，编译器放置特定类的虚函数的地址。在每个带有虚函数的类中，编译器秘密地防止一个指针，称为vpointer(缩写为VPTR)，指向这个对象 VTABLE。当通过基类指针做虚函数调用时(也就是做多台调用时)，编译器静态地插入能取得这个 VPTR 并在 VTABLE 表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。</p>
<p>为每个类设置 VTABLE，初始化 VPTR、为虚函数调用插入代码，所有这些都是自动发生的。利用虚函数，即使在编译器还不知道这个对象的特定类型的情况下，也能调用这个对象中正确的函数。</p>
<p><strong>15.5.1 存放类型信息</strong><br>如果有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针(VPTR)，指向一个存放函数地址的表。我们只需要一个表，因为所有虚函数地址都包含在这个但个表里。</p>
<h3 id="15-6-为什么需要虚函数"><a href="#15-6-为什么需要虚函数" class="headerlink" title="15.6 为什么需要虚函数"></a>15.6 为什么需要虚函数</h3><p>C++ 并不是对于绝对地址的一个简单的 CALL，而是为设置虚函数调用需要两条以上的复杂的汇编指令。这既需要代码空间，又需要执行时间。</p>
<p>一些面向对象的语言已经接受了这种途径，即晚捆绑对于面向对象程序设计是性质所固有的，所以应当总是出现，它不应当是可选的，而且用户并不一定需要知道它。这是在创造语言的设计时决定的，而这种特殊的方法对于许多语言是适合的(smalltalk、Java和Python)。</p>
<p>virtual 关键字可以改变程序的效率。当设计类时，我们不应当为效率问题担心。如果使用多态，就处处使用虚函数。当试图加速代码时，只需寻找可以不使用虚函数的函数。</p>
<p>有些证据表明，C++ 中的规模和速度改进效果是在 C 的规模和速度的 10% 之内，并且常常更接近。能够得到更小的规模和更高速度的原因是 C++ 可以有比 C 更快的方法设计程序，而且设计的程序更小。</p>
<h3 id="15-7-抽象基类和纯虚函数"><a href="#15-7-抽象基类和纯虚函数" class="headerlink" title="15.7 抽象基类和纯虚函数"></a>15.7 抽象基类和纯虚函数</h3><p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类对象。就可以在基类中加入至少一个纯虚函数(pure virtual function)，来使基类成为抽象(abstract)类。纯虚函数使用关键字 <code>virtual</code>，并且在其后面加上 <code>=0</code>。如果试着生成一个抽象类的对象，编译器会制止他。</p>
<p>当继承一个抽象类时，必须实现所有的纯虚函数，否则继承出的类也将是一个抽象类。创建一个纯叙述函数允许在接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。同时纯虚函数要求继承出的类对它提供一个定义。</p>
<p>建立公共接口的唯一原因是它能对于每个不同的子类有不同的表示。它建立一个基本的格式，用来确定什么是对于所有派生类是公共的──除此之外，别无用途。当仅希望通过一个公共接口来操纵一组类，且这个公共接口不需要实现(或者不需要完全实现)时，可以创建一个抽象类。语法为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>这样做，等于告诉编译器在 VTABLE 中为函数保留一个位置，但在这个特定位置中不放地址。只要有一个函数在类中被声明为纯虚函数，则 VTABLE 就是不完全的。</p>
<p>如果一个类的  是不完全的，当试图创建这个类的对象时，编译器就发出一个出错信息。这样，编译器就保证了抽象类的纯洁性，就不会被误用了。</p>
<p>一个类若全是纯虚函数，就称为纯抽象类(pure abstract class)。纯序函数是非常有用的，因为它们使得类有明显的抽象性，并告诉用户和编译器打算如何使用。</p>
<p>注意，纯虚函数禁止对抽象类的函数以传值方式调用。这也是防止对象切片(object slicing)的一种方法。通过抽象类，可以保证在向上类型转换期间总是使用指针或引用。</p>
<h3 id="15-8-继承和-VTABLE"><a href="#15-8-继承和-VTABLE" class="headerlink" title="15.8 继承和 VTABLE"></a>15.8 继承和 VTABLE</h3><p>当实现继承和重新定义一些虚函数时，编译器对新类创建一个新的 VTABLE表，并且插入新函数的地址，对于没有重新定义的虚函数使用基类函数的地址。无论如何，对于可被创建的每个对象(即它的类不含有纯虚函数)，在 VTABLE 中纵有一个函数地址的全集，所以绝对不能对不在其中的地址进行调用(否则结果将是灾难性的)。</p>
<p>若在派生(derived)类中继承或增加新的虚函数，那么通过基类的指针是无法进行调用的。</p>
<p>如果知道保存在一般容器中的所有对象的确切类型，会使我们的设计工作在最佳状态(或者没有选择)。这就是运行时类型辨认(Run-Time Type Identification,RTTI)问题。RTTI是有关向下类型转换基类指针到派生类指针的问题。向上类型转换是自动发生的，不需强制，因为它是绝对安全的。向下类型转换是不安全的，因为这里没有关于实际类型的编译时信息，所以必须准确地知道这个类实际是什么类型。如果把它转换称错误的类型，就会出现麻烦。</p>
<p><strong>15.8.1 对象切片</strong></p>
<p>当多态地处理对象时，传地址与传值有明显的不同。如果对一个对象进行向上类型转换，而不使用地址或引用，这个对象将会被“切片”，直到剩下来的是适合于目的的子对象。确切地来说，派生类对象会被切片成一个基类对象。</p>
<p>对象切片实际上是当它拷贝到一个新的对象时，去掉原来对象的一部分，而不是像使用指针或引用那样简单地改变地址和内容。因此，不常使用对象向上类型转换，事实上，通常要提防或防止这种操作。</p>
<h3 id="15-9-重载和重新定义"><a href="#15-9-重载和重新定义" class="headerlink" title="15.9 重载和重新定义"></a>15.9 重载和重新定义</h3><p>重新定义一个基类中的重载函数将会隐藏所有该函数的其他基类版本。而当对虚函数进行这些操作的时候，情况会有点不同。</p>
<p>编译器不允许我们改变重新定义过的虚函数的返回值(如果不是虚函数，则是允许的)。这是一个非常重要的限制，因为编译器必须保证我们能够多态地通过基类调用函数，若返回值不同，那么就会产生问题。</p>
<p>如果重新定义了基类中的一个重载成员函数，则在派生类中其他的重载函数将会被隐藏。例如，基类中有 <code>f(int)</code> 和 <code>f(string)</code> 这样的重载函数，如果我在派生类中重新定义了 <code>f(int)</code>，那么对于这个派生类来说，<code>f(string)</code>就被隐藏了，不可用了。</p>
<p><strong>15.9.1 变量返回类型</strong></p>
<p>通常，我们不能在重新定义过程中修改虚函数的返回类型，但是也有特例，如果返回一个指向基类的指针或引用，则该函数的重新定义版本可以从基类返回的内容中返回一个指向派生类的指针或引用。</p>
<h3 id="15-10-虚函数和构造函数"><a href="#15-10-虚函数和构造函数" class="headerlink" title="15.10 虚函数和构造函数"></a>15.10 虚函数和构造函数</h3><p>当创建一个报含有虚函数的对象时，必须初始化它的 VPTR 以指向相应的 VTABLE。这必须在对虚函数进行任何调用之前完成。编译器在构造函数开头部分秘密地插入能初始化VPTR的代码。</p>
<p>当寻找效率漏洞时，我们必须明白，编译器正在插入隐藏代码到我们构造函数中。这些隐藏代码不仅必须初始化 VPTR，而且还必须检查this的值(以免operator new返回零)和调用基类构造函数。放在一起，这些代码可以影响我们认为是一个小内联函数的调用。特别是，构造函数的规模会抵消函数调用代价的减少。如果做大量的内联构造函数调用，代码长度就会增长，而在速度上没有任何好处。</p>
<p>当然，也许并不会立即把所有这些小构造函数都变成非内联，因为它们更容易写为内联构造函数。但是，当我们正在调整我们的代码时，务必去掉这些内联构造函数。</p>
<p><strong>15.10.1 构造函数调用次序</strong></p>
<p>所有基类构造函数总是在继承类构造函数中被调用。派生类只访问它自己的成员，而不访问基类的成员。只有基类构造函数能正确地初始化它自己的成员。如果不在构造函数初始化表达式表中显式地调用基类构造函数，他就调用默认构造函数。如果没有默认构造函数，编译器将报告错误。</p>
<p>构造函数调用的顺序是重要的。当继承时，必须知道基类的全部成员并能访问基类的任何 <code>public</code> 和 <code>protected</code> 成员。在通常的成员函数中，构造已经发生，所以这个对象的所有部分的成员都已经建立。然而，在构造函数中，必须想办法保证所有成员都已经建立。保证它的惟一方法是让基类构造函数首先被调用。</p>
<p>只要可能，我们应当在构造函数初始化表达式表中初始化所有的成员对象。只要遵从这个做法，我们就能保证初始化所有基类成员和当前对象的成员对象。</p>
<p><strong>15.10.2 虚函数在构造函数中的行为</strong></p>
<p>对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。</p>
<p>构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象──我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员。这将导致灾难的发生。</p>
<p>当一个构造函数被调用时，它做的首要事情之一就是初始化它的 VPTR。然而，它只能知道它属于“当前”类──即构造函数所在类。于是它完全忽视这个对象是否是基于其他类的。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码──既不是为基类，也不是为它的派生类。VPTR 的状态是由被最后调用的构造函数确定的。</p>
<p>当这一系列构造函数调用正发生时，每个构造函数都已经设置 VPTR 指向子集的 VTABLE。如果函数调用使用虚机制，它将只产生通过它自己的 VTABLE 的调用，而不是最后派生的 VTABLE。</p>
<p>总之，在构造函数中调用虚函数都不能得到预期的结果。</p>
<h3 id="15-11-析构函数和虚拟析构函数"><a href="#15-11-析构函数和虚拟析构函数" class="headerlink" title="15.11 析构函数和虚拟析构函数"></a>15.11 析构函数和虚拟析构函数</h3><p>构造函数是不能为虚函数的。但析构函数能够且常常必须是虚的。</p>
<p>构造函数有一项特殊工作，即一块一块地组合成一个对象。它首先调用基类构造函数，然后调用在继承顺序中的更晚派生的构造函数。类似地，析构函数也有一项特殊工作，即它必须拆卸属于某层次类的对象。析构函数自最晚派生的类开始，并向上到基类。</p>
<p>如果通过指向某个对象基类的指针操纵这个对象(也就是通过它的一般接口操纵这对象)，当我们想在 <code>delete</code> 在栈中已经用new创建的对象的指针时，就会出现这个问题。如果这个指针是指向基类的，在 <code>delete</code> 期间，编译器只能知道调用这个析构函数的基类版本，幸运的是，析构函数可以是虚函数。</p>
<p>不把析构函数设为虚函数是一个隐匿的错误，因为它常常不会对程序有直接的影响，但是会不知不觉引入存储器泄露(关闭程序时内存未释放)。同样，这样的析构操作还有可能掩盖发生的问题。</p>
<p><strong>15.11.1 纯虚析构函数</strong></p>
<p>尽管纯虚析构函数在标准 C++ 中是合法的，但在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。纯虚析构函数和非纯虚虚构函数之间的唯一不同之处在于纯虚析构函数使得基类是抽象类，所以不能创建一个基类的对象(如果基类的任何其他函数是纯虚函数，也是具有同样的效果)。</p>
<p>当从某个含有虚析构函数的类中继承出一个类，情况变得有点复杂。不像其他的纯虚函数，我们不要求在派生类中提供纯虚函数的定义。</p>
<p>一般来说，如果在派生类中基类的纯虚函数(和所有其他纯虚函数)没有重新定义，则派生类将会成为抽象类。但是这里编译器将会自动地为每个类生成一个析构函数定义，基类的析构函数被重写(重新定义)，因此编译器会提供定义并且派生类实际上不会成为抽象类。</p>
<p>当我们的类仅含有一个纯虚函数时，就会发现这个唯一的差别：析构函数。这里析构函数的纯虚性的唯一效果是阻止基类的实例化。如果有其他的纯虚函数，则它们会阻止基类的实例化。</p>
<p>作为一个准则，任何时候我们的类中都要有一个虚函数，我们应当立即增加一个虚析构函数(即使它什么也不做)。这样，我们保证在后面不会出现问题。</p>
<p><strong>15.11.2 析构函数中的虚机制</strong></p>
<p>在析构期间，有一些我们可能不希望马上发生的情况。如果正在一个普通的成员函数中，并且调用一个虚函数，则会使用晚捆绑机制来调用这个函数。而对于析构函数，这样不行，不论是虚的还是非虚的。在析构函数中，只有成员函数的“本地”版本被调用；虚机制被忽略。</p>
<p><strong>15.11.3 创建基于对象的继承</strong></p>
<p>负责动态对象创建(使用 <code>new</code>)的对象进行 <code>delete</code> 调用的称之为“所有者”。在使用容器时的问题是，它们需要足够的灵活性用来接收不同类型的对象。为了做到这一点，容器使用 <code>void</code> 指针，因此它们并不知道所包容对象的类型。删除一个 <code>void</code> 指针并不调用析构函数，所以容器并不负责清除它的对象。</p>
<p>一种方法要求我们要为想在容器中容纳的每一种类型都派生出新类。</p>
<p>问题是我们希望容器可以容纳更多的类型，但我们不想使用 <code>void</code> 指针。另外一种解决方法是使用多态性，它通过强制容器内的所有对象从同一个基类继承而来。也就是说，容器容纳了具有同一基类的对象，并随后调用虚函数──特别地，我们可以调用虚析构函数来解决所有权问题。</p>
<p>这种解决方法使用单根继承(singly-rooted hierarchy)或基于对象的继承(object-based hierarchy)。事实上，除了 C++，每种面向对象的语言都强制使用这样的体系──当创建一个类时，都会直接或间接地从一个公共基类中继承出它，这个基类是由该语言的创建者生成的。C++ 中认为，强制地使用这个公共基类会引起太多的开销，所有便没有使用它。</p>
<h3 id="15-12-运算符重载"><a href="#15-12-运算符重载" class="headerlink" title="15.12 运算符重载"></a>15.12 运算符重载</h3><p>就像对成员函数那样，我们可以使用 virtual 运算符。然而，因为我们可能对两个不知道类型的对象进行操作，所以实现 virtual 运算符通常会很复杂。这通常用于处理数学部分。</p>
<h3 id="15-13-向下类型转换"><a href="#15-13-向下类型转换" class="headerlink" title="15.13 向下类型转换"></a>15.13 向下类型转换</h3><p>C++ 提供了一个特殊的称为 <code>dynamic_cast</code> 的显式类型转换(explicit cast)，它就是一种安全类型向下类型转换(type-safe downcast)的操作。当使用 <code>dynamic_cast</code> 来试着向下类型转换一个特定的类型，仅当类型转换是正确的并且是成功的时，返回值会是一个指向所需类型的指针，否则它将会返回0来表示这并不是正确的类型。</p>
<p>当使用 <code>dynamic_cast</code> 时，必须对一个真正多态的层次进行操作──它含有虚函数──这因为 <code>dynamic_cast</code> 使用了存储在 VTABLE 中的信息来判断实际的类型，所以运行时需要一点额外的开销。</p>
<h2 id="第16章-模板介绍"><a href="#第16章-模板介绍" class="headerlink" title="第16章 模板介绍"></a>第16章 模板介绍</h2><p>继承和组合提供了重用对象代码的方法，而 C++ 的模板特征提供了重用源代码的方法。</p>
<h3 id="16-1-容器"><a href="#16-1-容器" class="headerlink" title="16.1 容器"></a>16.1 容器</h3><p>在一般程序设计问题中，程序员在编写程序时并不知道将来需要创建多少个对象。C++ 中有更好的解决方法：用 <code>new</code> 创建所需要的对象，将其指针放入容器中，待实际实用时将其取出并进行处理。用这种方法，所创建的只是确实需要的对象。通常，在启动程序时没有可用的初始化条件。<code>new</code> 允许等待，直到在环境中相关事件发生后，再实际地创建这个对象。</p>
<h3 id="16-2-模板综述"><a href="#16-2-模板综述" class="headerlink" title="16.2 模板综述"></a>16.2 模板综述</h3><p>有三种源代码重用的方法：</p>
<p>C方法：应该摒弃，由于它表现繁琐、易发生错误、缺乏美感，是非常低效的技术。</p>
<p>Smalltalk方法：通过继承来实现代码重用，既简单又直观。每个容器类包含通用的基类Object的项目。这是一种单纯的技巧，因为Smalltalk类层次上的任何类都源于Object的派生，任何容器可容纳任何类(包括容器本身)。这种基于通用的基类(常称为Object，在Java中也有类似情况)的单树形层次类型称为“基于对象的层次结构”。</p>
<p><strong>16.2.1 模板方法</strong></p>
<p>尽管具有多重继承的基于对象的层次结构在概念上是直观的，但是在实践上较为困难。</p>
<p>模板对源代码进行重用，而不是通过继承和组合重用目标代码。容器不再存放称为Object的通用基类，而是存放一个未指明的参数。当用户使用模板时，参数由编译器来替换。</p>
<p>C++ 中，模板实现了参数化类型(parameterized type)的概念。模板方法的另一个优点是，使对继承不熟悉、不适应的新程序员也能正确地使用密封的容器类。</p>
<h3 id="16-3-模板语法"><a href="#16-3-模板语法" class="headerlink" title="16.3 模板语法"></a>16.3 模板语法</h3><p>template 这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码时，必须指定这些类型以使编译器能够替换它们。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> Array&#123;</div><div class="line">	<span class="keyword">enum</span>&#123; size = <span class="number">100</span> &#125;;</div><div class="line">	T A[size];</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;....&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	Array&lt;<span class="keyword">int</span>&gt; ia;</div><div class="line">	Array&lt;<span class="keyword">double</span>&gt; da;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>T</code> 是替换参数，它代表一个类型名称。在容器类中，它将出现在那些原本由某以特定类型出现的地方。</p>
<p><strong>16.3.1 非内联函数定义</strong></p>
<p>有时我们希望有非内联成员函数的定义。这时编译器需要在成员函数定义之前看到 <code>template</code> 声明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> Array&#123;</div><div class="line">	<span class="keyword">enum</span>&#123; size = <span class="number">100</span> &#125;;</div><div class="line">	T A[size];</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> index) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>注意在引用模板的类名的地方，必须伴游该模板的参数列表。可以想象，在内部，使用模板参数列表中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。</p>
<p>在 <code>template&lt;...&gt;</code> 之后的任何东西都意味着编译器在当时不为它分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉同一模板的多重定义。所以为了使用方便，几乎总是在头文件中放置全部的模板声明和定义。</p>
<p>可以认为模板为 C++ 提供了一种弱类型(weak typing)机制，C++ 通常是强类型语言。</p>
<p><strong>16.3.2 模板中的常量</strong></p>
<p>模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间编程模板的特定示例的常量。我们甚至可以对这些参数使用默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">int</span> size = <span class="number">100</span>&gt;</div><div class="line"><span class="keyword">class</span> Array&#123;</div><div class="line">	T <span class="built_in">array</span>[size];</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里的 size 决不存放在类中，但对它的使用就如同是成员函数中的数据成员。</p>
<p>如果某个类有一个指向 Array 的指针，而不是指向类型 Array 的嵌入对象。该指针在构造函数中不被初始化，而是推迟到第一次访问时。这称为懒惰初始化(lazy initialization)。如果创造大量的对象，但不访问每一个对象，为了节省存储，可以使用懒惰初始化技术。</p>
<h3 id="16-4-打开和关闭所有权"><a href="#16-4-打开和关闭所有权" class="headerlink" title="16.4 打开和关闭所有权"></a>16.4 打开和关闭所有权</h3><p>以值包含对象的容器通常无需担心所有权问题，因为它们清晰地拥有它们所包含的对象。但是，如果容器内包含指向对象的指针(这种情况在C++中相当普遍，有其在多态的情况下)，而这些指针很可能用于程序的其他地方，那么删除该指针指向的对象会导致在程序的其他地方的指针对已销毁的对象进行引用。为了避免上述情况，在设计和使用容器时必须考虑所有权问题。</p>
<p>处理所有权问题的最好方法是由客户程序员来选择。这常常通过构造函数的一个参数来完成，它默认地指明所有权。</p>
<h3 id="16-5-以值存放对象"><a href="#16-5-以值存放对象" class="headerlink" title="16.5 以值存放对象"></a>16.5 以值存放对象</h3><p>如果我们没有模板，那么在一个一般的容器内创建对象的一个拷贝是一个复杂的问题。使用模板，事情噢那个就相对简单了，只要说我们存放对象而不是指针就行了。</p>
<h3 id="16-6-迭代器简介"><a href="#16-6-迭代器简介" class="headerlink" title="16.6 迭代器简介"></a>16.6 迭代器简介</h3><p>迭代器(iterator)是一个对象，它在其他对象的容器上遍历，每此选择它们中的一个，不需要提供对这个容器的实现的直接访问。迭代器提供了一种访问元素的标准方法，无论容器是否提供了直接访问元素的方法。迭代器常常与容器类联合使用，而且迭代器在标准 C++ 容器的设计和使用中是一个基本概念。迭代器也是一种设计模式(design pattern)。</p>
<p>迭代器通常模仿大多数指针的运算。然而，不同的是，迭代器的设计更安全，所以数组越界的可能性更小。</p>
<p>习惯上，用构造函数来创建迭代器，并把它与一个容器对象联系，并且在它的生命期中，不把它与不同的容器联系。</p>
<h2 id="第19章-深入理解模板"><a href="#第19章-深入理解模板" class="headerlink" title="第19章 深入理解模板"></a>第19章 深入理解模板</h2><p>C++ 模板应用的便利性远远超出了它只是一种“T类型容器”(containers of T)的范畴。尽管其最初的设计动机是为了能产生类型安全的通用容器，但在现在 C++ 中，模板也用来生成自定义代码，这些代码通过编译时的程序设计构造来优化程序的执行。</p>
<h3 id="19-1-模板参数"><a href="#19-1-模板参数" class="headerlink" title="19.1 模板参数"></a>19.1 模板参数</h3><p>模板有两类：函数模板和类模板。二者都是由它们的参数来完全地描绘模板的特性。每个模板参数描述了下述内容之一：</p>
<ul>
<li>类型(或者是系统固有类型或者是用户自定义类型)。</li>
<li>编译时常数值(例如，整数、指针和某些静态实体的引用，通常是作为无类型参数的引用)。</li>
<li>其他模板。</li>
</ul>
<p><strong>5.1.1 无类型模板参数</strong></p>
<p>一个无类型模板参数必须是一个编译时所知的整数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">size_t</span> N&gt;</div></pre></td></tr></table></figure>
<p><strong>5.1.2 默认模板参数</strong></p>
<p>在类模板中，可以为模板参数提供默认(缺省)参数，但是在函数模板中却不行。作为默认的模板参数，它们只能被定义一次，编译器会知道第一次的模板声明或定义。一旦引入了一个默认参数，所有它之后的模板参数也必须具有默认值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源自我大学时阅读本书的笔记，算是对自己的『温故知新』。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
      <category term="经典" scheme="http://wdxtub.com/tags/%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>第三十三周 - 笔墨登场</title>
    <link href="http://wdxtub.com/2017/01/27/pen-and-ink/"/>
    <id>http://wdxtub.com/2017/01/27/pen-and-ink/</id>
    <published>2017-01-27T03:55:43.000Z</published>
    <updated>2017-01-27T07:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>起承转合连接着横竖撇捺儿，不能学白字先生不认偏旁笔划儿；辞旧迎新爆竹里炸出一个“福”字儿，五谷丰登米仓里屯着一个“丰”字儿。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.27: 完成初稿</li>
</ul>
<p>除夕啦春节啦，凑上年假居然有十天假期啦，特别感人呀！相比去年在匹兹堡过春节的天寒地冻，在广州在家里过节，开心指数有了成倍的提高。更不用说工作后终于能够自食其力，买买买再也不用眨眼睛。回国后的第一个春节，工作后的第一个春节，同一个春节给了我不一样的触动。对于生活，更加意识到了家人和朋友的重要性，大家在一起最重要就是开心；对于事业，更加坚定了信念，再次以『新参者』的态度去迎接挑战。</p>
<p><img src="/images/14854999393273.jpg" alt=""></p>
<p>年前终于买了属于自己的 Mavic Pro，借此机会去了不少地方借助『天空之眼』去看世界，也很开心能跟不同的朋友分享自己的感受。终于找到了一个值得投入的兴趣爱好，也在吃饭逛街看电影之外找到了更加有意思的活动。对我来说又找到了久违的热血与激情，每一次起飞和降落，都是非常有意思的体验。这么一说，就差一个女朋友一起到处去『飞』啦。</p>
<p>这周我的微博数量终于突破了五位数，不过博客的访问量还是没有能够在年前突破五十万，这个任务就交给接下来的十一个月吧！辛辛苦苦一年，也该休息休息，想想将来了。其中一个可见的将来是，这会是『大疆周记』的最后一篇了。</p>
<p>在大疆的这段时间得到了非常多的帮助和信任，也确确实实感受到了自己的成长，只是有的时候年轻的心还是不安于平淡安稳，于是公司利益与个人方向便出现了偏差。人生难得几回搏，害怕自己变得只敢去做平淡却不大会出差错的事情，希望自己能够一直跳动的追逐着，永远不要停下。</p>
<p>在这里祝大家新年快乐，新的一年希望能认识更多的朋友，飞得更高，看更大的世界。</p>
<p>古人云字如其人，透着一股精气神儿。俗话说师傅领进门儿，心要静手要勤，修行全看个人儿。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起承转合连接着横竖撇捺儿，不能学白字先生不认偏旁笔划儿；辞旧迎新爆竹里炸出一个“福”字儿，五谷丰登米仓里屯着一个“丰”字儿。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="春节" scheme="http://wdxtub.com/tags/%E6%98%A5%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>【降临】披着科幻皮的语言学</title>
    <link href="http://wdxtub.com/2017/01/23/arrival-movie/"/>
    <id>http://wdxtub.com/2017/01/23/arrival-movie/</id>
    <published>2017-01-22T23:57:07.000Z</published>
    <updated>2017-01-23T11:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>语言和文字的出现对任何一个物种来说都是里程碑式的大事，于是，文科生终于拯救了一次世界。（微量剧透）</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.23: 完成初稿</li>
</ul>
<p><img src="/images/14851294600253.jpg" alt=""></p>
<p>『烧脑』和『神作』这两个词都被滥用了，稍微需要推理和重组内容的就可以称之为『烧脑』，做几张酷炫的海报和几个宣传视频就可以叫『神作』。实话说，《降临》这部电影既算不上烧脑，也难以触及神作的标准，但导演和故事所想要表达的东西对于我这个非主流理科生来说还是很对胃口的，这里就想到哪里是哪里，写写我自己的感受吧。</p>
<p>我对语言的认识最初来源于父亲，虽然他一直说我对此有天赋，但是我一直是持怀疑态度的，毕竟很难分辨这到底是不是为了鼓励我让我好好学习的套路。直到后来因为要出国而开始准备托福和 GRE，我才意识到小时候我爸并没有说假话，蓝皮的长难句分析我翻了一遍就过去了，因为除了个别没有见过的表达方式，更多的长难句对我来说就和普通的句子没啥差别，既然一眼就能明白整个句子要表达什么，也就无需去分析句子的语法与词组的搭配了。</p>
<p>这样的自我感觉良好终结于遇到 CMU 语言系的一位教授，是他真正带我走进了语言学的大门。从修辞到文章组织，从语言到思维，我才意识到之前的想法是错误的，句子要表达的意思实际上是根植于语法与搭配中的，不存在『跳过』某步骤的说法，所谓『一眼就能明白句子的意思』不过是我认为的惯用法投射到了原文上，至于是不是原文想要表达的意思，不知道。而只有当明白了组成原文的每一个语言要素，才有可能真正明白其意思，简单来说就是从前我是以中文的模子去套英文，后来我学会了用英文本身去解释英文。</p>
<p>然后就会发现，虽然很多时候这两种方式都可以得到句子的意思，但其实是有细微差别的，只是这样的差别并不影响理解罢了。这里的原因也很简单，重要的沟通都会尽量以低语境的条件展开，即隐藏信息和可能造成的歧义较少。同样，这也能够解释为什么中国留学生大多难过语言关，因为学一门语言最终是学它的思维方式，但这是一个需要时间和精力去琢磨的事情。很多人意识不到个中的技术含量，简单地归结于词汇量和语法的问题，那肯定难以跟外国同事深入沟通，毕竟越是深入沟通越是需要对语言细节的把握，这些恰恰是大部分留学生都欠缺的。</p>
<p>关于语言和思维的讨论，一个很有趣的例子是乔治·奥威尔在《一九八四》中所提到的『新话』，新话试图通过抹去对不够和谐的词汇及表达来控制人们的思维，因为你有一个想法，但是你都没办法表达出来，那么这个想法其实就可以认为是不存在的。我们换个角度去看这个问题，就会意识到语言是能够影响思维的。另一个表现语言影响思维的例子是《合金装备 V 幻痛》，这款游戏中的反派试图通过消灭语言来达到天下大同，因为他认为不同的语言造成了不同的思维，最终导致了这个世界四分五裂。</p>
<p>前面讨论了这么多语言与思维，对不对暂且不说，从这个角度出发，就比较能够了解本片想要表达的内容了：</p>
<blockquote>
<p>女主角学会了外星人不受时间维度控制的语言，于是用这门语言交流思考的时候自我意识就可以超越时间维度，从而能够感知从过去到未来所有自己已有的和会有的记忆。</p>
</blockquote>
<p>为了配合『非线性时间观』这个概念，影片通过各种闪回和倒置从结果一步步回溯到原因，实际上也是带观众体验了一把『非线性』（这里需要解释一下，其实倒序也是一种线性，但问题在于如果做成纯非线性的，估计电影就没人看得懂了）。</p>
<p>外星人的表达方式其实跟我平时写文章的流程很像，我会把一篇文章中想要表达的东西以关键词和零碎句子的方式随意写在一张白纸上，虽然看起来是提纲，其实就是一张写满各种词汇的纸罢了。真正成文的时候，我会对这些关键词进行重新组织与加工，梳理出来逻辑和递进关系，最终成为一篇完整的文章。</p>
<p>停。这里其实就说到了关键。甚至可以认为《三体》中三体人的交流方式也是如此。</p>
<p>《三体》中说过三体人可以直接交流想法，所以不存在套路和欺骗。那么直接交流想法的形式可能是怎么样的呢？复盘我刚才提到的写作流程，其实就可以窥见一二。事情是这样的：</p>
<ol>
<li>我有了一个想法，想要表达</li>
<li>我通过写下各种关键词来确定要表达内容的范围和主题</li>
<li>我对这些关键词进行重新组织，加入逻辑与层次</li>
<li>我把组织好的语言写成文章，大家按照我选择的逻辑和顺序进行阅读</li>
</ol>
<p>这四步是人类通常的沟通交流方式，第三步中可以加入各种反直觉的逻辑，那么如果我们的交流不需要这四步，只要到第二步就足够了呢？按照这个方式去思考，就会发现电影中外星人所使用的文字说得通了，即交流的是想法本身，而不是围绕这个想法所形成的语言，于是用什么方式去沟通不重要，顶多是不同的沟通方式限制能能够表达的范围和精确度（有的从词汇出发，有的从游戏出发）。外星人的文字可以看做是想法的形式化展现，没有特定的顺序和形状，只是处于一种混沌的状态，反而可以认为是『无损』的（因为加入了逻辑与层次实际上对信息进行了有损压缩）。</p>
<p>于是我在想其实这并不是一部标准意义上的『科幻』作品，但正如『科幻』本身就是一种想法，怎么去描述是另外一回事儿。片尾提出的问题其实也是老生常谈了，不妨再重复一次：</p>
<blockquote>
<p>如果让你拥有预知未来的能力，你愿意吗？如果你已经知道未来，你会去改变吗？</p>
</blockquote>
<p>至于影片本身，有点像语言学天赋筛选机，通晓母语是不足够的，要能真正理解两种语言及其所带来的思维方式的异同，恐怕才能真正享受这部电影所带来的头脑风暴体验吧。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://movie.douban.com/review/8178580/" target="_blank" rel="external">关于语言，意识和记忆的呓语</a></li>
<li><a href="https://movie.douban.com/review/8068844/" target="_blank" rel="external">因即是果，果即是因的语言体系</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;语言和文字的出现对任何一个物种来说都是里程碑式的大事，于是，文科生终于拯救了一次世界。（微量剧透）&lt;/p&gt;
    
    </summary>
    
      <category term="Movie" scheme="http://wdxtub.com/categories/Movie/"/>
    
    
      <category term="电影" scheme="http://wdxtub.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="文明" scheme="http://wdxtub.com/tags/%E6%96%87%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>【Go Web 编程】读书笔记</title>
    <link href="http://wdxtub.com/2017/01/23/build-go-web-clip/"/>
    <id>http://wdxtub.com/2017/01/23/build-go-web-clip/</id>
    <published>2017-01-22T16:38:59.000Z</published>
    <updated>2017-01-23T01:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>复习一下 Go 和  Web 的相关知识。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.23: 完成初稿</li>
</ul>
<p>Go 的类型系统没有层级。用户不需要在定义类型之间花费时间。Go 是垃圾回收型预研，为并发执行与通信提供了基本的支持。</p>
<p>Go 使用 <code>package</code> 来组织代码。<code>main.main()</code> 函数是每一个独立的可运行程序的入口点。Go 使用 UTF-8 字符串和标志符，所以天生支持多语言。</p>
<p>Go 的 <code>if</code> 允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> x := dosomething(); x &gt; <span class="number">10</span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Oh"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Yeah"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Go 里面有两个保留的函数：<code>init</code> 函数（能够应用于所有的 package）和 <code>main</code> 函数（只能应用于 package main）。这两个函数在定义时不能有任何的参数和返回值。虽然一个 <code>package</code> 里面可以写任意多个 <code>init</code> 函数，但这无论是对于可读性还是以后的可维护性来说，都强烈建议用户在一个 <code>package</code> 中每个文件只写一个 <code>init</code> 函数。</p>
<p>引入包的操作有两个需要注意</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    f <span class="string">"fmt"</span></div><div class="line">    _ <span class="string">"github.com/wdxtub/wdx"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>第一种引入方式是把包命名成一个比较好记忆的名字。第二个使用 <code>_</code> 则是引入该包而不直接使用包里面的函数，主要是为了调用该包里的 <code>init</code> 函数。</p>
<p>如果匿名字段实现了一个方法，那么包含这个匿名字段的 <code>struct</code> 也能调用该方法。</p>
<p><code>interface</code> 就是一组抽象方法的集合，它必须由其他非 <code>interface</code> 类型实现，而不能自我实现，Go 通过 interface 实现了鸭子类型：当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来像鸭子，那么这只鸟就可以被称为鸭子。</p>
<p>空 interface 有点类似于 C 中的 <code>void*</code> 类型。</p>
<p><code>fmt.Println</code> 可以接受任意类型的数据，其源代码中可以看到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</div><div class="line">    String() <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，任何实现了 <code>String</code> 方法的类型都能作为参数被 <code>fmt.Println</code> 调用。</p>
<p>如何知道 <code>interface</code> 变量里面保存了什么类型的数值？可以使用 comma-ok 语法，比如 <code>value, ok = element.(T)</code> 如果 element 确实是 T 类型，那么 ok 为 true，反之为 false。</p>
<p>另外一种方式是使用 <code>switch</code>，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</div><div class="line">    <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="keyword">int</span>:</div><div class="line">            fmt.Printf(<span class="string">"int"</span>)</div><div class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</div><div class="line">            fmt.Printf(<span class="string">"string"</span>)</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            fmt.Printf(<span class="string">"unknown"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Go 中进行并行程序开发时要注意：不要通过共享来通信，而要通过通信来共享。</p>
<p>对于普通的上网过程，浏览器本身是一个客户端，输入 URL 时首先会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过 IP 地址找到 IP 对应的服务器后，要求建立 TCP 连接，等待浏览器发送完 HTTP Request 包之后，服务器收到请求包才开始处理请求包，调用自身服务，返回 HTTP Response 包，客户端收到来自服务器的响应后开始渲染这个 Response 包里的 body，收到全部内容后，断开与服务器之间的 TCP 连接。</p>
<p>以下均是服务器端的几个概念：</p>
<ul>
<li>Request: 用户请求的信息，用来解析用户的请求信息，包括 post, get, cookie, url 等信息</li>
<li>Response: 服务器需要反馈给客户端的信息</li>
<li>Conn: 用户的每次请求链接</li>
<li>Handler: 处理请求和生成返回信息的处理逻辑</li>
</ul>
<p>http 包执行流程</p>
<ol>
<li>创建 Listen Socket，监听指定的端口，等待客户端请求到来</li>
<li>Listen Socket 接受客户端的请求，得到 Client Socket，接下来通过 Client Socket 与客户端通信</li>
<li>处理客户端的请求，首先从 Client Socket 读取 HTTP 请求的协议头，如果是 post 方法，还可能要读取客户端提交的数据，然后交给相应的 handler 处理请求，handler 处理完毕准备好客户端需要的数据，通过 Client Socket 写给客户端</li>
</ol>
<p>开发 Web 的一个原则就是，不能信任用户输入的任何信息，所以验证和过滤用户的输入信息就变得非常重要。一般有两方面的数据验证，一个是在页面端的 js 验证，一个是在服务端验证。</p>
<p>要使表单能够上传文件，第一步是添加 form 的 <code>enctype</code> 属性，有如下三种情况：</p>
<ul>
<li><code>application/x-www-form-urlencoded</code> 发送前编码所有字符（默认）</li>
<li><code>multipart/form-data</code> 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值</li>
<li><code>text/plain</code> 空格转换为 <code>+</code>，但不对特殊字符编码</li>
</ul>
<p>Web 开发中一个很重要的议题就是如何做好用户整个浏览过程的控制，经典的解决方案是 cookie 和 session，cookie 是一种客户端机制，把用户数据保存在客户端，而 session 机制是一种服务端的机制，服务器使用一种类似于散列表的结构来保存信息，每一个网站访客都会被分配给一个唯一的标志符，即 sessionID，它的存放形式无非两种，要么经过 url 传递，要么保存在客户端的 cookies 里（当然也可以保存到数据库里，更安全，但是效率会下降）</p>
<p>cookie 是有时间限制的，根据生命期不同分成两种：会话 cookie 和持久 cookie。如果不设置过期时间，则表示这个 cookie 生命周期为凑够创建到浏览器关闭为止，只要关闭浏览器窗口，cookie 就消失了。这种生命期为浏览会话期的 cookie 被称为会话 cookie。会话 cookie 一般不保存在硬盘上而是保存在内存里。</p>
<p>如果设置了过期时间 <code>setMaxAge(606024)</code>，浏览器就会把 cookie 保存到硬盘上，关闭后再次打开浏览器，这些 cookie 依然有效直到超过设定的过期时间。存储在硬盘上的 cookie 可以在不同的浏览器进程间共享，比如两个 IE 窗口。而对于保存在内存的 cookie，不同的浏览器有不同的处理方式。</p>
<p>session 机制本身并不复杂，然而实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当做普适的。</p>
<p>session 的基本原理是由服务器为每个会话维护一份信息数据，客户端和服务端依靠一个全局唯一的标识来访问这份数据，以达到交互的目的。当用户访问 Web 应用时，服务端程序会随需要创建 session，这个过程可以概括为三个步骤：</p>
<ul>
<li>生成全局唯一标志符 sessionid</li>
<li>开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就回丢失，如果是电子商务类网站，这将造成严重的后果。所以为了解决这类问题，你可以将会话数据写到文件里或存储在数据库中，这样虽然会增加 I/O 开销，但是可以实现某种程度的 session 持久化，也更有利于 session 的共享</li>
<li>将 session 的全局唯一标志符发送给客户端</li>
</ul>
<p>这里最关键的是如何发送 sessionid，一般有两种方式：cookie 和 URL 重写。</p>
<ol>
<li>Cookie 方式中服务端通过设置 Set-cookie 头就可以将 session 的标志符传送到客户端，而客户端此后的每一次请求都会带上这个标志符，另外包含 session 信息的 cookie 会将失效时间设置为 0（会话 cookie），即浏览器进程有效时间。至于浏览器怎么处理这个 0，不同浏览器有不同方案，但差别都不会太大。</li>
<li>URL 重写方式，就是在返回给用户的页面里的所有 URL 后面追加 sessionid，这样用户收到响应后会自动带上 sessionid，这种做法比较麻烦，但是如果客户端禁用了 cookie，这样方案是首选。</li>
</ol>
<p>session 劫持是一种广泛存在的比较严重的安全威胁，在 session 技术中，客户端和服务端通过 session 的标志符来维护会话，但这个标志符很容易就能被嗅探到，从而被其他人利用，是中间人攻击的一种类型。</p>
<p>如何有效防止 session 劫持呢？其中一个解决方案就是 sessionID 的值只允许 cookie 设置，而不是通过 URL 重置方式设置，同时设置 cookie 的 httponly 为 true，这个属性是设置是否可通过客户端脚本访问这个设置的 cookie，可以防止这个 cookie 被 XSS 读取从而引起 session 劫持，也更难获取 sessionID。然后我们需要在每个请求里面加上隐藏 token，每次提交都需要认证，这样来进行防范。</p>
<p>还有一个解决方案是给 session 额外设置一个创建时间的值，一旦超过，则销毁并重新生成，在一定程度上可以防止 session 劫持的问题。</p>
<p><code>Unmarshal</code> 解析的时候 XML 元素和字段怎么对应起来呢？首先会读取 struct tag，如果没有，那么就寻找对应字段名。必须注意的是解析的时候 tag、字段名、XML 元素都是大小写敏感的，所以必须一一对应字段。</p>
<p>现在的网络编程几乎都是用 Socket 来编程。Socket 起源于 Unix，而 Unix 基本哲学之一就是『一切皆文件』，都可以用『打开 open - 读写 write/read - 关闭 close』模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 具有一个类似于打开文件的函数调用 <code>Socket()</code>，该函数返回一个整型的 Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。</p>
<p>常用的 Socket 类型有两种：流式 Socket(<code>SOCK_STREAM</code>)和数据报式 Socket(<code>SOCK_DGRAM</code>)。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket，对应于无连接的 UDP 服务应用。</p>
<p>Socket 有两种：TCP Socket 和 UDP Socket，TCP 和 UDP 是协议，而要确定一个进程需要三元组，还要 IP 地址和端口。</p>
<p>WebSocket 是 HTML5 的重要特性，它实现了基于浏览器的远程 Socket，它使浏览器和服务器可以进行全双工通信。在 WebSocket 出现之前，为了实现即时通信，采用的技术都是『轮询』，这样会占用大量带宽。WebSocket 采用了一些特殊的报头，使得浏览器和服务器只需要做一个握手的动作，就可以在浏览器和服务器之间建立一条连接通道。且此连接会保持在活动状态，你可以使用 JavaScript 来向连接写入或从中接收数据，就像在使用一个常规的 TCP Socket 一样。</p>
<p>WebSocket 的协议颇为简单，在第一次握手通过以后，连接便建立成功，其后的通讯数据都是以 <code>\x00</code> 开头，以 <code>\xFF</code> 结尾。</p>
<p>REST 是一种架构风格，汲取了 WWW 的成功经验：无状态，以资源为中心，充分利用 HTTP 协议和 URI 协议，提供统一的接口定义，使得它作为一种设计 Web 服务的方法而变得流行。在某种意义上，通过强调 URI 和 HTTP 等早期 Internet 标准，REST 是对大型应用程序服务器时代之前的 Web 方式的回归。</p>
<p>RPC 就是想实现函数调用模式的网络化。客户端就像调用本地函数一样，然后客户端把这些参数打包之后通过网络传递到服务端，服务端解包到处理过程中执行，然后执行的结果反馈给客户端。</p>
<p>RPC(Remote Procedure Call Protocol) 远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。它假定某些传输协议的存在，如 TCP 或 UDP，以便为通信程序之间携带信息数据。通过它可以使函数调用模式网络化。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>运行时，一次客户机对服务器的 RPC 调用，其内部操作大致有如下十步：</p>
<ol>
<li>调用客户端句柄；执行传送参数</li>
<li>调用本地系统内核发送网络消息</li>
<li>消息传送到远程主机</li>
<li>服务器句柄得到消息并取得参数</li>
<li>执行远程过程</li>
<li>执行的过程将结果返回服务器句柄</li>
<li>服务器句柄返回结果，调用远程系统内核</li>
<li>消息传回本地主机</li>
<li>客户句柄由内核接收消息</li>
<li>客户接受句柄返回的数据</li>
</ol>
<p>很多 Web 应用程序中的安全问题都是由于轻信了第三方提供的数据造成的。在使用第三方提供的数据，包括用户提供的数据时，首先检验这些数据的合法性非常重要，这个过程叫做过滤。</p>
<p>加密的本质就是扰乱数据，某些不可恢复的数据扰乱我们称为单向加密算法或者散列算法。另外还有一种双向加密方式，也就是可以对加密后的数据进行解密。</p>
<p>XSS 攻击：跨站脚本攻击(Cross-Site Scripting)是一种常见的 web 安全漏洞，它允许攻击者将恶意代码植入到提供给其他用户使用的页面中。不同于大说书攻击（一般只涉及攻击者和受害者），XSS 涉及到三方，即攻击者、客户端与 Web 应用。XSS 的攻击目标是为了盗取存储在客户端的 cookie 或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。</p>
<p>XSS 通常可以分为两大类：一类是存储型 XSS，主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面就可能受到攻击。这个流程简单可以描述为：恶意用户的 HTML 输入 Web 程序 - 进入数据库 - Web 程序 - 用户浏览器。另一类是反射型 XSS，主要做法是将脚本代码加入 URL 地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。</p>
<p>XSS 目前主要的手段和目的如下：</p>
<ul>
<li>盗用 cookie，获取敏感信息</li>
<li>利用植入 Flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 Java 等得到类似的曹禺</li>
<li>利用 iframe, frame, XMLHttpRequest 或上述 Flash 等方式，以（被攻击者）用户的身份执行一些管理动作</li>
<li>利用可被攻击的域收到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动</li>
<li>在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果</li>
</ul>
<p>防治 SQL 注入的方法：</p>
<ol>
<li>严格限制 Web 应用的数据库操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</li>
<li>检查输入的数据是否具有所期望的数据格式，严格限制变量的类型</li>
<li>对进入数据库的特殊字符进行转义处理</li>
<li>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句</li>
<li>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测，及时修补发现的 SQL 注入漏洞</li>
<li>避免网站打印出 SQL 错误信息，比如类型错误、字段不匹配等，把代码里的 SQL  语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入</li>
</ol>
<p>目前用的最多的密码存储方案是将明文密码做单向哈希后存储，常用算法包括 SHA-256, SHA-1, MD5 等，可用 rainbow table 破解。</p>
<p>安全性比较好的网站，都会用一种『加盐』的方式来存储密码，就是常说的 salt，先将用户输入的密码进行一次 MD5（或其他哈希算法）加密，将得到的 MD5 值前后加上一些只有管理员自己知道的随机串，再进行一次 MD5 加密。</p>
<p>专家级方案是 <code>scrypt</code>，由著名的 FreeBSD 黑客 Colin Percival 为其备份服务 Tarsnap 开发的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习一下 Go 和  Web 的相关知识。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="Web" scheme="http://wdxtub.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>【通天塔之聊聊无人机】拾 飞行安全指南</title>
    <link href="http://wdxtub.com/2017/01/21/drone-thought-flysafe/"/>
    <id>http://wdxtub.com/2017/01/21/drone-thought-flysafe/</id>
    <published>2017-01-21T00:13:28.000Z</published>
    <updated>2017-01-21T03:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为一个无人机近距离拍摄飞机的视频，大家都开始关注无人机的飞行安全问题了，这里我简单说一下自己的想法，并给出简单的飞行安全指南。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.21: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="http://wdxtub.com/2016/07/10/drone-thought-overview/">壹 总览</a></li>
<li><a href="http://wdxtub.com/2016/07/10/drone-thought-tech/">贰 技术趋势</a></li>
<li><a href="http://wdxtub.com/2016/07/11/drone-thought-nasa/">叁 NASA 的计划</a></li>
<li><a href="http://wdxtub.com/2016/07/12/drone-thought-nasa-tech/">肆 NASA 的技术思路</a></li>
<li><a href="http://wdxtub.com/2016/07/12/drone-thought-google/">伍 Google 的想法</a></li>
<li><a href="http://wdxtub.com/2016/07/19/drone-thought-amazon/">陆 Amazon 的想法</a></li>
<li><a href="http://wdxtub.com/2016/09/03/drone-thought-collision-avoidance/">柒 碰撞规避</a></li>
<li><a href="http://wdxtub.com/2016/11/05/drone-thought-atm/">捌 航空管理</a></li>
<li><a href="http://wdxtub.com/2017/01/21/drone-thought-utm/">玖 无人机交通管理</a></li>
<li><a href="http://wdxtub.com/2017/01/21/drone-thought-flysafe/">拾 飞行安全指南</a></li>
</ul>
<h2 id="飞行安全面面观"><a href="#飞行安全面面观" class="headerlink" title="飞行安全面面观"></a>飞行安全面面观</h2><p>任何安全问题其实都是非常复杂的问题，比方说，无人机的飞行安全，至少包括了：</p>
<ul>
<li>无人机本身的安全</li>
<li>空域的安全</li>
<li>信号的安全</li>
<li>可能影响到的设备的安全</li>
</ul>
<p>无人机本身的安全主要依靠设备制造商的技术升级，比方说利用视觉、红外等设备来进行智能避障，提供更加稳定的飞控核心保证在各种复杂情况仍旧能够保证平稳飞行。</p>
<p>空域安全主要是指不与空中已有的飞行器互相干扰甚至导致事故。这部分因为没有相关的法律法规和技术支持，很多时候需要依赖飞手本身的素质的提升，当然这部分也会不断完善，但想一口吃个胖子恐怕是很难的。</p>
<p>信号安全指的是控制无人机的信号不会被劫持或恶意利用，这个和任何无人/自动驾驶系统的道理都是一样的，一旦系统被攻破，可能造成非常严重的后果。目前可能因为保有量不算太多所以还没有被大规模攻击，但各个部分的安全，得在设计之初就考虑进去。</p>
<p>作为从业者，我希望所有的航拍/无人机爱好者能够做出负责任的行为。我们努力工作为无人机添加更多可能，是希望大家能在合理合法的范围内玩得更尽兴，能够给更多人换一个角度审视自己的机会，而不是让人出风头而做出危及公共安全的事情。</p>
<p>在冷兵器时代，弓和弩的出现是一次巨大的飞越，从此人们拥有了远距离攻击的能力。但是在历史的长河中，很多朝代都是禁弩的，为什么，因为威力大使用简单且难以管控，稍不注意可能就会造成重大事故。相反，弓原则上来说是不会被禁止的，一是因为威力较小，二是因为需要一定了熟练度才能灵活运用，三是因为弓是很多家庭的生产工具，不可能直接一刀切。</p>
<p>我觉得从这样的历史中，我们是可以学习一些东西的，以史为鉴可以知兴替。</p>
<h2 id="无人机飞手的自我修养"><a href="#无人机飞手的自我修养" class="headerlink" title="无人机飞手的自我修养"></a>无人机飞手的自我修养</h2><p>虽然现在的无人机大多宣传『到手即飞』，但其实驾驶无人机像开车一样，是需要一定的训练的，不然不出问题才是奇了怪了。我的建议是『到手』先『看飞行指南』，再『起飞』。</p>
<h3 id="起飞点"><a href="#起飞点" class="headerlink" title="起飞点"></a>起飞点</h3><p>首先是选择起飞点：</p>
<ul>
<li>空旷开阔</li>
<li>风力不易过大（尤其是在海边的时候）</li>
<li>雨雪不能飞（比如空气湿度极大，云层极低，都需要注意）</li>
<li>避免鸟群、人群、高大建筑物、磁场干扰地方（尤其是磁场干扰，很多时候难以肉眼发现，请根据指示进行操作）</li>
</ul>
<h3 id="起飞前"><a href="#起飞前" class="headerlink" title="起飞前"></a>起飞前</h3><p>然后是起飞前的准备：</p>
<ul>
<li>安装桨叶，对应安装</li>
<li>开启电源，确保自检正常</li>
<li>GPS 需要 3 格以上</li>
<li>电池预热至 20 度</li>
<li>信道红条过多不宜飞</li>
</ul>
<h3 id="飞行中"><a href="#飞行中" class="headerlink" title="飞行中"></a>飞行中</h3><p>飞行中主要是依靠视觉维持水平稳定，超声波维持竖直方向稳定。如果是室内飞行：</p>
<ul>
<li>速度不易过快</li>
<li>地面不应是纯色或纹理重复率极高（比如马赛克）</li>
<li>下方不宜有运动的物体</li>
<li>不宜有明暗快速变化</li>
<li>地面倾斜角不应大于 30 度</li>
<li>地面不能吸收超声波（超厚的地毯）</li>
<li>水面或透明物体上不行</li>
<li>考虑关闭 GPS 定位，打开三脚架模式，小心谨慎操作</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>飞行遇到特殊情况时：</p>
<ul>
<li>图传中断，用天线侧面对准飞机，恢复图传</li>
<li>信号丢失，会自动返回</li>
<li>悬停不稳，控制降落（指南针或 GPS），用姿态模式稳定</li>
<li>迷失机头，使用状态球</li>
<li>大风无法悬停，尽快降落</li>
</ul>
<h3 id="常见错误飞行"><a href="#常见错误飞行" class="headerlink" title="常见错误飞行"></a>常见错误飞行</h3><p>一定要尽量避免如下的错误操作：</p>
<ul>
<li>在空中内八或外八，导致电机直接关闭</li>
<li>桨没有安装好或卡稳</li>
<li>返航高度的设置不对，需要根据周边环境进行对应设置</li>
<li>不听从应用的建议强行飞行，导致电量过低无法返航</li>
<li>超视距飞行避障失败，要保证飞行高度高于环境所有的物体</li>
<li>倒飞，避障失效（最新的机型支持后向避障）</li>
<li>恶劣条件强行起飞</li>
<li>刹车后偏移撞机</li>
</ul>
<h3 id="电池保养"><a href="#电池保养" class="headerlink" title="电池保养"></a>电池保养</h3><p>使用和保养电池同样是有技巧的</p>
<ul>
<li>放电过流、放电过温、放电低温、电芯损坏</li>
<li>关闭电池再拔出电池</li>
<li>低温需要预热</li>
<li>不要低于 10% 长期放置</li>
<li>每隔三个月需要充放电一次</li>
<li>不要接触液体</li>
<li>确保外界温度</li>
<li>使用官方充电器，充电完毕时断开</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>无人机不是一个简单的小玩具，一定要仔细读说明书，安全飞行，飞得尽兴。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为一个无人机近距离拍摄飞机的视频，大家都开始关注无人机的飞行安全问题了，这里我简单说一下自己的想法，并给出简单的飞行安全指南。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="安全" scheme="http://wdxtub.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="飞行" scheme="http://wdxtub.com/tags/%E9%A3%9E%E8%A1%8C/"/>
    
      <category term="意识" scheme="http://wdxtub.com/tags/%E6%84%8F%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【通天塔之聊聊无人机】玖 无人机交通管理</title>
    <link href="http://wdxtub.com/2017/01/21/drone-thought-utm/"/>
    <id>http://wdxtub.com/2017/01/21/drone-thought-utm/</id>
    <published>2017-01-21T00:13:19.000Z</published>
    <updated>2017-01-21T02:42:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>无规矩不成方圆，在地面上我们有红绿灯斑马线车道交规，但是在空中怎么建立一套规则呢？</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.21: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="http://wdxtub.com/2016/07/10/drone-thought-overview/">壹 总览</a></li>
<li><a href="http://wdxtub.com/2016/07/10/drone-thought-tech/">贰 技术趋势</a></li>
<li><a href="http://wdxtub.com/2016/07/11/drone-thought-nasa/">叁 NASA 的计划</a></li>
<li><a href="http://wdxtub.com/2016/07/12/drone-thought-nasa-tech/">肆 NASA 的技术思路</a></li>
<li><a href="http://wdxtub.com/2016/07/12/drone-thought-google/">伍 Google 的想法</a></li>
<li><a href="http://wdxtub.com/2016/07/19/drone-thought-amazon/">陆 Amazon 的想法</a></li>
<li><a href="http://wdxtub.com/2016/09/03/drone-thought-collision-avoidance/">柒 碰撞规避</a></li>
<li><a href="http://wdxtub.com/2016/11/05/drone-thought-atm/">捌 航空管理</a></li>
<li><a href="http://wdxtub.com/2017/01/21/drone-thought-utm/">玖 无人机交通管理</a></li>
<li><a href="http://wdxtub.com/2017/01/21/drone-thought-flysafe/">拾 飞行安全指南</a></li>
</ul>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>随着无人机出货量与保有量的爆发式增长，低空空域这个无主之地（主要指相关法律法规还没有跟上）便成了兵家必争之地，毕竟除了少部分专业航拍需求的用户，大部分是娱乐飞行的用户，再加上可能出现的无人机送货，怎么能让不同人不同公司以不同角色合理高效安全使用空域，就成了迫切需要解决的问题。</p>
<p>在无人机管理这个问题上，最有分量的玩家有且只有三个：中国、美国和欧洲。对应的系统称之为 Unmanned Aircraft System (UAS) Traffic Management (UTM)，下文统称为 UTM。</p>
<p>美国布局最早，而且有 FAA 和 NASA 一起参与，在理论建设上已经走在了前面。美国的问题主要在于『理论很美好现实很骨感』，现实中各大公司都有自己的利益主张，不同州甚至不同地区都可能有自己的倾向，更不必说孱弱的基础建设，虽然人少地广任你飞，但是很多时候连手机信号都没有的话，很多事情就会变得很麻烦。举个简单的例子，虽然部分禁飞区是写入到无人机的固件中的，但是很多动态的是需要通过网络传输到手机上，给用户进行提示的，结果一次飞行的时候因为没有网络，误入了禁飞区，万一有个什么意外发生，可就不是吃罚单这么简单了。</p>
<p>相较于美国的松散邦联，欧洲的各个国家间的合作本来就难以做到无隙，更不用说英国脱欧这一黑天鹅事件对欧盟的未来产生的巨大影响。欧洲现有的的研究计划很多是基于欧盟这个共同体的，但是随着欧盟的势力范围和影响力逐步下滑（还有令人头疼的难民问题），研究资金能不能及时到位，出台标准后能不能得到所有成员国的通过，通过了之后大家的执行情况如何，都是值得考虑的问题。更麻烦的是，面对新事物，因为欧洲没有一个绝对的领军组织，利益集团间的博弈可能会更加旷日持久。</p>
<p>最后说说中国，中国的情况主要在于法律法规的不完善和相关人才的缺失。我国的航空业起步较晚，并且因为国防压力，只有少部分空域被划分给了民航。而对于超低空的相关空域划分与规定更是基本空白，所以形成了现在睁一只眼闭一只眼，出事儿了再进行处理的方式。但政府和相关机构其实已经意识到了这个问题，也在努力寻找可能的解决方案。中国的优势在于，最大的消费级无人机厂商终于是自己人了，很多前瞻性的测试和验证，都可以快速在本土进行，而一旦确定便可以自上而下的施行，一开始肯定会比较严格，但是随着相关法律法规的完备以及政府接受程度的提升，未来依然有无限可能。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>作为未来无人飞行器的交通管理系统，UTM 作为核心系统，需要一系列配套的设备，相信这也会应运出一系列产业，毕竟我们已经把地面、地下、海洋和高空都利用了起来，就只剩下低空了。在我看来，至少有以下三个方面值得我们去探索：</p>
<h3 id="无人机信息管理"><a href="#无人机信息管理" class="headerlink" title="无人机信息管理"></a>无人机信息管理</h3><p>我们知道围绕大飞机我们有一系列的航行监控检测方式（即使如此仍旧可能出现 MH370 这样的悲剧），那么这样的方式是否适用于无人机？这样带来的经济效应和限制有多少？如何针对不同场景进行对应的信息管理？如何与现有的航空系统兼容？</p>
<p>只有有了这么一个系统，才能保证大量无人机飞行的安全和效率，这也能够极大促进产业本身的发展</p>
<h3 id="地面技术"><a href="#地面技术" class="headerlink" title="地面技术"></a>地面技术</h3><p>我们日常使用的手机的数据链路实际上是通过各个基站来完成覆盖的，那么对于物联网新宠无人机来说，因为硬件设备本身的限制，在通信和监管上都会面比较大的挑战，传统的导航设备也不一定适用于超低空的情况，据此，有没有可能发展出一套低成本高覆盖率的地面支持系统。作为核心的数据链路，最好在现有技术的基础上找到最合适的，一是保证不会干扰到大飞机，二是保证在无人机数量大了之后不会互相干扰。</p>
<p>这部分需要详尽的技术规格，而且也是一个较新的思路，结合地面设备配合，无人机可以有更多应用。</p>
<h3 id="安全与隐私"><a href="#安全与隐私" class="headerlink" title="安全与隐私"></a>安全与隐私</h3><p>无人机的流行意味着人人都可以接触到飞行器，可能会带来隐私和安全的问题，所以需要在技术的支撑下做合理的限制，尽可能不让无人机飞进限飞区。如何减少利用无人机进行违法和危险行为需要制造商和服务提供商共同拿出一套解决方案。现在主要是利用地理围栏和视觉进行安全上的保障，但最近发生的爱好者用无人机近距离拍摄飞机降落的视频告诉我们，这样的限制还远远不够。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个行业的健康发展离不开合理的规则和强大的基础设施支持，尤其是在萌芽阶段，更需要参与的各方用心呵护，而不是竭泽而渔快速透支未来的可能。</p>
<p>不过这事儿吧，也急不来，还是好好踏踏实实一步一个脚印把事情做好吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无规矩不成方圆，在地面上我们有红绿灯斑马线车道交规，但是在空中怎么建立一套规则呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="无人机" scheme="http://wdxtub.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="交通" scheme="http://wdxtub.com/tags/%E4%BA%A4%E9%80%9A/"/>
    
      <category term="管理" scheme="http://wdxtub.com/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第三十二周 - 如何</title>
    <link href="http://wdxtub.com/2017/01/20/what-about/"/>
    <id>http://wdxtub.com/2017/01/20/what-about/</id>
    <published>2017-01-20T13:00:38.000Z</published>
    <updated>2017-01-20T14:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>岁月在这儿，温凉如丝却也能灼身。青春是远方流动的河。要如何原谅时光遗失的过程，要如何才能容忍它发生，要如何才能想而不问。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2016.01.20: 完成初稿</li>
</ul>
<p>上周日是我司研发部 2016 年终晚宴的日子，作为工作人员，一大早抵达会展中心进行设备调试和彩排。第一次亲眼目睹够掌控这么大的空间的总导演，内心的敬佩之情已经溢出。从团队安排到场面控制，从每个细微流程的安排到临场的应变，感觉未来我要走的路还很长，但是能和这么厉害的人共事，多骂我两句我也乐意（虽然越是厉害的人越是以礼待人）。</p>
<p>年会一开始是研发的老大致辞，和我平时接触的感觉一样，直来直往一针见血，明确指出了 2017 是要修炼内功的一年，毕竟这两年团队扩张太快，管理和效率没有完全跟上，很多经验的积累和复用也不够正规。这让在主控台的我诚惶诚恐，因为我在负责的项目正是为修炼『内功』而搭建平台，忽然就感觉肩上的担子又重了一些。</p>
<p>有年会当然少不了抽奖，今年的抽奖软件是我花三天学了一下 vue.js 然后搞出来的，为了保证公平，肯定是需要 code review 的，主持人问到谁有问题的时候，万万没想到是大老板第一个站出来提问，我在主控台被耀眼的聚光灯照着，总算是有惊无险地给出了合理的解释。这样一来，我的代码就是老板认证的了，接下来公司的其他几个部门基本都用得是我写的抽奖软件了，因此也认识了不少新朋友，我还是很开心的。</p>
<p>按级别来成长是很稳但是也很可怕的一种方式，级别本身是是因为采样率过低而不得不采取的一种权衡机制，当一个人成为了这种机制本身的时候，很多年少时的梦都不再有了，只剩下升级瞬间得到的有效期极短的快乐。还是希望自己能坚持去做自己喜欢的事情，临危受命，总觉得还有很多事情是我必须要去做，而且也能做好的，要坚持。</p>
<p>做事情一定是会遇到各种各样的阻力的，但是有的时候最大的阻力可能是想要放弃的念头。大疆作为一个年轻的公司，有好的一面，当然也有不好的一面。我觉得更多还是要看到好的一面，然后努力去改变不好的一面。这么大的队伍，可能真的是很难照顾到每个人的情绪，但是还是要勇敢展现自己，努力去承担责任，先完成一个小目标嘛。</p>
<p>这周经历了比较大的情绪波动，但是还算是做出了正确的选择，经过这样一番挣扎，感觉自己也成长了不少，既然是自己相信的事情，就好好去做吧！</p>
<p>要如何离别仍须游荡的旅人，要如何让缘份就是缘份，如何凝视缘份看我们的每种眼神。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;岁月在这儿，温凉如丝却也能灼身。青春是远方流动的河。要如何原谅时光遗失的过程，要如何才能容忍它发生，要如何才能想而不问。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>做人，做事，做自己</title>
    <link href="http://wdxtub.com/2017/01/18/behave-handle-be-myself/"/>
    <id>http://wdxtub.com/2017/01/18/behave-handle-be-myself/</id>
    <published>2017-01-17T22:59:52.000Z</published>
    <updated>2017-01-23T01:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>士人有百折不回之真心，才有万变不穷之妙用。立业建功，事事要从实地着脚，若少慕声闻，便成伪果；讲道修德，念念要从虚处立基，若稍计功效，便落尘情。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.22: 更新参考文章</li>
<li>2017.01.18: 完成初稿</li>
</ul>
<p>最近有些迷茫，有些摇摆，但归根结底问自己，是有些不安，有些不安带来的不安分。昨天和朋友吃饭的时候不经意的一句话点醒了我，让我意识到了自己的很傻很天真。可能是临近春节的缘故，几个我一直在关注的老司机都写了颇为掏心窝的文章，我一面看一面反思。一是觉得把自己的经验分享出来真的可能让别人少走一些弯路，感谢前辈们的分享；二是认识到自己初出茅庐的局限性，感谢同事朋友们一路的提携指点。</p>
<p>这几天上班下班的路上都在思考这个事情，总结下来正是标题中的三点：做人、做事、做自己。这之中顺序很重要，万万不可费尽心思找捷径：先做人，再做事，最终做自己。</p>
<p>做人，核心就两点：<strong>信任</strong>与<strong>坚持</strong>。信任不必多说，相信队友会以高度责任心完成工作，相信努力与贡献最终会被大家认可。做到信任，很多短期的投机行为就没有存在的意义了，不要成为一个还没开始干活就各种谈条件的人，这样本身就是一种不信任。而坚持并没有想象中这么简单，一是面对不公平和委屈要坚持下来，二是要坚持去做那些自己觉得对的事情，不能说稍有不顺心或者没有达到预期就想着换个地方会不会更好。抄近路反而把时间蹉跎掉了，不值得，还是要把心思放在做事上，做出贡献的同时，努力提高自己的核心竞争力。朋友的一句话让我非常有感触『我一直以来都认为的事情是，外面的机会大把大把的，问题是我自己有没有准备好 』，我想大概说得就是这个道理吧。</p>
<p>做事，重点在于持续输出，无论是写博客还是做项目，短期内看不到爆发式效果是很正常的，就像我写了十个月博客只有不到 80 个粉丝一样，谁能想到几个月之后这个数字就突破五位数了呢？在每个节奏点上都不吃亏，可能就在追求局部最优中提早结束自己的上升期。做事，持续努力证明自己的贡献，持续靠谱赢得更广泛的信任，持续沟通找到最佳解决方案。最近为公司做的一个抽奖软件，本来是为自己部门做的，后来三四个其他部门都用上了，反馈也还不错，这个事情让我意识到了把事情做好不是说要搞多么高大上的东西，而就是在最合适的时间给出最合理的实际可用的解决方案。短期不合理是常态，也不可能存在一个一开始就尽善尽美的系统，但是与其去抱怨这抱怨那，不如努力把事情做得更好。不把事情做好就开始夸夸其谈，其实是没有什么意义的。把工作做好有技巧，但是没有捷径，积累阶段，多接触多学，路也会宽一些。</p>
<p>做自己，恐怕要先找到自己，找到自己的方法很多，但是最靠谱的寻找方式一定是去尝试，而不是以旁观者的身份去看。就好像看了很多人航拍的视频，不自己真正飞一下，根本是没有办法体会个中真义的。而如果找到了特别喜欢的事情，正好自己也有能力让它变得更好，那就应该踏踏实实做出对得起自己这份喜欢的贡献，即使是别人看不到的地方，也要做得简洁优雅，因为很多事情本就不是做给别人看的。</p>
<p>迷则乐境成苦海，如水凝为冰；悟则苦海为乐境，犹冰涣作水。可见苦乐无二境，迷悟非两心，只在一转念间耳。就一身了一身者，方能以万物付万物；还天下于天下者，方能出世间于世间。</p>
<p>最后还是要再感谢一下一路上帮助我点拨我的朋友，觉得自己很幸运，要努力对得起自己的这份幸运。</p>
<p>附：参考文章</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjYxNDk4Mw==&amp;mid=2650720468&amp;idx=1&amp;sn=5e4068f79086897fc518b2c5d11c0f94&amp;chksm=beeceefc899b67ea5e2b4359526a7ddf9cb6dd9336352ce369cd4cfe73801eefa67f60541e5f#rd" target="_blank" rel="external">《厂职工和厂长的委屈》</a></li>
<li><a href="http://weibo.com/ttarticle/p/show?id=2309404065202692840548" target="_blank" rel="external">《打杂和搬砖》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;士人有百折不回之真心，才有万变不穷之妙用。立业建功，事事要从实地着脚，若少慕声闻，便成伪果；讲道修德，念念要从虚处立基，若稍计功效，便落尘情。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
    
      <category term="成长" scheme="http://wdxtub.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="态度" scheme="http://wdxtub.com/tags/%E6%80%81%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>第三十一周 - 初心不忘</title>
    <link href="http://wdxtub.com/2017/01/14/dont-forget-the-heart/"/>
    <id>http://wdxtub.com/2017/01/14/dont-forget-the-heart/</id>
    <published>2017-01-14T01:08:23.000Z</published>
    <updated>2017-01-14T02:07:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在的我们其实都一样，普普通通，匆匆忙忙。一个个平凡而年轻的脸庞，却有着自己，特别的小梦想。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2016.01.14 完成初稿</li>
</ul>
<p>随着气温骤降，广州和深圳终于有了冬天的感觉，这下无论是吃火锅还是吃烧烤都成了开心的选择，唯一不高兴的可能就是体重秤了。气温虽然低了，但是因为临近过年，大家的热情还是高涨的，尤其是在筹备年会这件事儿上，各个部门都都开始忙碌了起来。</p>
<p>我的活比较简单，就是写一个抽奖软件，因为要抽几百个奖项，所以逻辑上一定是要跟现场流程配合的，这就意味着，需求会经常改，我也只能通过一次一次的预演来尽量让抽奖的过程更加自然一些。其实我是非常享受这种努力打磨产品，然后再自己实现出来的感觉的，这种『掌控感』让人欲罢不能。</p>
<p>说是抽奖软件，其实就是一个网页，这是从易用性的角度所得出的技术选型，于是就选择了 Vue.js 来完成这个任务。都不知道当时自己哪来的自信，居然敢在从没有学过前端的时候，在截止日期如此临近的时候，选择一个对自己来说完全陌生的技术，简直完美演绎了 No Zuo No Die。但是神奇的是，居然三天内连学带弄，不但弄完了自己部门的抽奖软件，还顺手把另一个部门的做了，逻辑虽然有些不同，但是可能是一开始的数据结构设计得比较科学，只改几行代码就成。这里我要感谢靠谱的小军大哥在关键的几行代码上指点迷津，拯救了世界。这个故事告诉我们，司机还是老的好，胜读十年书小人书。</p>
<p>现在想来，用项目来逼迫着自己成长，其实还是挺有意思的事情，Vue.js 其实想说要学一两个月了，终于在年末来了个一步到位，虽然还有很多细节的部分没搞懂，比方说实现细节以及浏览器的特点，但是师傅领进门，修行靠个人，相信我的前端水平会随着 W.I.S.E 项目的陆续开展而快速进步的。就像学习计算机系统的时候要从底层的数电逻辑、门电路一路理解到汇编、高级语言，我觉得学习前端也要搞清楚从页面到浏览器最终实现这一整条完整的链路，这样遇到问题的时候才知道如何排查和解决，不然就只能完成一些机械重复的工作而没有任何成长了。</p>
<p>上个周末因为大学室友补办婚宴又回了广州，正好带着无人机飞飞飞飞完之后见到了久违的同学们。可是这种大场面就只能大家热闹一下，我还是觉得要深入聊聊天，得一对一，或者就是俩人一起录制一期『小土刀叨』播客嘛。周末航拍完之后彻底下定决心，买了 Mavic Pro，也于今天到货了。于我，新的创作时代开始了，但是从另一个角度看，颇有『一语成谶』的感觉。</p>
<p>趁着年末整理生活的时候，把自己的 <a href="https://github.com/wdxtub" target="_blank" rel="external">Github</a> 清理了一下，老的项目合并到了归档中，新的项目基本会围绕 <a href="https://github.com/wdxtub/wdxtub.github.io" target="_blank" rel="external">博客</a> 和 <a href="https://github.com/wdxtub/W.I.S.E" target="_blank" rel="external">W.I.S.E</a> 来进行了，噢，还有我的笔记归档 <a href="https://github.com/wdxtub/WDXpeak" target="_blank" rel="external">WDXpeak</a>。另外最近感觉利用收费来过滤非目标用户是挺好的办法，所以 W.I.S.E 在内测的时候不收费，但是进入公测的时候是会进行收费的（内测用户的数据不会丢失且我会个人掏腰包为内测用户提供两年的年费）。</p>
<p>跑步的意义是甩掉那些无意义的烦恼，整理生活的意义是把真正重要的烦恼变成目标，看看在一路烦恼过程中有没有什么可以改变的。年轻人不该安于现状，回忆也是为了更好地往前看。我还是想沿着抵抗力最大的路径走，想要去追寻更大的挑战。虽然我意识到 2017 仍旧是巨变的一年，但是没想到一切来的如此快。</p>
<p>那就面对疾风吧！</p>
<p>将来的我们，和今天不一样。天高海阔，任凭翱翔。一个个厚重而可靠的肩膀，滚烫的胸膛，不变的是倔强。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的我们其实都一样，普普通通，匆匆忙忙。一个个平凡而年轻的脸庞，却有着自己，特别的小梦想。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【小土刀玩摄影】δ 个人航拍飞行器选购指南</title>
    <link href="http://wdxtub.com/2017/01/09/dji-tour-1/"/>
    <id>http://wdxtub.com/2017/01/09/dji-tour-1/</id>
    <published>2017-01-09T14:22:05.000Z</published>
    <updated>2017-01-11T00:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>假如你想换个角度从空中看世界，正好又不知道如何选择合适的个人航拍飞行器的话，那么看完这篇文章相信你心中会有答案。</p>
<p>注：本文主要介绍 Mavic Pro, Phantom 4 Pro 和 Phantom 4 这三款产品。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.11: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="http://wdxtub.com/2016/11/12/alpha-7-tour-1/">α 开拍</a></li>
<li><a href="http://wdxtub.com/2016/11/12/alpha-7-tour-2/">β 读说明书</a></li>
<li><a href="http://wdxtub.com/2016/11/16/alpha-7-tour-3/">γ 从镜头到构图</a></li>
<li><a href="http://wdxtub.com/2017/01/09/dji-tour-1/">δ 个人航拍飞行器选购指南</a></li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>时至今日，我还很清楚地记得第一次坐飞机时，从窗外往下看时的震撼：像血管一般的公路与河流，像蚂蚁一般的车辆与行人与像小朋友一般激动的自己。当我第一次在手机屏幕上看到无人机『看』到的景色时，我才意识到飞翔本身的无限可能。而在我用无人机飞行了 44 次，共 6 小时 15 分钟，总里程 31449 米之后，我能感觉到某种深埋心底的本能被唤醒了：原来我心中，有一个想要飞得更高的梦。</p>
<p>前几天在微博上发了一下自己用无人机拍摄的作品，不少朋友表示了好奇，于是在这里我把自己对无人机的理解和自己飞行的感受分享给大家，算是一个小小的导购吧。</p>
<h2 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h2><p>航拍航拍，有航也有拍，我们也正是通过这两个标准来选择最合适自己的航拍飞行器的。消费级无人机领域主要有两个品牌：一是大疆，二是其他。我就不推荐大家买非大疆的产品了，毕竟都是要买，为什么不买个飞着安全智能省心的呢？</p>
<p>大疆的航拍飞行器又主要分为两大类：一是个人航拍，二是专业航拍。考虑到我只在个人航拍上有一点点经验，专业航拍的部分我就不班门弄斧了。本文旨在从大疆推出的最新几款个人航拍产品中帮大家找到最合适自己的。</p>
<p>航拍中的『航』，是『拍』的基础，拍照需要稳定停在空中，摄像需要飞行动作连贯流畅，而拍摄过程的飞行也需要非常智能（避障、跟随等等）。与此同时，因为我们是通过手机屏幕来查看镜头所『看』到的图像的，所以保证图像的稳定传输也很重要。这里我总结出了几点，作为打分的依据，他们是：</p>
<ul>
<li><strong>悬停</strong>：指飞行器静止在空中某个位置而不飘移，尤其是在有风的时候，只有这样，拍出来的照片才不会虚</li>
<li><strong>机动</strong>：指飞行器运动时的可操作性与飞行安全性，当然还有最重要的续航</li>
<li><strong>图传</strong>：指飞行器与遥控器之间的信号传输的能力</li>
<li><strong>便携</strong>：指飞行器全套装备的编写程度，毕竟带着越轻松，拍得机会才更多</li>
</ul>
<p>而对于『拍』来说，各项指标基本和相机的评价标准差不多，虽然我不是专业玩相机的，但是也算是拍过一点点，这里就以我的个人主观感受来进行简单的评价，标准是：</p>
<ul>
<li><strong>镜头</strong>：主要是基本的镜头素质</li>
<li><strong>成像</strong>：软硬件配合的成像质量，包括色彩等等</li>
</ul>
<p>具体参数什么的可以去文中附带的链接中查看，我会从以上六个角度分别给不同的设备打出 0-10 的分数，并最终给出总分（诸如<strong>性价比</strong>之类的综合指标也考虑在内），供大家参考。</p>
<h2 id="Mavic-Pro"><a href="#Mavic-Pro" class="headerlink" title="Mavic Pro"></a><a href="http://www.dji.com/cn/mavic" target="_blank" rel="external">Mavic Pro</a></h2><p>开始之前我们先看一段视频 — <a href="https://www.skypixel.com/videos/7f05fe97-8d4c-4e2e-8c4a-a4778b20b6ba" target="_blank" rel="external">大疆“御”产品介绍</a>。</p>
<p><img src="/images/14840933196045.jpg" alt=""></p>
<p>飞 Mavic 的整体感觉是声音没那么大了，操作起来更轻盈的同时，甚至更稳一些（与 Phantom 4 对比）。可折叠所带来的便携性的意义可能比大多数人想象得要大得多，从一个航拍设备到一个像玩具的航拍设备所带来的飞跃，相信真正飞一次就能明显感觉到。</p>
<ul>
<li><strong>悬停</strong>：8 分。在风力不大的情况下，稳，真的稳如狗</li>
<li><strong>机动</strong>：7 分。起飞时明显能够感受到轻飞如燕的感觉，惯性也比 Phantom 系列小，得心应手</li>
<li><strong>图传</strong>：6 分。有干扰环境（比如说市区）的信号传输基本上 500 米以外就开始信号不稳了</li>
<li><strong>便携</strong>：9 分。整体打包的体积只有 Phantom 系列的三分之一不到，这样的飞跃真的改变游戏</li>
<li><strong>镜头</strong>：6 分。为了便携牺牲了镜头的质量，但是已经做得足够好了</li>
<li><strong>成像</strong>：7 分。白天效果不错，晚上基本不能放大看，有过饱和和过锐的倾向，但这些可以后期调整，无伤大雅</li>
</ul>
<p>总分：<strong>8 + 1 = 9 分</strong>。加的一分来自便携性带来的轻松以及本身的高性价比。</p>
<h2 id="Phantom-4-Pro"><a href="#Phantom-4-Pro" class="headerlink" title="Phantom 4 Pro"></a><a href="http://www.dji.com/cn/phantom-4-pro" target="_blank" rel="external">Phantom 4 Pro</a></h2><p>开始之前我们先看一段视频 — <a href="https://www.skypixel.com/videos/dji-phantom-4-pro" target="_blank" rel="external">DJI - Phantom 4 Pro 介绍视频</a>。</p>
<p>实话说，我没有飞过 Phantom 4 Pro，但是丰富的 Phantom 4 飞行经验告诉我，Phantom 4 Pro 所带来的改进，如果换个样子，真的可以直接叫 Phantom 5 了。如果不是 Mavic 太 666 完全碾压了 Phantom 4 的话，恐怕 4 Pro 还可以晚一点再出。新增的四向避障虽然左右方向只能在低速模式运行，但用作自动航拍跟踪的机器，是足够了的。后向避障的加入使得更多极限操作变得更加安全，新的 1 寸传感器也使得成像质量得到了质的提高，唯一的缺点，就是太贵以及不知道什么时候又被下一代产品打趴下了。</p>
<ul>
<li><strong>悬停</strong>：9 分。考虑到 Mavic 已经做到的稳如狗，这一点完全没有必要怀疑。</li>
<li><strong>机动</strong>：9 分。更加全面收集环境信息使得智能飞行的速度上限提高了不少，甚至拍公路片都毫无压力</li>
<li><strong>图传</strong>：7 分。目测大部分条件下飞个两三公里毫无压力，具体有待实测</li>
<li><strong>便携</strong>：6 分。重就一个字，不信全套背一次</li>
<li><strong>镜头</strong>：8 分。有了 RX100M3 的大底加成，剩下的就是看成像调教了</li>
<li><strong>成像</strong>：9 分。完全扭转了孱弱的夜景能力，如果主要拍夜景，不要犹豫了</li>
</ul>
<p>总分：<strong>9 - 1 = 8 分</strong>。减的一分来自较低的性价比以及贵出天际的配件价格。</p>
<h2 id="Phantom-4"><a href="#Phantom-4" class="headerlink" title="Phantom 4"></a><a href="http://www.dji.com/cn/phantom-4" target="_blank" rel="external">Phantom 4</a></h2><p>开始之前我们先看一段视频 - <a href="https://www.djivideos.com/video_play/2d54ffc1-b12e-48b7-9075-8cf4839872a6" target="_blank" rel="external">DJI - Phantom 4 介绍视频</a></p>
<p><img src="/images/14840933408171.jpg" alt=""></p>
<p>Phantom 4 是我飞得最多的一个机型，广州深圳上海南京，室内室外，甚至还用来在朋友的婚礼上送过一次戒指（没错就是模仿汪峰），也是我最为了解的机型。Phantom 4 标志着飞行器进入了机器视觉时代，为创作者提供了更大的想象空间。虽然只有前向和底部避障，悬停也不算特别稳，但其智能水平已经让我喜出望外。作为我航拍的启蒙伙伴，好用够用爱用就足以说明一切。</p>
<ul>
<li><strong>悬停</strong>：7 分。实话说，有些不够稳定，不知道是不是我用过的那一台的本身原因</li>
<li><strong>机动</strong>：8 分。跟着我全速跑毫无压力，问题来了，紧急刹车(机)的能力有待加强，侧面和后面都是瞎子让人飞起来有些担心</li>
<li><strong>图传</strong>：6 分。市区里干扰大非常煎熬，但是稍微空旷一些的地方，两三公里无压力</li>
<li><strong>便携</strong>：6 分。重就一个字，不信全套背一次</li>
<li><strong>镜头</strong>：7 分。比 Mavic 好点但是不如 4 Pro，总之是完全够用的</li>
<li><strong>成像</strong>：8 分。色彩还原真实，直接用相册自带的美化功能，就可以搞出大片的效果了</li>
</ul>
<p>总分：<strong>7 + 0.5 = 7.5 分</strong>。降价后性价比有一定提升，各类配件和 4 Pro 通用也是一个小小的加分项。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>追求便携买 Mavic Pro，真的会大大提高出门航拍的意愿</li>
<li>追求画质买 Phantom 4 Pro，和索尼 RX100M3 一样的传感器，用过的都知道靠谱</li>
<li>预算有限买 Mavic Pro，不得不说 Phantom 4 的处境很危险啊</li>
<li>那么什么时候买 Phantom 4 呢，下次打折促销的时候？毕竟只剩下性价比一个竞争力了</li>
</ul>
<p>PS: 有对无人机和航拍感兴趣的朋友可以来免费约飞，至于出不出台就要看我时间和心情了哈。下面是一些我看过感觉不错的评测和教学视频，看了估计就会买买买了，谨慎点开啊。</p>
<h2 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h2><ul>
<li><a href="http://www.bilibili.com/video/av7834320/" target="_blank" rel="external">《值不值得买》第119期：你能闭着眼睛开无人机吗——精灵4Pro</a></li>
<li><a href="http://www.bilibili.com/video/av7409541/" target="_blank" rel="external">《值不值得买》第111期：“御”疆飞翔——Mavic Pro</a></li>
<li><a href="https://www.skypixel.com/videos/141abac3-fa15-49c6-b8a4-266386220853" target="_blank" rel="external">“御” Mavic 系列教学视频—平行/锁定跟随与手势自拍</a></li>
<li><a href="https://www.skypixel.com/videos/eb0744b8-1e20-4f5e-b718-f940fe04838e" target="_blank" rel="external">“御” Mavic 系列教学视频-智能跟随</a></li>
<li><a href="https://www.skypixel.com/videos/53d996a6-91aa-4737-a9c2-c8896356c9e2" target="_blank" rel="external">“御” Mavic 系列教学视频-精准悬停</a></li>
<li><a href="https://www.skypixel.com/videos/0120380f-9692-49b8-ac10-485f4e77eed7" target="_blank" rel="external">“御” Mavic 系列教学视频-精准降落</a></li>
<li><a href="https://www.skypixel.com/videos/c99901cb-b0cd-4502-b221-baab945ce788" target="_blank" rel="external">“御” Mavic 系列教学视频-指点飞行</a></li>
<li><a href="https://www.skypixel.com/videos/1497efce-795a-4ccd-8e72-11df07e74d36" target="_blank" rel="external">Phantom4 Pro应用教学视频-相机使用</a></li>
<li><a href="https://www.skypixel.com/videos/59ae0fa6-cfbe-4ac0-b9dd-19c1a7947cd1" target="_blank" rel="external">Phantom 4 Pro 系列教学视频—指点飞行</a></li>
<li><a href="https://www.skypixel.com/videos/edf9eccf-9313-48c8-9062-6b3057598747" target="_blank" rel="external">Phantom 4 Pro 系列教学视频—手势自拍</a></li>
<li><a href="https://www.skypixel.com/videos/6228520f-8c47-4d00-85b3-d9bb169a6def" target="_blank" rel="external">Phantom 4 Pro 系列教学视频—智能跟随</a></li>
<li><a href="https://www.skypixel.com/videos/phantom-4-d5ba64f5-0086-4fc5-97a1-4141368a3d0a" target="_blank" rel="external">DJI - 大疆科技: Phantom 4智能飞行电池</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假如你想换个角度从空中看世界，正好又不知道如何选择合适的个人航拍飞行器的话，那么看完这篇文章相信你心中会有答案。&lt;/p&gt;
&lt;p&gt;注：本文主要介绍 Mavic Pro, Phantom 4 Pro 和 Phantom 4 这三款产品。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="无人机" scheme="http://wdxtub.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="航拍" scheme="http://wdxtub.com/tags/%E8%88%AA%E6%8B%8D/"/>
    
  </entry>
  
</feed>
