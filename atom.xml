<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小土刀</title>
  <subtitle>Agony is my triumph</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wdxtub.com/"/>
  <updated>2017-01-30T01:00:10.000Z</updated>
  <id>http://wdxtub.com/</id>
  
  <author>
    <name>wdxtub</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【C++ Primer】读书笔记</title>
    <link href="http://wdxtub.com/2017/01/30/cpp-primer-clip/"/>
    <id>http://wdxtub.com/2017/01/30/cpp-primer-clip/</id>
    <published>2017-01-30T10:14:26.000Z</published>
    <updated>2017-01-30T01:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>时隔这么多年又拿起了这本书，简单挑选一些内容作为温故知新的笔记。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.29: 完成初稿</li>
</ul>
<p>C++ 并没有直接定义进行输入或输出的任何语句，这种功能是由标准库提供的。</p>
<p>在写 C++ 程序时，大部分出现空格符的地方可用换行符代替。这条规则的一个例外是字符串字面值中的空格符不能用换行符代替。另一个例外是空格符不允许出现在预处理指示中。</p>
<p>类机制是 C++ 最重要的特征之一。</p>
<p>标准库的头文件用尖括号，非标准库的头文件用双引号括起来。</p>
<p>字符类型有两种：<code>char</code> 和 <code>wchar_t</code>，其中 <code>wchar_t</code> 用于扩展字符集，比如汉字和日语，这些字符集中的一些字符不能用单个 <code>char</code> 表示。</p>
<p>程序不应该依赖未定义行为。</p>
<p>在 C++ 中理解『初始化不是赋值』是必要的。初始化值指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。</p>
<p>直接初始化语法更灵活且效率更高。</p>
<p>通常把一个对象定义在它首次使用的地方是一个很好的方法。</p>
<p>非 const 变量默认为 extern。要使 const 变量能够在其他的文件中访问，必须显式地制定它为 extern。</p>
<p>当引用初始化后，只要该引用存在，它就保持绑定到初始化时指向的对象。不可能将引用绑定到另一个对象。</p>
<p>非 const 引用只能绑定到与该引用同类型的对象。const 引用则可以绑定到不同但相关的类型的对象或绑定到右值。</p>
<p><code>typedef</code> 通常被用于以下三种目的：</p>
<ul>
<li>为了隐藏特定类型的实现，强调使用</li>
<li>简化负责的类型定义，使其更易理解</li>
<li>允许一种类型用于多个目的，同时使得每次使用该类型的目的明确</li>
</ul>
<p>编程新手经常会忘记类定义后面的分号，这是个很普遍的错误！</p>
<p>用 class 和 struct 关键字定义类的唯一差别在于默认访问级别：默认情况下，struct 的成员为 public，而 class 的成员为 private。</p>
<p>头文件应该含有保护符，即使这些头文件不会被其他头文件包含。编写头文件保护符并不困难，而且如果头文件被包含多次，它可以避免难以理解的编译错误。</p>
<p>通常，头文件中应该只定义确实必要的东西。请养成这个好习惯。</p>
<p>任何存储 string 的 size 操作结果的变量必须为 <code>string::size_type</code> 类型。特别重要的是，不要把 size 的返回值赋给一个 int 变量。</p>
<p>vector 不是一种数据类型，而只是一个类模板，可以用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。因此，<code>vector&lt;int&gt;</code> 和 <code>vector&lt;string&gt;</code> 都是数据类型。</p>
<p>现代 C++ 程序应尽量使用 vector 和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。</p>
<p>除非显式地提供元素初值，否则内置类型的局部数组的元素没有初始化。此时，除了给元素赋值外，其他使用这些元素的操作没有定义。</p>
<p>一些编译器允许将数组赋值作为编译器扩展，但是如果希望编写的程序能在不同的编译器上运行，则应该避免使用像数组赋值这类依赖于编译器的非标准功能。</p>
<p>指针和数组容易产生不可预料的错误。其中一部分是概念上的问题：指针用于低级操作，容易产生与繁琐细节相关的错误。其他错误则源于使用指针的语法规则，特别是声明指针的语法。</p>
<p>很多运行时错误都源于使用了未初始化的指针。</p>
<p>如果可能的话，除非所指向的对象已经存在，否则不要先定义指针，这样可避免定义一个未初始化的指针。如果必须分开定义指针和其所指向的对象，则将指针初始化为 0，因为编译器可检测出 0 值的指针，程序可判断该指针并未指向一个对象。</p>
<p>指针的算术操作只有在原指针和计算出来的新指针都指向同一个数组的元素，或指向该数组存储空间的下一单元才是合法的。如果指针指向一对象，我们还可以在指针上加 1 从而获取指向相邻的下一个对象的指针。</p>
<p>C++ 允许计算数组或对象的超出末端的地址，但不允许对此地址进行解引用操作。而计算数组超出末端位置之后或数组首地址之前的地址都是不合法的。</p>
<p>不能使用指向 const 对象的指针修改基础对象，然而如果该指针指向的是一个非 const 对象，可用其他方法修改其所指的对象。</p>
<p>尽管 C++ 支持 C 风格字符串，但不应该在 C++ 程序中使用这个类型。C 风格字符串常常带来许多错误，是导致大量安全问题的根源。</p>
<p>对于动态分配的数组，其元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。</p>
<p>对于位操作符，由于系统不能确保如何处理其操作数的符号位，所以强烈建议使用 unsigned 整型操作数。</p>
<p>一般而言，标准库提供的 bitset 操作更直接、更容易阅读和书写、正确使用的可能性更高。而且，bitset 对象的大小不受 unsigned 数的位数限制。通常来说，bitset 优于整型数据的低级直接位操作。</p>
<p>一旦删除了指针所指向的对象，立即将指针置为 0，这样就非常清除地表明指针不再指向任何对象。</p>
<p>虽然有时候确实需要强制类型转换，但是它们本质上是非常危险的。</p>
<p>使用空语句时应该加上注释，以便任何读这段代码的人都知道该语句是有意省略的。</p>
<p>无关的空语句并非总是无害的。</p>
<p>故意省略 case 后面的 break 语句是很罕见的，因此应该提供一些注释说明其逻辑。</p>
<p>在循环条件中定义的变量在每次循环里都要经历创建和撤销的过程。</p>
<p>如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为 const 引用。</p>
<p>通常，函数不应该有 vector 或其他标准库容器类型的形参。调用含有普通的非引用 vector 形参的函数将会复制 vector 的每一个元素。C++ 程序员倾向于通过传递指向容器中需要处理的元素的迭代器来传递容器。</p>
<p>理解返回引用至关重要的是：千万不能返回局部变量的引用。</p>
<p>定义函数的源文件应该包含声明该函数的头文件。</p>
<p>在 C++ 中，名字查找发生在类型检查之前。</p>
<p>如果指向函数的指针没有初始化，或者具有 0 值，则该指针不能在函数调用中使用。</p>
<p>为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。</p>
<p>使用迭代器编写程序时，必须留意哪些操作会式迭代器失效。使用无效迭代器将会导致严重的运行时错误。</p>
<p>任何 insert 或 push 操作都可能导致迭代器失效。当编写循环将元素插入到 vector 或 deque 容器中时，程序必须确保迭代器在每次循环后都得到更新。</p>
<p>不要存储 end 操作返回的迭代器。添加或删除 deque 或 vector 容器内的元素都会导致存储的迭代器失效。</p>
<p>最简单地来说，类就是定义了一个新的类型和一个新的作用域。</p>
<p>按照与成员声明一致的次序编写构造函数初始化列表十个好主意。此外、尽可能避免使用成员来初始化其他成员。</p>
<p>我们更喜欢使用默认实参，因为它减少代码重复。</p>
<p>如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数。它应该定义自己的构造函数来初始化这些成员。</p>
<p>通常，除非有明显的理由想要定义隐式转换，否则，单形参构造函数应该为 explicit。将构造函数设置为 explicit 可以避免错误，并且当转换有用时，用户可以显式地构造对象。</p>
<p>定义和使用构造函数几乎总是较好的。当我们为自己定义的类型提供一个默认构造函数时，允许编译器自动运行那个构造函数，以保证每个类对象在初次使用之前正确地初始化。</p>
<p>通常，将友元声明成组地放在类定义的开始或结尾是个好主意。</p>
<p>保证对象正好定义一次的最好办法，就是将 static 数据成员的定义放在包含类的非内联成员函数定义的文件中。</p>
<p>为了防止复制，类必须显式声明其复制构造函数为 private。</p>
<p>一般来说，最好显式或隐式定义默认构造函数和复制构造函数。只有不存在其他构造函数时才合成默认构造函数。如果定义类复制构造函数。也必须定义默认构造函数。</p>
<p>当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的指针或实际对象（而不是对象的引用）超出作用域时，才会运行析构函数。</p>
<p>如果类需要析构函数，则它也需要赋值操作符和复制构造函数，这是一个有用的经验法则。</p>
<p>基类通常应将派生类需要重定义的任意函数定义为虚函数。</p>
<p>一旦函数在基类中声明为虚函数，它就一直为虚函数，派生类无法改变该函数为虚函数这一事实。派生类重定义虚函数时，可以使用 virtual 保留字，但不是必须这样做。</p>
<p>只有成员函数中的代码才应该使用作用域操作符覆盖虚函数机制。</p>
<p>通过异常我们能够将问题的检测和问题的解决分离，这样程序的问题检测部分可以不必了解如何处理问题。</p>
<p>可能存在异常的程序以及分配资源的程序应该使用类来管理那些资源。</p>
<p>定义多个不相关类型的命名空间应该使用分离的文件，表示该命名空间定义的每个类型。</p>
<p>using 指示不声明命名空间成员名字的别名，相反，它具有将命名空间成员提升到包含命名空间本身和 using 指示的最近作用域的效果。</p>
<p>using 指示有用的一种情况是，用在命名空间本身的实现文件中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔这么多年又拿起了这本书，简单挑选一些内容作为温故知新的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="基础" scheme="http://wdxtub.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp 编码风格指南</title>
    <link href="http://wdxtub.com/2017/01/29/cpp-style-guide/"/>
    <id>http://wdxtub.com/2017/01/29/cpp-style-guide/</id>
    <published>2017-01-29T01:33:22.000Z</published>
    <updated>2017-01-29T07:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离我第一次接触 Google Cpp 编码风格指南已经过去了八年，现在再来看看，感觉别有一番风味。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.29: 完成初稿</li>
</ul>
<p>本文来源于 <a href="https://github.com/zh-google-styleguide/zh-google-styleguide" target="_blank" rel="external">Google 开源项目风格指南 (中文版) </a>，版本 4.45。感谢原作者和译者的付出。这里主要是整理一下，方便自己阅读。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.</p>
<p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p>
<p>风格, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p>
<p>使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.</p>
<p>本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.</p>
<p>Google 主导的开源项目均符合本指南的规定.</p>
<p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>通常每一个 <code>.cc</code> 文件都有一个对应的 <code>.h</code> 文件. 也有一些常见例外, 如单元测试代码和只包含 <code>main()</code> 函数的 <code>.cc</code> 文件.</p>
<p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p>
<p>下面的规则将引导你规避使用头文件时的各种陷阱.</p>
<h3 id="Self-contained-头文件"><a href="#Self-contained-头文件" class="headerlink" title="Self-contained 头文件"></a>Self-contained 头文件</h3><blockquote>
<p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code>.</code>h 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code> 头文件的做法.</p>
</blockquote>
<p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 <code>#define</code> 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.</p>
<p>不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 <code>.inc</code> 文件扩展名。</p>
<p>如果 <code>.h</code> 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 <code>.cc</code> 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 <code>-inl.h</code> 文件里（译者注：过去该规范曾提倡把定义放到 <code>-inl.h</code> 里过）。</p>
<p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 <code>.cc</code> 文件里。</p>
<h3 id="define-保护"><a href="#define-保护" class="headerlink" title="#define 保护"></a>#define 保护</h3><blockquote>
<p>所有头文件都应该使用 <code>#define</code> 来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code> .<br>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 <code>foo</code> 中的头文件 <code>foo/src/bar/baz.h</code> 可按如下方式保护:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_BAZ_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_BAZ_H_</span></div><div class="line">…</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></div></pre></td></tr></table></figure>
<h3 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h3><blockquote>
<p>尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。</p>
</blockquote>
<p><strong>定义：</strong></p>
<p>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p>
<p><strong>优点：</strong></p>
<ul>
<li>前置声明能够节省编译时间，多余的 <code>#include</code> 会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够节省不必要的重新编译的时间。 <code>#include</code> 使代码因为头文件中无关的改动而被重新编译多次。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li>
<li>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li>
<li>前置声明来自命名空间 <code>std::</code> 的 symbol 时，其行为未定义。</li>
<li>很难判断什么时候该用前置声明，什么时候该用 <code>#include</code> 。极端情况下，用前置声明代替 <code>includes</code> 甚至都会暗暗地改变代码的含义：</li>
</ul>
<p>如果 <code>#include</code> 被 B 和 D 的前置声明替代，<code>test()</code> 就会调用 <code>f(void*)</code> . </p>
<ul>
<li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 <code>include</code> 冗长。</li>
<li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li>
</ul>
<p><strong>结论</strong>：</p>
<ul>
<li>尽量避免前置声明那些定义在其他项目中的实体.</li>
<li>函数：总是使用 <code>#include</code>.</li>
<li>类模板：优先使用 <code>#include</code>.</li>
</ul>
<p>至于什么时候包含头文件，参见 name-and-order-of-includes。</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><blockquote>
<p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</p>
<p><strong>优点:</strong></p>
<p>只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p>
<p><strong>缺点:</strong></p>
<p>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p>
<p><strong>结论:</strong></p>
<p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<p>另一个实用的经验准则: 内联那些包含循环或 <code>switch</code> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <code>switch</code> 语句从不被执行).</p>
<p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p>
<h3 id="include-的路径及顺序"><a href="#include-的路径及顺序" class="headerlink" title="#include 的路径及顺序"></a>#include 的路径及顺序</h3><blockquote>
<p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.</p>
</blockquote>
<p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <code>.</code> (当前目录) 或 <code>..</code> (上级目录). 例如, <code>google-awesome-project/src/base/logging.h</code> 应该按如下方式包含:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/logging.h"</span></span></div></pre></td></tr></table></figure>
<p>又如, <code>dir/foo.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p>
<ol>
<li><code>dir2/foo2.h</code> (优先位置, 详情如下)</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的 <code>.h</code> 文件</li>
<li>本项目内 <code>.h</code> 文件</li>
</ol>
<p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p>
<p><code>dir/foo.cc</code> 和 <code>dir2/foo2.h</code> 通常位于同一目录下 (如 <code>base/basictypes_unittest.cc</code> 和 <code>base/basictypes.h</code>), 但也可以放在不同目录下.</p>
<p>按字母顺序对头文件包含进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p>
<p>您所依赖的 symbols 被哪些头文件所定义，您就应该包含（include）哪些头文件，forward-declaration 情况除外。比如您要用到 <code>bar.h</code> 中的某个 symbol, 哪怕您所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code> 就够了，不用再管后者所包含的其它内容。</p>
<p>举例来说, <code>google-awesome-project/src/foo/internal/fooserver.cc</code> 的包含次序如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/fooserver.h"</span> <span class="comment">// 优先位置</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hash_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/basictypes.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/commandlineflags.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/bar.h"</span></span></div></pre></td></tr></table></figure>
<p><strong>例外：</strong></p>
<p>有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/fooserver.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/port.h"</span>  <span class="comment">// For LANG_CXX11.</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LANG_CXX11</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// LANG_CXX11</span></span></div></pre></td></tr></table></figure>
<p>译者 (YuleFox) 笔记</p>
<ol>
<li>避免多重包含是学编程时最基本的要求;</li>
<li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li>
<li>内联函数的合理使用可提高代码执行效率;</li>
<li><code>-inl.h</code> 可提高代码可读性 (一般用不到吧:D);</li>
<li>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li>
<li>包含文件的名称使用 <code>.</code> 和 <code>..</code> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</li>
</ol>
<p>译者（acgtyrant）笔记</p>
<ol>
<li>原来还真有项目用 <code>#includes</code> 来插入文本，且其文件扩展名 <code>.inc</code> 看上去也很科学。</li>
<li>Google 已经不再提倡 <code>-inl.h</code> 用法。</li>
<li>注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li>
<li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 <code>.cc</code> 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li>
<li>在 <code>#include</code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code>.h</code> 和本项目内的 <code>.h</code> 是个好习惯。</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><blockquote>
<p>鼓励在 <code>.cc</code> 文件内使用匿名名字空间. 使用具名的名字空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>名字空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.</p>
<p><strong>优点:</strong></p>
<p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 名字空间在这基础上又封装了一层.</p>
<p>举例来说, 两个不同项目的全局作用域都有一个类 <code>Foo</code>, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同名字空间中, <code>project1::Foo</code> 和 <code>project2::Foo</code> 作为不同符号自然不会冲突.</p>
<p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> X &#123;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y &#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>X::Y::foo()</code> 与 <code>X::foo()</code> 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p>
<p><strong>缺点:</strong></p>
<p>名字空间具有迷惑性, 因为它们和类一样提供了额外的 (可嵌套的) 命名轴线.</p>
<p>命名空间很容易令人迷惑，毕竟它们不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p>
<p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</p>
<p><strong>结论:</strong></p>
<p>根据下文将要提到的策略合理使用命名空间.</p>
<h4 id="匿名名字空间"><a href="#匿名名字空间" class="headerlink" title="匿名名字空间"></a>匿名名字空间</h4><p>在 <code>.cc</code> 文件中, 允许甚至鼓励使用匿名名字空间, 以避免运行时的命名冲突:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> &#123;                             <span class="comment">// .cc 文件中</span></div><div class="line"></div><div class="line"><span class="comment">// 名字空间的内容无需缩进</span></div><div class="line"><span class="keyword">enum</span> &#123; kUNUSED, kEOF, kERROR &#125;;         <span class="comment">// 经常使用的符号</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AtEof</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pos_ == kEOF; &#125;   <span class="comment">// 使用本名字空间内的符号 EOF</span></div><div class="line"></div><div class="line">&#125; <span class="comment">// namespace</span></div></pre></td></tr></table></figure>
<p>然而, 与特定类关联的文件作用域声明在该类中被声明为类型, 静态数据成员或静态成员函数, 而不是匿名名字空间的成员. 如上例所示, 匿名空间结束时用注释 <code>// namespace</code> 标识.</p>
<p>不要在 <code>.h</code> 文件中使用匿名名字空间.</p>
<h4 id="具名的名字空间"><a href="#具名的名字空间" class="headerlink" title="具名的名字空间"></a>具名的名字空间</h4><p>具名的名字空间使用方式如下:</p>
<p>用名字空间把文件包含, gflags 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它名字空间:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// .h 文件</span></div><div class="line"><span class="keyword">namespace</span> mynamespace &#123;</div><div class="line"></div><div class="line"><span class="comment">// 所有声明都置于命名空间中</span></div><div class="line"><span class="comment">// 注意不要使用缩进</span></div><div class="line"><span class="keyword">class</span> MyClass &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    …</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&#125; <span class="comment">// namespace mynamespace</span></div><div class="line"><span class="comment">// .cc 文件</span></div><div class="line"><span class="keyword">namespace</span> mynamespace &#123;</div><div class="line"></div><div class="line"><span class="comment">// 函数定义都置于命名空间中</span></div><div class="line"><span class="keyword">void</span> MyClass::Foo() &#123;</div><div class="line">    …</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125; <span class="comment">// namespace mynamespace</span></div></pre></td></tr></table></figure>
<p>通常的 <code>.cc</code> 文件包含更多, 更复杂的细节, 比如引用其他名字空间的类等.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> “a.h”</span></div><div class="line"></div><div class="line">DEFINE_bool(someflag, <span class="literal">false</span>, “dummy flag”);</div><div class="line"></div><div class="line"><span class="keyword">class</span> C;                    <span class="comment">// 全局名字空间中类 C 的前置声明</span></div><div class="line"><span class="keyword">namespace</span> a &#123; <span class="keyword">class</span> A; &#125;    <span class="comment">// a::A 的前置声明</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> b &#123;</div><div class="line"></div><div class="line">…code <span class="keyword">for</span> b…                <span class="comment">// b 中的代码</span></div><div class="line"></div><div class="line">&#125; <span class="comment">// namespace b</span></div></pre></td></tr></table></figure>
<p>不要在名字空间 <code>std</code> 内声明任何东西, 包括标准库的类前置声明. 在 <code>std</code> 名字空间声明实体会导致不确定的问题, 比如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</p>
<p>最好不要使用 <code>using</code> 指示，以保证名字空间下的所有名称都可以正常使用.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 禁止 —— 污染名字空间</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</div></pre></td></tr></table></figure>
<p>在 <code>.cc</code> 文件, <code>.h</code> 文件的函数, 方法或类中, 可以使用 using 声明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 允许: .cc 文件中</span></div><div class="line"><span class="comment">// .h 文件的话, 必须在函数, 方法或类的内部使用</span></div><div class="line"><span class="keyword">using</span> ::foo::bar;</div></pre></td></tr></table></figure>
<p>在 <code>.cc</code> 文件, <code>.h</code> 文件的函数, 方法或类中, 允许使用名字空间别名.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 允许: .cc 文件中</span></div><div class="line"><span class="comment">// .h 文件的话, 必须在函数, 方法或类的内部使用</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</div><div class="line"></div><div class="line"><span class="comment">// 在 .h 文件里</span></div><div class="line"><span class="keyword">namespace</span> librarian &#123;</div><div class="line"><span class="comment">//以下别名在所有包含了该头文件的文件中生效。</span></div><div class="line"><span class="keyword">namespace</span> pd_s = ::pipeline_diagnostics::sidetable;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// namespace alias local to a function (or method).</span></div><div class="line">  <span class="keyword">namespace</span> fbz = ::foo::bar::baz;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">&#125;  <span class="comment">// namespace librarian</span></div></pre></td></tr></table></figure>
<p>注意在 <code>.h</code> 文件的别名对包含了该头文件的所有人可见，所以在公共头文件（在项目外可用）以及它们递归包含的其它头文件里，不要用别名。毕竟原则上公共 API 要尽可能地精简。<br>禁止用内联命名空间</p>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><blockquote>
<p>当公有嵌套类作为接口的一部分时, 虽然可以直接将他们保持在全局作用域中, 但将嵌套类的声明置于<code>名字空间</code>内是更好的选择.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>在一个类内部定义另一个类; 嵌套类也被称为 成员类 (member class).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo &#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Bar是嵌套在Foo中的成员类</span></div><div class="line">    <span class="keyword">class</span> Bar &#123;</div><div class="line">        …</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>优点:</strong></p>
<p>当嵌套 (或成员) 类只被外围类使用时非常有用; 把它作为外围类作用域内的成员, 而不是去污染外部作用域的同名类. 嵌套类可以在外围类中做前置声明, 然后在 <code>.cc</code> 文件中定义, 这样避免在外围类的声明中定义嵌套类, 因为嵌套类的定义通常只与实现相关.</p>
<p><strong>缺点:</strong></p>
<p>嵌套类只能在外围类的内部做前置声明. 因此, 任何使用了  <code>Foo::Bar*</code> 指针的头文件不得不包含类 <code>Foo</code> 的整个声明.</p>
<p><strong>结论:</strong></p>
<p>不要将嵌套类定义成公有, 除非它们是接口的一部分, 比如, 嵌套类含有某些方法的一组选项.</p>
<h3 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h3><blockquote>
<p>使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数.</p>
</blockquote>
<p><strong>优点:</strong></p>
<p>某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在名字空间内可避免污染全局作用域.</p>
<p><strong>缺点:</strong></p>
<p>将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.</p>
<p><strong>结论:</strong></p>
<p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个名字空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用<code>名字空间</code>。</p>
<p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的名字空间内.</p>
<p>如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名 <code>namespaces</code> 或 <code>static</code> 链接关键字 (如 <code>static int Foo() {...}</code>) 限定其作用域.</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><blockquote>
<p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p>
</blockquote>
<p>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line">i = f(); <span class="comment">// 坏——初始化和声明分离</span></div><div class="line"><span class="keyword">int</span> j = g(); <span class="comment">// 好——初始化时声明</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">v.push_back(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></div><div class="line">v.push_back(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 好——v 一开始就初始化</span></div></pre></td></tr></table></figure>
<p>注意, GCC 可正确实现了 <code>for (int i = 0; i &lt; 10; ++i)</code> (<code>i</code> 的作用域仅限 <code>for</code> 循环内), 所以其他 <code>for</code> 循环中可以重新使用 <code>i</code>. 在 <code>if</code> 和 <code>while</code> 等语句中的作用域声明也是正确的, 如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, ‘/’)) str = p + <span class="number">1</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>Warning: 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 低效的实现</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</div><div class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></div><div class="line">    f.DoSomething(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在循环作用域外面声明这类变量要高效的多:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</div><div class="line">    f.DoSomething(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h3><blockquote>
<p>禁止使用 <code>class</code> 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 <code>constexpr</code> 变量除外，毕竟它们又不涉及动态初始化或析构。</p>
</blockquote>
<p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是不确定的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数不涉及（比如 <code>getenv()</code> 或 <code>getpid()</code>）不涉及任何全局变量。（函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。）</p>
<p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 <code>main()</code> 返回还是对 <code>exit()</code> 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 <code>string</code> 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>改善以上析构问题的办法之一是用 <code>quick_exit()</code> 来代替 <code>exit()</code> 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 <code>atexit()</code> 所绑定的任何 handlers. 如果您想在执行 <code>quick_exit()</code> 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 <code>_at_quick_exit()</code>. 如果您想在 <code>exit()</code> 和 <code>quick_exit()</code> 都用上该 handler, 都绑定上去。</p>
<p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 <code>vector</code> (使用 C 数组替代) 和 <code>string</code> (使用 <code>const char []</code>)。</p>
<p>如果您确实需要一个 <code>class</code> 类型的静态或全局变量，可以考虑在 <code>main()</code> 函数或 <code>pthread_once()</code> 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p>
<blockquote>
<p>Note: 上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</p>
</blockquote>
<p>译者 (YuleFox) 笔记</p>
<ol>
<li><code>cc</code> 中的匿名名字空间可避免命名冲突, 限定作用域, 避免直接使用 <code>using</code> 关键字污染命名空间;</li>
<li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code>public</code>;</li>
<li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</li>
<li>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</li>
<li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</li>
</ol>
<p>译者（acgtyrant）笔记</p>
<ol>
<li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li>
<li>匿名名字空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li>
<li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li>
<li>注意别在循环犯大量构造和析构的低级错误。</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.</p>
<h3 id="构造函数的职责"><a href="#构造函数的职责" class="headerlink" title="构造函数的职责"></a>构造函数的职责</h3><blockquote>
<p>不要在构造函数中进行复杂的初始化 (尤其是那些有可能失败或者需要调用虚函数的初始化).</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>在构造函数体中进行初始化操作.</p>
<p><strong>优点:</strong></p>
<p>排版方便, 无需担心类是否已经初始化.</p>
<p><strong>缺点:</strong></p>
<p>在构造函数中执行操作引起的问题有:</p>
<ul>
<li>构造函数中很难上报错误, 不能使用异常.</li>
<li>操作失败会造成对象初始化失败，进入不确定状态.</li>
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</li>
<li>如果有人创建该类型的全局变量 (虽然违背了上节提到的规则), 构造函数将先 main() 一步被调用, 有可能破坏构造函数中暗含的假设条件. 例如, gflags 尚未初始化.</li>
</ul>
<p><strong>结论:</strong></p>
<p>构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 <code>Init()</code> 方法或使用工厂模式.</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote>
<p>如果类中定义了成员变量, 则必须在类中为每个类提供初始化函数或定义一个构造函数. 若未声明构造函数, 则编译器会生成一个默认的构造函数, 这有可能导致某些成员未被初始化或被初始化为不恰当的值.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p><code>new</code> 一个不带参数的类对象时, 会调用这个类的默认构造函数. 用 <code>new[]</code> 创建数组时, 默认构造函数则总是被调用. 在类成员里面进行初始化是指声明一个成员变量的时候使用一个结构例如 <code>int _count = 17</code> 或者 <code>string _name{&quot;abc&quot;}</code> 来替代 <code>int _count</code> 或者 <code>string _name</code> 这样的形式.</p>
<p><strong>优点:</strong></p>
<p>用户定义的默认构造函数将在没有提供初始化操作时将对象初始化. 这样就保证了对象在被构造之时就处于一个有效且可用的状态, 同时保证了对象在被创建时就处于一个显然”不可能”的状态, 以此帮助调试.</p>
<p><strong>缺点:</strong></p>
<p>对代码编写者来说, 这是多余的工作.</p>
<p>如果一个成员变量在声明时初始化又在构造函数中初始化, 有可能造成混乱, 因为构造函数中的值会覆盖掉声明中的值.</p>
<p><strong>结论:</strong></p>
<p>简单的初始化用类成员初始化完成, 尤其是当一个成员变量要在多个构造函数里用相同的方式初始化的时候.</p>
<p>如果你的类中有成员变量没有在类里面进行初始化, 而且没有提供其它构造函数, 你必须定义一个 (不带参数的) 默认构造函数. 把对象的内部状态初始化成一致 / 有效的值无疑是更合理的方式.</p>
<p>这么做的原因是: 如果你没有提供其它构造函数, 又没有定义默认构造函数, 编译器将为你自动生成一个. 编译器生成的构造函数并不会对对象进行合理的初始化.</p>
<p>如果你定义的类继承现有类, 而你又没有增加新的成员变量, 则不需要为新类定义默认构造函数.</p>
<h3 id="显式构造函数"><a href="#显式构造函数" class="headerlink" title="显式构造函数"></a>显式构造函数</h3><blockquote>
<p>对单个参数的构造函数使用 C++ 关键字 <code>explicit</code>.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>通常, 如果构造函数只有一个参数, 可看成是一种隐式转换. 打个比方, 如果你定义了 <code>Foo::Foo(string name)</code>, 接着把一个字符串传给一个以 <code>Foo</code> 对象为参数的函数, 构造函数 <code>Foo::Foo(string name)</code> 将被调用, 并将该字符串转换为一个 <code>Foo</code> 的临时对象传给调用函数. 看上去很方便, 但如果你并不希望如此通过转换生成一个新对象的话, 麻烦也随之而来. 为避免构造函数被调用造成隐式转换, 可以将其声明为 <code>explicit.</code></p>
<p>除单参数构造函数外, 这一规则也适用于除第一个参数以外的其他参数都具有默认参数的构造函数, 例如 <code>Foo::Foo(string name, int id = 42)</code>.</p>
<p><strong>优点:</strong></p>
<p>避免不合时宜的变换.</p>
<p><strong>缺点:</strong></p>
<p>无</p>
<p><strong>结论:</strong></p>
<p>所有单参数构造函数都必须是显式的. 在类定义中, 将关键字 <code>explicit</code> 加到单参数构造函数前: <code>explicit Foo(string name);</code></p>
<p>例外: 在极少数情况下, 拷贝构造函数可以不声明成 <code>explicit</code>. 作为其它类的透明包装器的类也是特例之一. 类似的例外情况应在注释中明确说明.</p>
<p>最后, 只有 std::initializer_list 的构造函数可以是非 explicit, 以允许你的类型结构可以使用列表初始化的方式进行赋值. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType m = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line"><span class="function">MyType <span class="title">MakeMyType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; &#125;</div><div class="line">TakeMyType(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</div></pre></td></tr></table></figure>
<h3 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h3><blockquote>
<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. string 类型就是一个可拷贝类型的例子.</p>
<p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). std::unique_ptr<int> 就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的.</int></p>
<p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.</p>
<p><strong>优点:</strong></p>
<p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器.</p>
<p>拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如 Clone(), CopyFrom() or Swap(), 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过 = 默认. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似省略不必要的拷贝这样的优化它们也更加合适.</p>
<p>移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰.</p>
<p><strong>缺点:</strong></p>
<p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成对象切割. 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误.</p>
<p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.<br>结论:</p>
<p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p>
<p>建议通过 <code>= default</code> 定义拷贝和移动操作. 定义非默认的移动操作目前需要异常. 时刻记得检测默认操作的正确性. 由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <code>public virtual Clone()</code> 和一个 <code>protected</code> 的拷贝构造函数以供派生类实现.</p>
<p>如果你的类不需要拷贝 / 移动操作, 请显式地通过 <code>= delete</code> 或其他手段禁用之.</p>
<h3 id="委派和继承构造函数"><a href="#委派和继承构造函数" class="headerlink" title="委派和继承构造函数"></a>委派和继承构造函数</h3><blockquote>
<p>在能够减少重复代码的情况下使用委派和继承构造函数.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>委派和继承构造函数是由 C++11 引进为了减少构造函数重复代码而开发的两种不同的特性. 通过特殊的初始化列表语法, 委派构造函数允许类的一个构造函数调用其他的构造函数. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">X::X(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name) : name_(name) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">X::X() : X(<span class="string">""</span>) &#123; &#125;</div></pre></td></tr></table></figure>
<p>继承构造函数允许派生类直接调用基类的构造函数, 一如继承基类的其他成员函数, 而无需重新声明. 当基类拥有多个构造函数时这一功能尤其有用. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Base &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Base();</div><div class="line">  Base(<span class="keyword">int</span> n);</div><div class="line">  Base(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s);</div><div class="line">  ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> Base::Base;  <span class="comment">// Base's constructors are redeclared here.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果派生类的构造函数只是调用基类的构造函数而没有其他行为时, 这一功能特别有用.</p>
<p><strong>优点:</strong></p>
<p>委派和继承构造函数可以减少冗余代码, 提高可读性. 委派构造函数对 Java 程序员来说并不陌生.</p>
<p><strong>缺点:</strong></p>
<p>使用辅助函数可以预估出委派构造函数的行为. 如果派生类和基类相比引入了新的成员变量, 继承构造函数就会让人迷惑, 因为基类并不知道这些新的成员变量的存在.</p>
<p><strong>结论:</strong></p>
<p>只在能够减少冗余代码, 提高可读性的前提下使用委派和继承构造函数. 如果派生类有新的成员变量, 那么使用继承构造函数时要小心. 如果在派生类中对成员变量使用了类内部初始化的话, 继承构造函数还是适用的.</p>
<h3 id="结构体-VS-类"><a href="#结构体-VS-类" class="headerlink" title="结构体 VS. 类"></a>结构体 VS. 类</h3><blockquote>
<p>仅当只有数据时使用 <code>struct</code>, 其它一概使用 <code>class</code>.</p>
</blockquote>
<p><strong>说明:</strong></p>
<p>在 C++ 中 struct 和 class 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便未定义的数据类型选择合适的关键字.</p>
<p>struct 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, Initialize(), Reset(), Validate() 等类似的函数外, 不能提供其它功能的函数.</p>
<p>如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class.</p>
<p>为了和 STL 保持一致, 对于仿函数和 trait 特性可以不用 class 而是使用 struct.</p>
<p>注意: 类和结构体的成员变量使用不同的命名规则.</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>使用组合 (composition, YuleFox 注: 这一点也是 GoF 在 &lt;<design patterns="">&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 <code>public</code> 继承.</design></p>
</blockquote>
<p><strong>定义:</strong></p>
<p>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承 (implementation inheritance), 子类继承父类的实现代码; 接口继承 (interface inheritance), 子类仅继承父类的方法名称.</p>
<p><strong>优点:</strong></p>
<p>实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.</p>
<p><strong>缺点:</strong></p>
<p>对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 还要区分基类的实际布局.</p>
<p><strong>结论:</strong></p>
<p>所有继承必须是 <code>public</code> 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p>
<p>不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 <code>Bar</code> 的确 “是一种” Foo, <code>Bar</code> 才能继承 <code>Foo</code>.</p>
<p>必要的话, 析构函数声明为 <code>virtual</code>. 如果你的类有虚函数, 则析构函数也应该为虚函数. 注意 数据成员在任何情况下都必须是私有的.</p>
<p>当重载一个虚函数, 在衍生类中把它明确的声明为 <code>virtual</code>. 理论依据: 如果省略 <code>virtual</code> 关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><blockquote>
<p>真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code>Interface</code> 为后缀的 纯接口类.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>多重继承允许子类拥有多个基类. 要将作为 纯接口 的基类和具有 实现 的基类区别开来.</p>
<p><strong>优点:</strong></p>
<p>相比单继承 (见 继承), 多重实现继承可以复用更多的代码.<br>缺点:</p>
<p>真正需要用到多重 实现 继承的情况少之又少. 多重实现继承看上去是不错的解决方案, 但你通常也可以找到一个更明确, 更清晰的不同解决方案.</p>
<p><strong>结论:</strong></p>
<p>只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀.</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote>
<p>接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制).</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>当一个类满足以下要求时, 称之为纯接口:</p>
<ul>
<li>只有纯虚函数 (“<code>=0</code>”) 和静态函数 (除了下文提到的析构函数).</li>
<li>没有非静态数据成员.</li>
<li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为  <code>protected</code>.</li>
<li>如果它是一个子类, 也只能从满足上述条件并以 <code>Interface</code> 为后缀的类继承.</li>
</ul>
<p>接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 The C++ Programming Language, 3rd edition 第 12.4 节.</p>
<p><strong>优点:</strong></p>
<p>以 <code>Interface</code> 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 多重继承 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</p>
<p><strong>缺点:</strong></p>
<p><code>Interface</code> 后缀增加了类名长度, 为阅读和理解带来不便. 同时，接口特性作为实现细节不应暴露给用户.</p>
<p><strong>结论:</strong></p>
<p>只有在满足上述需要时, 类才以 <code>Interface</code> 结尾, 但反过来, 满足上述需要的类未必一定以 <code>Interface</code> 结尾.</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote>
<p>除少数特定环境外，不要重载运算符.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>一个类可以定义诸如 <code>+</code> 和 <code>/</code> 等运算符, 使其可以像内建类型一样直接操作.</p>
<p><strong>优点:</strong></p>
<p>使代码看上去更加直观, 类表现的和内建类型 (如 int) 行为一致. 重载运算符使 <code>Equals()</code>, <code>Add()</code> 等函数名黯然失色. 为了使一些模板函数正确工作, 你可能必须定义操作符.</p>
<p><strong>缺点:</strong></p>
<p>虽然操作符重载令代码更加直观, 但也有一些不足:</p>
<ul>
<li>混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.</li>
<li>更难定位重载运算符的调用点, 查找 <code>Equals()</code> 显然比对应的 <code>==</code> 调用点要容易的多.</li>
<li>有的运算符可以对指针进行操作, 容易导致 bug. <code>Foo + 4</code> 做的是一件事, 而 <code>&amp;Foo + 4</code> 可能做的是完全不同的另一件事. 对于二者, 编译器都不会报错, 使其很难调试;</li>
<li>重载还有令你吃惊的副作用. 比如, 重载了 <code>operator&amp;</code> 的类不能被前置声明.</li>
</ul>
<p><strong>结论:</strong></p>
<p>一般不要重载运算符. 尤其是赋值操作 (<code>operator=</code>) 比较诡异, 应避免重载. 如果需要的话, 可以定义类似 <code>Equals()</code>, <code>CopyFrom()</code> 等函数.</p>
<p>然而, 极少数情况下可能需要重载运算符以便与模板或 “标准” C++ 类互操作 (如 <code>operator&lt;&lt;(ostream&amp;, const T&amp;)</code>). 只有被证明是完全合理的才能重载, 但你还是要尽可能避免这样做. 尤其是不要仅仅为了在 STL 容器中用作键值就重载 <code>operator==</code> 或 <code>operator&lt;</code>; 相反, 你应该在声明容器的时候, 创建相等判断和大小比较的仿函数类型.</p>
<p>有些 STL 算法确实需要重载 <code>operator==</code> 时, 你可以这么做, 记得别忘了在文档中说明原因.</p>
<p>参考 拷贝构造函数 和 函数重载.</p>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><blockquote>
<p>将 所有 数据成员声明为 <code>private</code>, 并根据需要提供相应的存取函数. 例如, 某个名为 <code>foo_</code> 的变量, 其取值函数是 <code>foo()</code>. 还可能需要一个赋值函数 <code>set_foo()</code>.</p>
</blockquote>
<p>特例是, 静态常量数据成员 (一般写做 kFoo) 不需要是私有成员.</p>
<p>一般在头文件中把存取函数定义成内联函数.</p>
<p>参考 继承 和 函数命名</p>
<h3 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h3><blockquote>
<p>在类中使用特定的声明顺序: <code>public:</code> 在 <code>private:</code> 之前, 成员函数在数据成员 (变量) 前;</p>
</blockquote>
<p>类的访问控制区段的声明顺序依次为: <code>public:</code>, <code>protected:</code>, <code>private:</code>. 如果某区段没内容, 可以不声明.</p>
<p>每个区段内的声明通常按以下顺序:</p>
<ul>
<li><code>typedefs</code> 和枚举</li>
<li>常量</li>
<li>构造函数</li>
<li>析构函数</li>
<li>成员函数, 含静态成员函数</li>
<li>数据成员, 含静态数据成员</li>
</ul>
<p>友元声明应该放在 <code>private</code> 区段. 如果用宏 <code>DISALLOW_COPY_AND_ASSIGN</code> 禁用拷贝和赋值, 应当将其置于 <code>private</code> 区段的末尾, 也即整个类声明的末尾. 参见可拷贝类型和可移动类型.</p>
<p><code>.cc</code> 文件中函数的定义应尽可能和声明顺序一致.</p>
<p>不要在类定义中内联大型函数. 通常, 只有那些没有特别意义或性能要求高, 并且是比较短小的函数才能被定义为内联函数. 更多细节参考 内联函数.</p>
<h3 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h3><blockquote>
<p>倾向编写简短, 凝练的函数.</p>
</blockquote>
<p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
<p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题. 甚至导致难以发现的 bug. 使函数尽量简短, 便于他人阅读和修改代码.</p>
<p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试困难, 或者你需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p>
<p><strong>译者 (YuleFox) 笔记</strong></p>
<ol>
<li>不在构造函数中做太多逻辑相关的初始化;</li>
<li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;</li>
<li>为避免隐式转换, 需将单参数构造函数声明为 <code>explicit</code>;</li>
<li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 <code>private</code> 且无需实现;</li>
<li>仅在作为数据集合时使用 <code>struct</code>;</li>
<li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 <code>virtual</code> 关键字, 虽然编译器允许不这样做;</li>
<li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;</li>
<li>接口类类名以 <code>Interface</code> 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话，声明为 <code>protected</code>;</li>
<li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;</li>
<li>存取函数一般内联在头文件中;</li>
<li>声明次序: <code>public</code> -&gt; <code>protected</code> -&gt; <code>private</code>;</li>
<li>函数体尽量短小, 紧凑, 功能单一;</li>
</ol>
<h2 id="其他-C-特性"><a href="#其他-C-特性" class="headerlink" title="其他 C++ 特性"></a>其他 C++ 特性</h2><h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><blockquote>
<p>所有按引用传递的参数必须加上 const.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明引用参数: <code>int foo(int &amp;val)</code>.</p>
<p><strong>优点:</strong></p>
<p>定义引用参数防止出现 <code>(*pval)++</code> 这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 <code>NULL</code> 指针.</p>
<p><strong>缺点:</strong></p>
<p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
<p><strong>结论:</strong></p>
<p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;in, <span class="built_in">string</span> *out)</span></span>;</div></pre></td></tr></table></figure>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code>const</code> 引用, 输出参数为指针. 输入参数可以是 <code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数，除非用于交换，比如 <code>swap()</code>.</p>
<p>有时候，在输入形参中用 <code>const T*</code> 指针比 <code>const T&amp;</code> 更明智。比如：</p>
<ul>
<li>您会传 null 指针。</li>
<li>函数要把指针或对地址的引用赋值给输入形参。</li>
</ul>
<p>总之大多时候输入形参往往是 <code>const T&amp;</code>. 若用 <code>const T*</code> 说明输入另有处理。所以若您要用 <code>const T*</code>, 则应有理有据，否则会害得读者误解。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><blockquote>
<p>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 <code>std::forward</code>.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, <code>void f(string&amp;&amp; s)</code>; 声明了一个其参数是一个字符串的右值引用的函数.</p>
<p><strong>优点:</strong></p>
<p>用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果 <code>v1</code> 是一个 <code>vector&lt;string&gt;</code>, 则 <code>auto v2(std::move(v1))</code> 将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升.</p>
<p>右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能, 无论其参数是否是临时对象都能正常工作.</p>
<p>右值引用能实现可移动但不可拷贝的类型, 这一特性对那些在拷贝方面没有实际需求, 但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.</p>
<p>要高效率地使用某些标准库类型, 例如 <code>std::unique_ptr</code>, <code>std::move</code> 是必需的.</p>
<p><strong>缺点:</strong></p>
<p>右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</p>
<p><strong>结论:</strong></p>
<p>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 <code>std::forward</code> 功能函数. 你可能会使用 <code>std::move</code> 来表示将值从一个对象移动而不是复制到另一个对象.</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><blockquote>
<p>若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数, 然后用另一个参数类型为 <code>const char*</code> 的函数重载它:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> MyClass &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;text)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *text, <span class="keyword">size_t</span> textlen)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>优点:</strong></p>
<p>通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利.</p>
<p><strong>缺点:</strong></p>
<p>如果函数单单靠不同的参数类型而重载（acgtyrant 注：这意味着参数数量不变），读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。</p>
<p><strong>结论:</strong></p>
<p>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等， 而不是一口气重载多个 <code>Append()</code>.</p>
<h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><blockquote>
<p>我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p>
</blockquote>
<p><strong>优点:</strong></p>
<p>当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</p>
<p><strong>缺点:</strong></p>
<p>缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复（acgtyrant 注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</p>
<p><strong>结论:</strong></p>
<p>由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数（acgtyrant 注：即不能再通过缺省参数来省略参数了）。</p>
<p>其一，位于 <code>.cc</code> 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</p>
<p>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</p>
<p>其三，可以用来模拟变长数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 通过空 AlphaNum 以支持四个形参</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">StrCat</span><span class="params">(<span class="keyword">const</span> AlphaNum &amp;a,</span></span></div><div class="line">              <span class="keyword">const</span> AlphaNum &amp;b = gEmptyAlphaNum,</div><div class="line">              <span class="keyword">const</span> AlphaNum &amp;c = gEmptyAlphaNum,</div><div class="line">              <span class="keyword">const</span> AlphaNum &amp;d = gEmptyAlphaNum);</div></pre></td></tr></table></figure>
<h3 id="变长数组和-alloca"><a href="#变长数组和-alloca" class="headerlink" title="变长数组和 alloca()"></a>变长数组和 <code>alloca()</code></h3><blockquote>
<p>我们不允许使用变长数组和 <code>alloca()</code>.</p>
</blockquote>
<p><strong>优点:</strong></p>
<p>变长数组具有浑然天成的语法. 变长数组和 <code>alloca()</code> 也都很高效.</p>
<p><strong>缺点:</strong></p>
<p>变长数组和 <code>alloca()</code> 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.</p>
<p><strong>结论:</strong></p>
<p>改用更安全的分配器（allocator），就像 <code>std::vector</code> 或 <code>std::unique_ptr&lt;T[]&gt;</code>.</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><blockquote>
<p>我们允许合理的使用友元类及友元函数.</p>
</blockquote>
<p>通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 <code>FooBuilder</code> 声明为 <code>Foo</code> 的友元, 以便 <code>FooBuilder</code> 正确构造 <code>Foo</code> 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.</p>
<p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 <code>public</code>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><blockquote>
<p>我们不使用 C++ 异常.</p>
</blockquote>
<p><strong>优点:</strong></p>
<ul>
<li>异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant 注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。</li>
<li>很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类 C++ 的语言更一脉相承。</li>
<li>有些第三方 C++ 库依赖异常，禁用异常就不好用了。</li>
<li>异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant 注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或 <code>Init()</code> 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态。</li>
<li>在测试框架里很好用。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>在现有函数中添加 <code>throw</code> 语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，<code>f()</code> 调用 <code>g()</code>, <code>g()</code> 又调用 <code>h()</code>, 且 <code>h</code> 抛出的异常被 <code>f</code> 捕获。当心 <code>g</code>, 否则会没妥善清理好。</li>
<li>还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。</li>
<li>异常安全需要RAII和不同的编码实践. 要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说, 为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交” 状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得.</li>
<li>启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。</li>
<li>滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。</li>
</ul>
<p><strong>结论:</strong></p>
<p>从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p>
<p>鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.</p>
<p>我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p>
<p>对于 Windows 代码来说, 有个 特例.</p>
<p>(YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的, 以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理, Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定)</p>
<h3 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h3><blockquote>
<p>我们禁止使用 RTTI.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 <code>typeid</code> 或者 <code>dynamic_cast</code> 完成.</p>
<p><strong>优点:</strong></p>
<p>RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中.</p>
<p>RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用.</p>
<p>在考虑多个抽象对象时 RTTI 也很好用. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> Base::Equal(Base* other) = <span class="number">0</span>;</div><div class="line"><span class="keyword">bool</span> Derived::Equal(Base* other) &#123;</div><div class="line">  Derived* that = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(other);</div><div class="line">  <span class="keyword">if</span> (that == <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>缺点:</strong></p>
<p>在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</p>
<p>随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 <code>switch</code> 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p>
<p><strong>结论:</strong></p>
<p>RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:</p>
<p>虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.</p>
<p>如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行类型判断.</p>
<p>如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 <code>dynamic_cast</code>. 在这种情况下, 使用 <code>dynamic_cast</code> 也是一种替代方案.</p>
<p>基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*data) == <span class="keyword">typeid</span>(D1)) &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeid</span>(*data) == <span class="keyword">typeid</span>(D2)) &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeid</span>(*data) == <span class="keyword">typeid</span>(D3)) &#123;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p>
<p>不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图.</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><blockquote>
<p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用 <code>int y = (int)x</code> 或 <code>int y = int(x)</code> 等转换方式;</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</p>
<p><strong>优点:</strong></p>
<p>C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 <code>(int)3.5</code>), 有时是在做类型转换 (如 <code>(int)&quot;hello&quot;</code>). 另外, C++ 的类型转换在查找时更醒目.</p>
<p><strong>缺点:</strong></p>
<p>恶心的语法.</p>
<p><strong>结论:</strong></p>
<p>不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p>
<ul>
<li>用 <code>static_cast</code> 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</li>
<li>用 <code>const_cast</code> 去掉 <code>const</code> 限定符.</li>
<li>用 <code>reinterpret_cast</code> 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</li>
</ul>
<p>至于 <code>dynamic_cast</code> 参见 运行时类型识别.</p>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><blockquote>
<p>只在记录日志时使用流.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>流用来替代 <code>printf()</code> 和 <code>scanf()</code>.</p>
<p><strong>优点:</strong></p>
<p>有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 <code>printf</code> 也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.</p>
<p><strong>缺点:</strong></p>
<p>流使得 <code>pread()</code> 等功能函数很难执行. 如果不使用 <code>printf</code> 风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 <code>%.*s</code>) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (<code>%1s</code>), 而这一点对于软件国际化很有用.</p>
<p><strong>结论:</strong></p>
<p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code> 之类的代替.</p>
<p>使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p>
<p><strong>拓展讨论:</strong></p>
<p>对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是 <code>printf + read/write</code>. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p>
<p>流的支持者们主张流是不二之选, 但观点并不是那么清晰有力. 他们指出的流的每个优势也都是其劣势. 流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警. 使用流时容易造成的这类错误:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>;   <span class="comment">// 输出地址</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; *<span class="keyword">this</span>;  <span class="comment">// 输出值</span></div></pre></td></tr></table></figure>
<p>由于 <code>&lt;&lt;</code> 被重载, 编译器不会报错. 就因为这一点我们反对使用操作符重载.</p>
<p>有人说 <code>printf</code> 的格式化丑陋不堪, 易读性差, 但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error connecting to '"</span> &lt;&lt; foo-&gt;bar()-&gt;hostname.first</div><div class="line">     &lt;&lt; <span class="string">":"</span> &lt;&lt; foo-&gt;bar()-&gt;hostname.second &lt;&lt; <span class="string">": "</span> &lt;&lt; strerror(errno);</div><div class="line"></div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error connecting to '%s:%u: %s"</span>,</div><div class="line">        foo-&gt;bar()-&gt;hostname.first, foo-&gt;bar()-&gt;hostname.second,</div><div class="line">        strerror(errno));</div></pre></td></tr></table></figure>
<p>你可能会说, “把流封装一下就会比较好了”, 这儿可以, 其他地方呢? 而且不要忘了, 我们的目标是使语言更紧凑, 而不是添加一些别人需要学习的新装备.</p>
<p>每一种方式都是各有利弊, “没有最好, 只有更适合”. 简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 <code>printf + read/write</code>.</p>
<h3 id="前置自增和自减"><a href="#前置自增和自减" class="headerlink" title="前置自增和自减"></a>前置自增和自减</h3><blockquote>
<p>对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>对于变量在自增 (++i 或 i++) 或自减 (–i 或 i–) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).</p>
<p><strong>优点:</strong></p>
<p>不考虑返回值的话, 前置自增 (++i) 通常要比后置自增 (i++) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝. 如果 i 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</p>
<p><strong>缺点:</strong></p>
<p>在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 for 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (i) 在谓语动词 (++) 前.</p>
<p><strong>结论:</strong></p>
<p>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</p>
<h3 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a><code>const</code> 用法</h3><blockquote>
<p>我们强烈建议你在任何可能的情况下都要使用 <code>const</code>. 此外有时改用 C++11 推出的 constexpr 更好。</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>在声明的变量或参数前加上关键字 <code>const</code> 用于指明变量值不可被篡改 (如 <code>const int foo</code> ). 为类中的函数加上 <code>const</code> 限定符表明该函数不会修改类成员变量的状态 (如 <code>class Foo { int Bar(char c) const; };</code>).</p>
<p><strong>优点:</strong></p>
<p>大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</p>
<p><strong>缺点:</strong></p>
<p><code>const</code> 是入侵性的: 如果你向一个函数传入 <code>const</code> 变量, 函数原型声明中也必须对应 <code>const</code> 参数 (否则变量需要 <code>const_cast</code> 类型转换), 在调用库函数时显得尤其麻烦.</p>
<p><strong>结论:</strong></p>
<p><code>const</code> 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 <code>const</code>:</p>
<ul>
<li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 <code>const</code>.</li>
<li>尽可能将函数声明为 <code>const</code>. 访问函数应该总是 <code>const</code>. 其他不会修改任何数据成员, 未调用非 <code>const</code> 函数, 不会返回数据成员非 <code>const</code> 指针或引用的函数也应该声明成 <code>const</code>.</li>
<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <code>const</code>.</li>
</ul>
<p>然而, 也不要发了疯似的使用 <code>const</code>. 像 <code>const int * const * const x;</code> 就有些过了, 虽然它非常精确的描述了常量 <code>x</code>. 关注真正有帮助意义的信息: 前面的例子写成 <code>const int** x</code> 就够了.</p>
<p>关键字 <code>mutable</code> 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.</p>
<p><code>const</code> 的位置:</p>
<p>有人喜欢 <code>int const *foo</code> 形式, 不喜欢 <code>const int* foo</code>, 他们认为前者更一致因此可读性也更好: 遵循了 <code>const</code> 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消大部分你原本想保持的一致性. 将 <code>const</code> 放在前面才更易读, 因为在自然语言中形容词 (<code>const</code>) 是在名词 (<code>int</code>) 之前.</p>
<p>这是说, 我们提倡但不强制 <code>const</code> 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把 <code>const</code> 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)</p>
<h3 id="constexpr-用法"><a href="#constexpr-用法" class="headerlink" title="constexpr 用法"></a><code>constexpr</code> 用法</h3><blockquote>
<p>在 C++11 里，用 <code>constexpr</code> 来定义真正的常量，或实现常量初始化。</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>变量可以被声明成 <code>constexpr</code> 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 <code>constexpr</code>, 以用来定义 <code>constexpr</code> 变量。</p>
<p><strong>优点:</strong></p>
<p>如今 <code>constexpr</code> 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</p>
<p><strong>缺点:</strong></p>
<p>若过早把变量优化成 <code>constexpr</code> 变量，将来又要把它改为常规变量时，挺麻烦的；当前对 <code>constexpr</code> 函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</p>
<p><strong>结论:</strong></p>
<p>靠 <code>constexpr</code> 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 <code>constexpr</code> 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与 <code>constexpr</code> 一起使用。 千万别痴心妄想地想靠 <code>constexpr</code> 来强制代码「内联」。</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><blockquote>
<p>C++ 内建整型中, 仅使用 <code>int</code>. 如果程序中需要不同大小的变量, 可以使用 <code>&lt;stdint.h&gt;</code> 中长度精确的整型, 如 <code>int16_t</code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 <code>int64_t</code>. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。<br>定义:</p>
</blockquote>
<p>C++ 没有指定整型的大小. 通常人们假定 <code>short</code> 是 16 位, <code>int</code> 是 32 位, <code>long</code>是 32 位, <code>long long</code> 是 64 位.</p>
<p><strong>优点:</strong></p>
<p>保持声明统一.</p>
<p><strong>缺点:</strong></p>
<p>C++ 中整型大小因编译器和体系结构的不同而不同.</p>
<p>结论:</p>
<p><code>&lt;stdint.h&gt;</code> 定义了 <code>int16_t</code>, <code>uint32_t</code>, <code>int64_t</code> 等整型, 在需要确保整型大小时可以使用它们代替 <code>short</code>, <code>unsigned long long</code> 等. 在 C 整型中, 只使用 int. 在合适的情况下, 推荐使用标准类型如 <code>size_t</code> 和 <code>ptrdiff_t</code>.</p>
<p>如果已知整数不会太大, 我们常常会使用 <code>int</code>, 如循环计数. 在类似的情况下使用原生类型 <code>int</code>. 你可以认为 <code>int</code> 至少为 32 位, 但不要认为它会多于 32 位. 如果需要 64 位整型, 用 <code>int64_t</code> 或 <code>uint64_t</code>.</p>
<p>对于大整数, 使用 <code>int64_t</code>.</p>
<p>不要使用 <code>uint32_t</code> 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p>
<p>如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。</p>
<p>小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 <code>int</code> 与 <code>unsigned int</code> 运算时，前者被提升为 <code>unsigned int</code> 而有可能溢出），总有意想不到的后果。</p>
<p>关于无符号整数:</p>
<p>有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = foo.Length()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) ...</div></pre></td></tr></table></figure>
<p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p>
<p>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p>
<h3 id="64-位下的可移植性"><a href="#64-位下的可移植性" class="headerlink" title="64 位下的可移植性"></a>64 位下的可移植性</h3><blockquote>
<p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:</p>
</blockquote>
<p>对于某些类型, <code>printf()</code> 的指示符在 32 位和 64 位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 <code>inttypes.h</code> 仿标准风格):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// printf macros for size_t, in the style of inttypes.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __PRIS_PREFIX <span class="meta-string">"z"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __PRIS_PREFIX</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// Use these macros after a % in a printf format string</span></div><div class="line"><span class="comment">// to get correct 32/64 bit behavior, like this:</span></div><div class="line"><span class="comment">// size_t size = records.size();</span></div><div class="line"><span class="comment">// printf("%"PRIuS"\n", size);</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIdS __PRIS_PREFIX <span class="meta-string">"d"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIxS __PRIS_PREFIX <span class="meta-string">"x"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIuS __PRIS_PREFIX <span class="meta-string">"u"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIXS __PRIS_PREFIX <span class="meta-string">"X"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIoS __PRIS_PREFIX <span class="meta-string">"o"</span></span></div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">不要使用</th>
<th style="text-align:center">使用</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>void *</code> (或其他指针类型)</td>
<td style="text-align:center"><code>%lx</code></td>
<td style="text-align:center"><code>%p</code></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>int64_t</code></td>
<td style="text-align:center"><code>%qd, %lld</code></td>
<td style="text-align:center"><code>%&quot;PRId64&quot;</code></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>uint64_t</code></td>
<td style="text-align:center"><code>%qu, %llu, %llx</code></td>
<td style="text-align:center"><code>%&quot;PRIu64&quot;, %&quot;PRIx64&quot;</code></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t</code></td>
<td style="text-align:center"><code>%u</code></td>
<td style="text-align:center"><code>%&quot;PRIuS&quot;, %&quot;PRIxS&quot;</code></td>
<td style="text-align:center">C99 规定 <code>%zu</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ptrdiff_t</code></td>
<td style="text-align:center"><code>%d</code></td>
<td style="text-align:center"><code>%&quot;PRIdS&quot;</code></td>
<td style="text-align:center">C99 规定 <code>%zd</code></td>
</tr>
</tbody>
</table>
<p>注意 <code>PRI*</code> 宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用 PRI* 宏同样可以在 <code>%</code> 后包含长度指示符. 例如, <code>printf(&quot;x = %30&quot;PRIuS&quot;\n&quot;, x)</code> 在 32 位 Linux 上将被展开为 <code>printf(&quot;x = %30&quot; &quot;u&quot; &quot;\n&quot;, x)</code>, 编译器当成 <code>printf(&quot;x = %30u\n&quot;, x)</code> 处理 (Yang.Y 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p>
<p>记住 <code>sizeof(void *) != sizeof(int)</code>. 如果需要一个指针大小的整数要用 <code>intptr_t</code>.</p>
<p>你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 <code>int64_t</code>/<code>uint64_t</code> 成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 <code>__attribute__((packed))</code>. MSVC 则提供了 <code>#pragma pack()</code> 和 <code>__declspec(align())</code> (YuleFox 注, 解决方案的项目属性里也可以直接设置).</p>
<p>创建 64 位常量时使用 <code>LL</code> 或 <code>ULL</code> 作为后缀, 如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int64_t</span> my_value = <span class="number">0</span>×<span class="number">123456789L</span>L;</div><div class="line"><span class="keyword">uint64_t</span> my_mask = <span class="number">3U</span>LL &lt;&lt; <span class="number">48</span>;</div></pre></td></tr></table></figure>
<p>如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 <code>#ifdef _LP64</code> 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化)</p>
<h3 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h3><blockquote>
<p>使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p>
</blockquote>
<p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.</p>
<p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被 <code>const</code> 变量代替. 用宏 “缩写” 长变量名可被引用代替. 用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦 (<code>#define</code> 防止头文件重包含当然是个特例).</p>
<p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 # 字符串化, 用 ## 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p>
<p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:</p>
<ul>
<li>不要在 <code>.h</code> 文件中定义宏.</li>
<li>在马上要使用时才进行 <code>#define</code>, 使用后要立即 <code>#undef</code>.</li>
<li>不要只是对已经存在的宏使用 <code>#undef</code>，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>
<li>不要用 <code>##</code> 处理函数，类和变量的名字。</li>
</ul>
<h3 id="0-nullptr-和-NULL"><a href="#0-nullptr-和-NULL" class="headerlink" title="0, nullptr 和 NULL"></a>0, <code>nullptr</code> 和 <code>NULL</code></h3><blockquote>
<p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>&#39;\0&#39;</code>.</p>
</blockquote>
<p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 这一点是毫无争议的.</p>
<p>对于指针 (地址值), 到底是用 <code>0</code>, <code>NULL</code> 还是 <code>nullptr</code>. C++11 项目用 <code>nullptr</code>; C++03 项目则用 <code>NULL</code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 <code>NULL</code> 的定义比较特殊，可以输出有用的警告，特别是 <code>sizeof(NULL)</code> 就和 <code>sizeof(0)</code> 不一样。</p>
<p>字符 (串) 用 <code>&#39;\0&#39;</code>, 不仅类型正确而且可读性好.</p>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><blockquote>
<p>尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</p>
</blockquote>
<p>使用 <code>sizeof(varname)</code> 是因为当代码中变量类型改变时会自动更新. 您或许会用 <code>sizeof(type)</code> 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Struct data;</div><div class="line">Struct data; <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(Struct));</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (raw_size &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</div><div class="line">    LOG(ERROR) &lt;&lt; <span class="string">"compressed record not big enough for count: "</span> &lt;&lt; raw_size;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><blockquote>
<p>用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>
</blockquote>
<p><strong>定义：</strong></p>
<p>C++11 中，若变量被声明成 <code>auto</code>, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用 <code>auto</code> 来复制初始化或绑定引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</div><div class="line">...</div><div class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>];  <span class="comment">// 创建一份 v[0] 的拷贝。</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>];  <span class="comment">// s2 是 v[0] 的一个引用。</span></div></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<p>C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">sparse_hash_map&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator iter = m.find(val);</div></pre></td></tr></table></figure>
<p>返回类型好难读，代码目的也不够一目了然。重构其：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> iter = m.find(val);</div></pre></td></tr></table></figure>
<p>好多了。</p>
<p>没有 <code>auto</code> 的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::ErrorStatus(<span class="string">"xyz"</span>);</div></pre></td></tr></table></figure>
<p>有了 <code>auto</code>, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p>
<p><strong>缺点：</strong></p>
<p>类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> i = x.Lookup(key);</div></pre></td></tr></table></figure>
<p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p>
<p>程序员必须会区分 <code>auto</code> 和 <code>const auto&amp;</code> 的不同之处，否则会复制错东西。</p>
<p><code>auto</code> 和 C++11 列表初始化的合体令人摸不着头脑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 圆括号。</span></div><div class="line"><span class="keyword">auto</span> y&#123;<span class="number">3</span>&#125;;  <span class="comment">// 大括号。</span></div></pre></td></tr></table></figure>
<p>它们不是同一回事——<code>x</code> 是 <code>int</code>, <code>y</code> 则是 <code>std::initializer_list&lt;int&gt;</code>. 其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types, 它涉及到 C++ 鲜为人知的坑：<a href="http://stackoverflow.com/a/17794965/1546088" target="_blank" rel="external">Why is vector<bool> not a STL container?</bool></a>）也有大同小异的陷阱。</p>
<p>如果在接口里用 <code>auto</code>, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。</p>
<p><strong>结论：</strong></p>
<p><code>auto</code> 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 <code>auto</code> 变量。</p>
<p><code>auto</code> 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><blockquote>
<p>你可以用列表初始化。</p>
</blockquote>
<p>早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> Point &#123; <span class="keyword">int</span> x; <span class="keyword">int</span> y; &#125;;</div><div class="line">Point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div></pre></td></tr></table></figure>
<p>C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Vector 接收了一个初始化列表。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v&#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 不考虑细节上的微妙差别，大致上相同。</span></div><div class="line"><span class="comment">// 您可以任选其一。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 可以配合 new 一起用。</span></div><div class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// map 接收了一些 pair, 列表初始化大显神威。</span></div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"2"</span>&#125;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 初始化列表也可以用在返回类型上的隐式转换。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test_function() &#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化列表可迭代。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在函数调用里用列表初始化。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFunction2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;&#125;</div><div class="line">TestFunction2(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</div></pre></td></tr></table></figure>
<p>用户自定义类型也可以定义接收 <code>std::initializer_list&lt;T&gt;</code> 的构造函数和赋值运算符，以自动列表初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> MyType &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// std::initializer_list 专门接收 init 列表。</span></div><div class="line">  <span class="comment">// 得以值传递。</span></div><div class="line">  MyType(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; init_list) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : init_list) append(i);</div><div class="line">  &#125;</div><div class="line">  MyType&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; init_list) &#123;</div><div class="line">    clear();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : init_list) append(i);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">MyType m&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</div></pre></td></tr></table></figure>
<p>最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收 <code>std::initializer_list&lt;T&gt;</code> 的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">double</span> d&#123;<span class="number">1.23</span>&#125;;</div><div class="line"><span class="comment">// MyOtherType 没有 std::initializer_list 构造函数，</span></div><div class="line"> <span class="comment">// 直接上接收常规类型的构造函数。</span></div><div class="line"><span class="keyword">class</span> MyOtherType &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyOtherType</span><span class="params">(<span class="built_in">string</span>)</span></span>;</div><div class="line">  MyOtherType(<span class="keyword">int</span>, <span class="built_in">string</span>);</div><div class="line">&#125;;</div><div class="line">MyOtherType m = &#123;<span class="number">1</span>, <span class="string">"b"</span>&#125;;</div><div class="line"><span class="comment">// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。</span></div><div class="line">MyOtherType m&#123;<span class="string">"b"</span>&#125;;</div></pre></td></tr></table></figure>
<p>千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;;        <span class="comment">// d 即是 std::initializer_list&lt;double&gt;</span></div><div class="line"><span class="keyword">auto</span> d = <span class="keyword">double</span>&#123;<span class="number">1.23</span>&#125;;  <span class="comment">// 善哉 -- d 即为 double, 并非 std::initializer_list.</span></div></pre></td></tr></table></figure>
<p>至于格式化，参见 braced-initializer-list-format.</p>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><blockquote>
<p>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p>
</blockquote>
<p><strong>定义：</strong></p>
<p>Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::sort(v.begin(), v.end(), [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</div><div class="line">    <span class="keyword">return</span> Weight(x) &lt; Weight(y);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>C++11 首次提出 Lambdas, 还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper） <code>std::function</code>.</p>
<p><strong>优点：</strong></p>
<ul>
<li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li>
<li>Lambdas, <code>std::functions</code> 和 <code>std::bind</code> 可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</li>
<li>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</li>
</ul>
<p><strong>结论：</strong></p>
<ul>
<li>按 format 小用 lambda 表达式怡情。</li>
<li>禁用默认捕获，捕获都要显式写出来。打比方，比起 <code>[=](int x) {return x + n;}</code>, 您该写成 <code>[n](int x) {return x + n;}</code> 才对，这样读者也好一眼看出 <code>n</code> 是被捕获的值。</li>
<li>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。</li>
<li>如果可读性更好，就显式写出 lambda 的尾置返回类型，就像 <code>auto</code>.</li>
</ul>
<h3 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h3><blockquote>
<p>不要使用复杂的模板编程</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>模板编程指的是利用 C++ 模板实例化机制是图灵完备性, 可以被用来实现编译时刻的类型判断的一系列编程技巧</p>
<p><strong>优点:</strong></p>
<p>模板编程能够实现非常灵活的类型安全的接口和极好的性能, 一些常见的工具比如 Google Test, <code>std::tuple</code>, <code>std::function</code> 和 <code>Boost.Spirit</code>. 这些工具如果没有模板是实现不了的</p>
<p><strong>缺点:</strong></p>
<ul>
<li>模板编程所使用的技巧对于使用 C++不是很熟练的人是比较晦涩, 难懂的. 在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和 维护起来都很麻烦</li>
<li>模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候, 即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示. 导致这个编译出错信息看起来非常难以理解.</li>
<li>大量的使用模板编程接口会让重构工具(Visual Assist X, Refactor for C++等等)更难发挥用途. 首先模板的代码会在很多上下文里面扩展开来, 所以很难确认重构对所有的这些展开的代码有用, 其次有些重构工具只对已经做过模板类型替换的代码的AST 有用. 因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构.</li>
</ul>
<p><strong>结论:</strong></p>
<ul>
<li>模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此模板编程最好只用在少量的基础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉</li>
<li>在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非 C++ 程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程. 如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板, 或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载, 那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用</li>
<li>如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴漏. 你最好只在实现里面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性. 并且你应该在这些使用模板的代码上写尽可能详细的注释. 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代码大概是什么样子的. 还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为这些出错信息也是你的接口的一部分, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解, 并且用户很容易知道如何修改这些错误</li>
</ul>
<h3 id="Boost-库"><a href="#Boost-库" class="headerlink" title="Boost 库"></a>Boost 库</h3><blockquote>
<p>只使用 Boost 中被认可的库.</p>
</blockquote>
<p><strong>定义:</strong></p>
<p>Boost 库集 是一个广受欢迎, 经过同行鉴定, 免费开源的 C++ 库集.</p>
<p><strong>优点:</strong></p>
<p>Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针。</p>
<p><strong>缺点:</strong></p>
<p>某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术, 以及过度 “函数化” 的编程风格.</p>
<p><strong>结论:</strong></p>
<p>为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前允许使用以下库:</p>
<ul>
<li>Call Traits : <code>boost/call_traits.hpp</code></li>
<li>Compressed Pair : <code>boost/compressed_pair.hpp</code></li>
<li>&lt;The Boost Graph Library (BGL) : <code>boost/graph</code>, except serialization (<code>adj_list_serialize.hpp</code>) and parallel/distributed algorithms and data structures(<code>boost/graph/parallel/*</code> and <code>boost/graph/distributed/*</code>)</li>
<li>Property Map : <code>boost/property_map.hpp</code></li>
<li>The part of Iterator that deals with defining iterators: <code>boost/iterator/iterator_adaptor.hpp</code>, <code>boost/iterator/iterator_facade.hpp</code>, and <code>boost/function_output_iterator.hpp</code></li>
<li>The part of Polygon that deals with Voronoi diagram construction and doesn’t depend on the rest of Polygon: <code>boost/polygon/voronoi_builder.hpp</code>, <code>boost/polygon/voronoi_diagram.hpp</code>, and <code>boost/polygon/voronoi_geometry_type.hpp</code></li>
<li>Bimap : <code>boost/bimap</code></li>
<li>Statistical Distributions and Functions : <code>boost/math/distributions</code></li>
<li>Multi-index : <code>boost/multi_index</code></li>
<li>Heap : <code>boost/heap</code></li>
<li>The flat containers from Container: <code>boost/container/flat_map</code>, and <code>boost/container/flat_set</code></li>
</ul>
<p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p>
<p>以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：</p>
<ul>
<li>Pointer Container : <code>boost/ptr_container</code>, 改用 std::unique_ptr</li>
<li>Array : <code>boost/array.hpp</code>, 改用 std::array</li>
</ul>
<h3 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h3><blockquote>
<p>适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。</p>
</blockquote>
<p><strong>定义：</strong></p>
<p>C++11 有众多语言和库上的<a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="external">变革</a>。</p>
<p><strong>优点：</strong></p>
<p>在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++ 编译器支持。它标准化很多我们早先就在用的 C++ 扩展，简化了不少操作，大大改善了性能和安全。</p>
<p><strong>缺点：</strong></p>
<p>C++11 相对于前身，复杂极了：1300 页 vs 800 页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。</p>
<p>和 Boost 库 一样，有些 C++11 扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。</p>
<p><strong>缺点：</strong></p>
<p>C++11 特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11 特性之外，以下特性最好不要用：</p>
<ul>
<li>尾置返回类型，比如用 <code>auto foo() -&gt; int</code> 代替 <code>int foo()</code>. 为了兼容于现有代码的声明风格。</li>
<li>编译时合数 <code>&lt;ratio&gt;</code>, 因为它涉及一个重模板的接口风格。</li>
<li><code>&lt;cfenv&gt;</code> 和 <code>&lt;fenv.h&gt;</code> 头文件，因为编译器尚不支持。</li>
<li>默认 lambda 捕获。</li>
</ul>
<p>译者（acgtyrant）笔记</p>
<ol>
<li>实际上，<a href="http://www.zhihu.com/question/24439516/answer/27858964" target="_blank" rel="external">缺省参数会改变函数签名的前提是改变了它接收的参数数量</a>，比如把 <code>void a()</code> 改成 <code>void a(int b = 0)</code>, 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li>
<li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li>
<li>我还发现 <a href="http://www.zhihu.com/question/24439516/answer/27896004" target="_blank" rel="external">滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少</a>。</li>
<li><code>friend</code> 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 <code>.cc</code> 文件加以定义。</li>
<li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li>
<li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考 声明顺序 。</li>
<li><a href="http://www.zhihu.com/question/22889420" target="_blank" rel="external">对使用 C++ 异常处理应具有怎样的态度？</a> 非常值得一读。</li>
<li>注意初始化 <code>const</code> 对象时，必须在初始化的同时值初始化。</li>
<li>用断言代替无符号整型类型，深有启发。</li>
<li><code>auto</code> 在涉及迭代器的循环语句里挺常用。</li>
<li><a href="http://stackoverflow.com/questions/11215227/should-the-trailing-return-type-syntax-style-become-the-default-for-new-c11-pr" target="_blank" rel="external">Should the trailing return type syntax style become the default for new C++11 programs?</a> 讨论了 auto 与尾置返回类型一起用的全新编码风格，值得一看。</li>
</ol>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>最重要的一致性规则是命名管理. 命名风格快速获知名字代表是什么东东: 类型? 变量? 函数? 常量? 宏 … ? 甚至不需要去查找类型声明. 我们大脑中的模式匹配引擎可以非常可靠的处理这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重, 所以不管你怎么想, 规则总归是规则.</p>
<h3 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h3><blockquote>
<p>函数命名，变量命名，文件命名要有描述性；少用缩写。</p>
</blockquote>
<p>尽可能给有描述性的命名，别心疼空间，毕竟让代码易于新读者理解很重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> price_count_reader;    <span class="comment">// 无缩写</span></div><div class="line"><span class="keyword">int</span> num_errors;            <span class="comment">// “num” 本来就很常见</span></div><div class="line"><span class="keyword">int</span> num_dns_connections;   <span class="comment">// 人人都知道 “DNS” 是啥</span></div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> n;                     <span class="comment">// 莫名其妙。</span></div><div class="line"><span class="keyword">int</span> nerr;                  <span class="comment">// 怪缩写。</span></div><div class="line"><span class="keyword">int</span> n_comp_conns;          <span class="comment">// 怪缩写。</span></div><div class="line"><span class="keyword">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是啥意思。</span></div><div class="line"><span class="keyword">int</span> pc_reader;             <span class="comment">// "pc" 有太多可能的解释了。</span></div><div class="line"><span class="keyword">int</span> cstmr_id;              <span class="comment">// 有删减若干字母。</span></div></pre></td></tr></table></figure>
<h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><blockquote>
<p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>). 按项目约定来. 如果并没有项目约定，<code>_</code> 更好。</p>
</blockquote>
<p>可接受的文件命名:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">* my_useful_class.cc</div><div class="line">* my-useful-<span class="keyword">class</span>.cc</div><div class="line">* myusefulclass.cc</div><div class="line">* muusefulclass_test.cc <span class="comment">// ``_unittest`` 和 ``_regtest`` 已弃用。</span></div></pre></td></tr></table></figure>
<p>C++ 文件要以 <code>.cc</code> 结尾, 头文件以 <code>.h</code> 结尾. 专门插入文本的文件则以 <code>.inc</code> 结尾，参见 Self-contained 头文件。</p>
<p>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 <code>db.h</code>.</p>
<p>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比 <code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类 <code>FooBar</code>.</p>
<p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短, 就直接放在 <code>.h</code> 中.</p>
<h3 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h3><blockquote>
<p>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p>
</blockquote>
<p>所有类型命名 —— 类, 结构体, 类型定义 (<code>typedef</code>), 枚举 —— 均使用相同约定. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// classes and structs</span></div><div class="line"><span class="keyword">class</span> UrlTable &#123; ...</div><div class="line"><span class="keyword">class</span> UrlTableTester &#123; ...</div><div class="line"><span class="keyword">struct</span> UrlTableProperties &#123; ...</div><div class="line"></div><div class="line"><span class="comment">// typedefs</span></div><div class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, <span class="built_in">string</span>&gt; PropertiesMap;</div><div class="line"></div><div class="line"><span class="comment">// enums</span></div><div class="line"><span class="keyword">enum</span> UrlTableErrors &#123; ...</div></pre></td></tr></table></figure>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><blockquote>
<p>变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用，如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member</code>.</p>
</blockquote>
<p>普通变量命名:</p>
<p>举例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">string</span> table_name;  <span class="comment">// 可 - 用下划线。</span></div><div class="line"><span class="built_in">string</span> tablename;   <span class="comment">// 可 - 全小写。</span></div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">string</span> tableName;   <span class="comment">// 差 - 混合大小写。</span></div></pre></td></tr></table></figure>
<p>类数据成员：</p>
<p>不管是静态的还是非静态的，类数据成员都可以和普通变量一样, 但要接下划线。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> TableInfo &#123;</div><div class="line">  ...</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="built_in">string</span> table_name_;  <span class="comment">// 可 - 尾后加下划线。</span></div><div class="line">  <span class="built_in">string</span> tablename_;   <span class="comment">// 可。</span></div><div class="line">  <span class="keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 可。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>结构体变量:</p>
<p>不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> UrlTableProperties &#123;</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">int</span> num_entries;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构体与类的讨论参考 结构体 vs. 类 一节.</p>
<p>全局变量:</p>
<p>对全局变量没有特别要求, 少用就好, 但如果你要用, 可以用 <code>g_</code> 或其它标志作为前缀, 以便更好的区分局部变量.</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><blockquote>
<p>在全局或类里的常量名称前加 <code>k</code>: <code>kDaysInAWeek</code>. 且除去开头的 <code>k</code> 之外每个单词开头字母均大写。</p>
</blockquote>
<p>所有编译时常量, 无论是局部的, 全局的还是类中的, 和其他变量稍微区别一下. <code>k</code> 后接大写字母开头的单词:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</div></pre></td></tr></table></figure>
<p>这规则适用于编译时的局部作用域常量，不过要按变量规则来命名也可以。</p>
<h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><blockquote>
<p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>.</p>
</blockquote>
<p>常规函数:</p>
<p>函数名的每个单词首字母大写, 没有下划线。</p>
<p>如果您的某函数出错时就要直接 crash, 那么就在函数名加上 OrDie. 但这函数本身必须集成在产品代码里，且平时也可能会出错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">AddTableEntry()</div><div class="line">DeleteUrl()</div><div class="line">OpenFileOrDie()</div></pre></td></tr></table></figure>
<p>取值和设值函数:</p>
<p>取值（Accessors）和设值（Mutators）函数要与存取的变量名匹配. 这儿摘录一个类, <code>num_entries_</code> 是该类的实例变量:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> MyClass &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        ...</div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">num_entries</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> num_entries_; &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_num_entries</span><span class="params">(<span class="keyword">int</span> num_entries)</span> </span>&#123; num_entries_ = num_entries; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">int</span> num_entries_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其它非常短小的内联函数名也可以用小写字母, 例如. 如果你在循环中调用这样的函数甚至都不用缓存其返回值, 小写命名就可以接受.</p>
<h3 id="名字空间命名"><a href="#名字空间命名" class="headerlink" title="名字空间命名"></a>名字空间命名</h3><blockquote>
<p>名字空间用小写字母命名, 并基于项目名称和目录结构: <code>google_awesome_project.</code></p>
</blockquote>
<p>关于名字空间的讨论和如何命名, 参考 名字空间 一节.</p>
<h3 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h3><blockquote>
<p>枚举的命名应当和 常量 或 宏 一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>.</p>
</blockquote>
<p>单独的枚举值应该优先采用 常量 的命名方式. 但 宏 方式的命名也可以接受. 枚举名 <code>UrlTableErrors</code> (以及 <code>AlternateUrlTableErrors</code>) 是类型, 所以要用大小写混合的方式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> UrlTableErrors &#123;</div><div class="line">    kOK = <span class="number">0</span>,</div><div class="line">    kErrorOutOfMemory,</div><div class="line">    kErrorMalformedInput,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">enum</span> AlternateUrlTableErrors &#123;</div><div class="line">    OK = <span class="number">0</span>,</div><div class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</div><div class="line">    MALFORMED_INPUT = <span class="number">2</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>2009 年 1 月之前, 我们一直建议采用 宏 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
<h3 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h3><blockquote>
<p>你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p>
</blockquote>
<p>参考 预处理宏; 通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(x) ...</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_ROUNDED 3.0</span></div></pre></td></tr></table></figure>
<h3 id="命名规则的特例"><a href="#命名规则的特例" class="headerlink" title="命名规则的特例"></a>命名规则的特例</h3><blockquote>
<p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
</blockquote>
<ul>
<li><code>bigopen()</code>: 函数名, 参照 <code>open()</code> 的形式</li>
<li><code>uint</code>: <code>typedef</code></li>
<li><code>bigpos</code>: <code>struct</code> 或 <code>class</code>, 参照 <code>pos</code> 的形式</li>
<li><code>sparse_hash_map</code>: STL 相似实体; 参照 STL 命名约定</li>
<li><code>LONGLONG_MAX</code>: 常量, 如同 <code>INT_MAX</code></li>
</ul>
<p>译者（acgtyrant）笔记</p>
<p>感觉 Google 的命名约定很高明，比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 <code>query_result</code>, 区分度很好；再次，类内变量以下划线结尾，那么就可以直接传入同名的形参，比如 <code>TextQuery::TextQuery(std::string word) : word_(word) {}</code> , 其中 <code>word_</code> 自然是类内私有成员。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码本身应该是自文档化. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</p>
<p>你写的注释是给代码读者看的: 下一个需要理解你的代码的人. 慷慨些吧, 下一个人可能就是你!</p>
<h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h3><blockquote>
<p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p>
</blockquote>
<p><code>//</code> 或 <code>/* */</code> 都可以; 但 <code>//</code> 更 常用. 要在如何注释及注释风格上确保统一.</p>
<h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><blockquote>
<p>在每一个文件开头加入版权公告, 然后是文件内容描述.</p>
</blockquote>
<p>法律公告和作者信息:</p>
<p>每个文件都应该包含以下项, 依次是:</p>
<ul>
<li>版权声明 (比如, Copyright 2008 Google Inc.)</li>
<li>许可证. 为项目选择合适的许可证版本 (比如, Apache 2.0, BSD, LGPL, GPL)</li>
<li>作者: 标识文件的原始作者.</li>
</ul>
<p>如果你对原始作者的文件做了重大修改, 将你的信息添加到作者信息里. 这样当其他人对该文件有疑问时可以知道该联系谁.</p>
<p>文件内容:</p>
<p>紧接着版权许可和作者信息之后, 每个文件都要用注释描述文件内容.</p>
<p>通常, <code>.h</code> 文件要对所声明的类的功能和用法作简单说明. <code>.cc</code> 文件通常包含了更多的实现细节或算法技巧讨论, 如果你感觉这些实现细节或算法技巧讨论对于理解 <code>.h</code> 文件有帮助, 可以将该注释挪到 <code>.h</code>, 并在 <code>.cc</code> 中指出文档在 <code>.h</code>.</p>
<p>不要简单的在 <code>.h</code> 和 <code>.cc</code> 间复制注释. 这种偏离了注释的实际意义.</p>
<h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><blockquote>
<p>每个类的定义都要附带一份注释, 描述类的功能和用法.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Iterates over the contents of a GargantuanTable.  Sample usage:</span></div><div class="line"><span class="comment">//    GargantuanTable_Iterator* iter = table-&gt;NewIterator();</span></div><div class="line"><span class="comment">//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) &#123;</span></div><div class="line"><span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//    delete iter;</span></div><div class="line"><span class="keyword">class</span> GargantuanTable_Iterator &#123;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果你觉得已经在文件顶部详细描述了该类, 想直接简单的来上一句 “完整描述见文件顶部” 也不打紧, 但务必确保有这类注释.</p>
<p>如果类有任何同步前提, 文档说明之. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
<h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><blockquote>
<p>函数声明处注释描述函数功能; 定义处描述函数实现.</p>
</blockquote>
<p>函数声明:</p>
<p>注释位于声明之前, 对函数功能及用法进行描述. 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p>
<p>函数声明处注释的内容:</p>
<ul>
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>如果函数分配了空间, 需要由调用者释放.</li>
<li>参数是否可以为 <code>NULL</code>.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ul>
<p>举例如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Returns an iterator for this table.  It is the client's</span></div><div class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></div><div class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></div><div class="line"><span class="comment">// on which the iterator was created has been deleted.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This method is equivalent to:</span></div><div class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></div><div class="line"><span class="comment">//    iter-&gt;Seek("");</span></div><div class="line"><span class="comment">//    return iter;</span></div><div class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></div><div class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></div><div class="line"><span class="comment">// and avoid the extra seek.</span></div><div class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="keyword">const</span></span>;</div></pre></td></tr></table></figure>
<p>但也要避免罗罗嗦嗦, 或做些显而易见的说明. 下面的注释就没有必要加上 “returns false otherwise”, 因为已经暗含其中了:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Returns true if the table cannot hold any more entries.</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTableFull</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以 “destroys this object” 这样的注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
<p>函数定义:</p>
<p>每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要.</p>
<p>不要 从 <code>.h</code> 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
<h3 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h3><blockquote>
<p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
</blockquote>
<p>类数据成员:</p>
<p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果变量可以接受 <code>NULL</code> 或 <code>-1</code> 等警戒值, 须加以说明. 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Keeps track of the total number of entries in the table.</span></div><div class="line">    <span class="comment">// Used to ensure we do not go over the limit. -1 means</span></div><div class="line">    <span class="comment">// that we don't yet know how many entries the table has.</span></div><div class="line">    <span class="keyword">int</span> num_total_entries_;</div></pre></td></tr></table></figure>
<p>全局变量:</p>
<p>和数据成员一样, 所有全局变量也要注释说明含义及用途. 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumTestCases = <span class="number">6</span>;</div></pre></td></tr></table></figure>
<h3 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h3><blockquote>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
</blockquote>
<p>代码前注释:</p>
<p>巧妙或复杂的代码段前要加注释. 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Divide result by two, taking into account that x</span></div><div class="line"><span class="comment">// contains the carry from the add.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result-&gt;size(); i++) &#123;</div><div class="line">    x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</div><div class="line">    (*result)[i] = x &gt;&gt; <span class="number">1</span>;</div><div class="line">    x &amp;= <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>行注释:</p>
<p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></div><div class="line">mmap_budget = max&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;length());</div><div class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))</div><div class="line">    <span class="keyword">return</span>;  <span class="comment">// Error already logged.</span></div></pre></td></tr></table></figure>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">DoSomething();                  <span class="comment">// Comment here so the comments line up.</span></div><div class="line">DoSomethingElseThatIsLonger();  <span class="comment">// Comment here so there are two spaces between</span></div><div class="line">                                <span class="comment">// the code and the comment.</span></div><div class="line">&#123; <span class="comment">// One space before comment when opening a new scope is allowed,</span></div><div class="line">  <span class="comment">// thus the comment lines up with the following comments and code.</span></div><div class="line">  DoSomethingElse();  <span class="comment">// Two spaces before line comments normally.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NULL, true/false, 1, 2, 3…:</p>
<p>向函数传入 <code>NULL</code>, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意. 例如, 对比:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</div><div class="line">                                  <span class="number">10</span>,</div><div class="line">                                  <span class="literal">false</span>,</div><div class="line">                                  <span class="literal">NULL</span>);  <span class="comment">// What are these arguments??</span></div></pre></td></tr></table></figure>
<p>和:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</div><div class="line">                                  <span class="number">10</span>,     <span class="comment">// Default base value.</span></div><div class="line">                                  <span class="literal">false</span>,  <span class="comment">// Not the first time we're calling this.</span></div><div class="line">                                  <span class="literal">NULL</span>);  <span class="comment">// No callback.</span></div></pre></td></tr></table></figure>
<p>或使用常量或描述性变量:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDefaultBaseValue = <span class="number">10</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">bool</span> kFirstTimeCalling = <span class="literal">false</span>;</div><div class="line">Callback *null_callback = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</div><div class="line">                                  kDefaultBaseValue,</div><div class="line">                                  kFirstTimeCalling,</div><div class="line">                                  null_callback);</div></pre></td></tr></table></figure>
<p>不允许:</p>
<p>注意 永远不要 用自然语言翻译代码作为注释. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 现在, 检查 b 数组并确保 i 是否存在,</span></div><div class="line"><span class="comment">// 下一个元素是 i+1.</span></div><div class="line">...        <span class="comment">// 天哪. 令人崩溃的注释.</span></div></pre></td></tr></table></figure>
<h3 id="标点-拼写和语法"><a href="#标点-拼写和语法" class="headerlink" title="标点, 拼写和语法"></a>标点, 拼写和语法</h3><blockquote>
<p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
</blockquote>
<p>注释的通常写法是包含正确大小写和结尾句号的完整语句. 短一点的注释 (如代码行尾注释) 可以随意点, 依然要注意风格的一致性. 完整的语句可读性更好, 也可以说明该注释是完整的, 而不是一些不成熟的想法.</p>
<p>虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有所帮助.</p>
<h3 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h3><blockquote>
<p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释.</p>
</blockquote>
<p><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>, 在随后的圆括号里写上你的大名, 邮件地址, 或其它身份标识. 冒号是可选的. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code> 格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span></div><div class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></div><div class="line">如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November <span class="number">2005</span>”), 或者一个明确的事项 (“Remove <span class="keyword">this</span> code when all clients can handle XML responses.”).</div></pre></td></tr></table></figure>
<h3 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h3><blockquote>
<p>通过弃用注释（DEPRECATED comments）以标记某接口点（interface points）已弃用。</p>
</blockquote>
<p>您可以写上包含全大写的 <code>DEPRECATED</code> 的注释，以标记某接口为弃用状态。注释可以放在接口声明前，或者同一行。</p>
<p>在 <code>DEPRECATED</code> 一词后，留下您的名字，邮箱地址以及括号补充。</p>
<p>仅仅标记接口为 <code>DEPRECATED</code> 并不会让大家不约而同地弃用，您还得亲自主动修正调用点（callsites），或是找个帮手。</p>
<p>修正好的代码应该不会再涉及弃用接口点了，着实改用新接口点。如果您不知从何下手，可以找标记弃用注释的当事人一起商量。</p>
<p>译者 (YuleFox) 笔记</p>
<ol>
<li>关于注释风格，很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>代码风格和格式确实比较随意, 但一个项目中所有人遵循同一风格是非常容易的. 个体未必同意下述每一处格式规则, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人能很轻松的阅读和理解代码.</p>
<p>另外, 我们写了一个 <a href="http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el" target="_blank" rel="external">emacs 配置文件</a> 来帮助你正确的格式化代码.</p>
<h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><blockquote>
<p>每一行代码字符数不超过 80.</p>
</blockquote>
<p>我们也认识到这条规则是有争议的, 但很多已有代码都已经遵照这一规则, 我们感觉一致性更重要.</p>
<p><strong>优点:</strong></p>
<p>提倡该原则的人主张强迫他们调整编辑器窗口大小很野蛮. 很多人同时并排开几个代码窗口, 根本没有多余空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 为什么要改变呢?</p>
<p><strong>缺点:</strong></p>
<p>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 很轻松的可以显示更多代码.</p>
<p><strong>结论:</strong></p>
<p>80 个字符是最大值.</p>
<p><strong>特例:</strong></p>
<ul>
<li>如果一行注释包含了超过 80 字符的命令或 URL, 出于复制粘贴的方便允许该行超过 80 字符.</li>
<li>包含长路径的 <code>#include</code> 语句可以超出80列. 但应该尽量避免.</li>
<li>头文件保护 可以无视该原则.</li>
</ul>
<h3 id="非-ASCII-字符"><a href="#非-ASCII-字符" class="headerlink" title="非 ASCII 字符"></a>非 ASCII 字符</h3><blockquote>
<p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p>
</blockquote>
<p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符要少用. 特殊情况下可以适当包含此类字符. 如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p>
<p>十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 <code>&quot;\xEF\xBB\xBF&quot;</code> 在 Unicode 中是 零宽度 无间断 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p>
<p>(Yang.Y 注: <code>&quot;\xEF\xBB\xBF&quot;</code> 通常用作 UTF-8 with BOM 编码标记)</p>
<p>用 <code>u8</code> 前缀以把带 <code>uXXXX</code> 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上，因为如果编译器不把源代码识别成 UTF-8, 输出就会出错。</p>
<p>别用 C++11 的 <code>char16_t</code> 和 <code>char32_t</code>, 它们和 UTF-8 文本没有关系，<code>wchar_t</code> 同理，除非您写的代码要调用 Windows API, 后者有用到 <code>wchar_t</code> 扩展。</p>
<h3 id="空格还是制表位"><a href="#空格还是制表位" class="headerlink" title="空格还是制表位"></a>空格还是制表位</h3><blockquote>
<p>只使用空格, 每次缩进 2 个空格.</p>
</blockquote>
<p>我们使用空格缩进. 不要在代码中使用制符表. 你应该设置编辑器将制符表转为空格.</p>
<h3 id="函数声明与定义"><a href="#函数声明与定义" class="headerlink" title="函数声明与定义"></a>函数声明与定义</h3><blockquote>
<p>返回类型和函数名在同一行, 参数也尽量放在同一行，如果放不下就对形参分行。</p>
</blockquote>
<p>函数看上去像这样:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123;</div><div class="line">    DoSomething();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果同一行文本太多, 放不下所有参数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,</div><div class="line">                                             Type par_name3) &#123;</div><div class="line">    DoSomething();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>甚至连第一个参数都放不下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ReturnType LongClassName::ReallyReallyReallyLongFunctionName(</div><div class="line">        Type par_name1,  <span class="comment">// 4 空格缩进</span></div><div class="line">        Type par_name2,</div><div class="line">        Type par_name3) &#123;</div><div class="line">    DoSomething();  <span class="comment">// 2 空格缩进</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意以下几点:</p>
<ul>
<li>如果返回类型和函数名在一行放不下，分行。</li>
<li>如果返回类型那个与函数声明或定义分行了，不要缩进。</li>
<li>左圆括号总是和函数名在同一行;</li>
<li>函数名和左圆括号间没有空格;</li>
<li>圆括号与参数间没有空格;</li>
<li>左大括号总在最后一个参数同一行的末尾处;</li>
<li>如果其它风格规则允许的话，右大括号总是单独位于函数最后一行，或者与左大括号同一行。</li>
<li>右大括号和左大括号间总是有一个空格;</li>
<li>函数声明和定义中的所有形参必须有命名且一致;</li>
<li>所有形参应尽可能对齐;</li>
<li>缺省缩进为 2 个空格;</li>
<li>换行后的参数保持 4 个空格的缩进;</li>
<li>如果有些参数没有用到, 在函数定义处将参数名注释起来:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 接口中形参恒有命名。</div><div class="line">class Shape &#123;</div><div class="line"> public:</div><div class="line">  virtual void Rotate(double radians) = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 声明中形参恒有命名。</div><div class="line">class Circle : public Shape &#123;</div><div class="line"> public:</div><div class="line">  virtual void Rotate(double radians);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义中注释掉无用变量。</div><div class="line">void Circle::Rotate(double /*radians*/) &#123;&#125;</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 差 - 如果将来有人要实现，很难猜出变量是干什么用的。</span></div><div class="line"><span class="keyword">void</span> Circle::Rotate(<span class="keyword">double</span>) &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="Lambda-表达式-1"><a href="#Lambda-表达式-1" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><blockquote>
<p>其它函数怎么格式化形参和函数体，Lambda 表达式就怎么格式化；捕获列表同理。</p>
</blockquote>
<p>若用引用捕获，在变量名和 &amp; 之间不留空格。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line"><span class="keyword">auto</span> add_to_x = [&amp;x](<span class="keyword">int</span> n) &#123; x += n; &#125;;</div></pre></td></tr></table></figure>
<p>短 lambda 就写得和内联函数一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; blacklist = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; digits = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</div><div class="line">digits.erase(<span class="built_in">std</span>::remove_if(digits.begin(), digits.end(), [&amp;blacklist](<span class="keyword">int</span> i) &#123;</div><div class="line">                <span class="keyword">return</span> blacklist.find(i) != blacklist.end();</div><div class="line">            &#125;),</div><div class="line">            digits.end());</div></pre></td></tr></table></figure>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><blockquote>
<p>要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。</p>
</blockquote>
<p>函数调用遵循如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> retval = DoSomething(argument1, argument2, argument3);</div></pre></td></tr></table></figure>
<p>如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> retval = DoSomething(averyveryveryverylongargument1,</div><div class="line">                          argument2, argument3);</div></pre></td></tr></table></figure>
<p>参数也可以放在次行，缩进四格：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (...) &#123;</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  <span class="keyword">if</span> (...) &#123;</div><div class="line">    DoSomething(</div><div class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></div><div class="line">        argument3, argument4);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>把多个参数放在同一行，是为了减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办：</p>
<p>如果一些参数本身就是略复杂的表达式，且降低了可读性。那么可以直接创建临时变量描述该表达式，并传递给函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> my_heuristic = scores[x] * y + bases[x];</div><div class="line"><span class="keyword">bool</span> retval = DoSomething(my_heuristic, x, y, z);</div></pre></td></tr></table></figure>
<p>或者放着不管，补充上注释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> retval = DoSomething(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></div><div class="line">                          x, y, z);</div></pre></td></tr></table></figure>
<p>如果某参数独立成行，对可读性更有帮助的话，就这么办。</p>
<p>此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></div><div class="line">my_widget.Transform(x1, x2, x3,</div><div class="line">                    y1, y2, y3,</div><div class="line">                    z1, z2, z3);</div></pre></td></tr></table></figure>
<h3 id="列表初始化格式"><a href="#列表初始化格式" class="headerlink" title="列表初始化格式"></a>列表初始化格式</h3><blockquote>
<p>您平时怎么格式化函数调用，就怎么格式化 列表初始化。</p>
</blockquote>
<p>如果列表初始化伴随着名字，比如类型或变量名，您可以当名字是函数、{} 是函数调用的括号来格式化它。反之，就当它有个长度为零的名字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 一行列表初始化示范。</span></div><div class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</div><div class="line">functioncall(&#123;foo, bar&#125;);</div><div class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p&#123;foo, bar&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 当不得不断行时。</span></div><div class="line">SomeFunction(</div><div class="line">    &#123;<span class="string">"assume a zero-length name before &#123;"</span>&#125;,</div><div class="line">    some_other_function_parameter);</div><div class="line">SomeType variable&#123;</div><div class="line">    some, other, values,</div><div class="line">    &#123;<span class="string">"assume a zero-length name before &#123;"</span>&#125;,</div><div class="line">    SomeOtherType&#123;</div><div class="line">        <span class="string">"Very long string requiring the surrounding breaks."</span>,</div><div class="line">        some, other values&#125;,</div><div class="line">    SomeOtherType&#123;<span class="string">"Slightly shorter string"</span>,</div><div class="line">                  some, other, values&#125;&#125;;</div><div class="line">SomeType variable&#123;</div><div class="line">    <span class="string">"This is too long to fit all in one line"</span>&#125;;</div><div class="line">MyType m = &#123;  <span class="comment">// 注意了，您可以在 &#123; 前断行。</span></div><div class="line">    superlongvariablename1,</div><div class="line">    superlongvariablename2,</div><div class="line">    &#123;<span class="keyword">short</span>, interior, <span class="built_in">list</span>&#125;,</div><div class="line">    &#123;interiorwrappinglist,</div><div class="line">     interiorwrappinglist2&#125;&#125;;</div></pre></td></tr></table></figure>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><blockquote>
<p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.</p>
</blockquote>
<p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<p>最常见的是没有空格的格式. 哪种都可以, 但 保持一致性. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在徘徊的话, 就不要加空格了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) &#123;  圆括号里没空格紧邻。</div><div class="line">  ...  <span class="comment">// 2 空格缩进。</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行。</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你更喜欢在圆括号内部加空格:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></div><div class="line">  ...  <span class="comment">// 2 空格缩进。</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行。</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(condition)     <span class="comment">// 差 - IF 后面没空格。</span></div><div class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 差 - &#123; 前面没空格。</span></div><div class="line"><span class="keyword">if</span>(condition)&#123;    <span class="comment">// 变本加厉地差。</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 可 - IF 和 &#123; 都与空格紧邻。</span></div></pre></td></tr></table></figure>
<p>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> Foo();</div><div class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> Bar();</div></pre></td></tr></table></figure>
<p>如果语句有 <code>else</code> 分支则不允许:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 不可以这样子 - 当有 ELSE 分支时 IF 块却只有一行</span></div><div class="line"><span class="keyword">if</span> (x) DoThis();</div><div class="line"><span class="keyword">else</span> DoThat();</div></pre></td></tr></table></figure>
<p>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition)</div><div class="line">  DoSomething();  <span class="comment">// 2 空格缩进。</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">  DoSomething();  <span class="comment">// 2 空格缩进。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但如果语句中某个 if-else 分支使用了大括号的话, 其它分支也必须使用:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有。</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">    foo;</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">    bar;</div><div class="line"></div><div class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有。</span></div><div class="line"><span class="keyword">if</span> (condition)</div><div class="line">    foo;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    bar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 只要其中一个分支用了大括号，两个分支都要用上大括号。</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">  foo;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  bar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="循环和开关选择语句"><a href="#循环和开关选择语句" class="headerlink" title="循环和开关选择语句"></a>循环和开关选择语句</h3><blockquote>
<p><code>switch</code> 语句可以使用大括号分段，以表明 cases 之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用 <code>{}</code> 或 <code>continue</code>.</p>
</blockquote>
<p><code>switch</code> 语句中的 <code>case</code> 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<p>如果有不满足 <code>case</code> 条件的枚举值, <code>switch</code> 应该总是包含一个 <code>default</code> 匹配 (如果有输入值没有 <code>case</code> 去处理, 编译器将报警). 如果 <code>default</code> 应该永远执行不到, 简单的加条 <code>assert</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> (var) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></div><div class="line">    ...      <span class="comment">// 4 空格缩进</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">default</span>: &#123;</div><div class="line">    assert(<span class="literal">false</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在单语句循环里，括号可用可不用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i)</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"I love you\n"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"I take it back\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>空循环体应使用 <code>{}</code> 或 <code>continue</code>, 而不是一个简单的分号.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition) &#123;</div><div class="line">  <span class="comment">// 反复循环直到条件失效。</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体。</span></div><div class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑。</span></div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition);  <span class="comment">// 差 - 看起来仅仅只是 while/loop 的部分之一。</span></div></pre></td></tr></table></figure>
<h3 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h3><blockquote>
<p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*</code>, <code>&amp;</code>) 之后不能有空格.</p>
</blockquote>
<p>下面是指针和引用表达式的正确使用范例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">x = *p;</div><div class="line">p = &amp;x;</div><div class="line">x = r.y;</div><div class="line">x = r-&gt;y;</div></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>在访问成员时, 句点或箭头前后没有空格.</li>
<li>指针操作符 <code>*</code> 或 <code>&amp;</code> 后没有空格.</li>
</ul>
<p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 好样的，空格前置。</span></div><div class="line"><span class="keyword">char</span> *c;</div><div class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp;str;</div><div class="line"></div><div class="line"><span class="comment">// 好样的，空格后置。</span></div><div class="line"><span class="keyword">char</span>* c;    <span class="comment">// 但别忘了 "char* c, *d, *e, ...;"!</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; str;</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格。</span></div></pre></td></tr></table></figure>
<p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</p>
<h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><blockquote>
<p>如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.<br>下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</div><div class="line">    a_third_thing == a_fourth_thing &amp;&amp;</div><div class="line">    yet_another &amp; last_one) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 上例的逻辑与 (<code>&amp;&amp;</code>) 操作符均位于行尾. 这格式在 Google 里很常见，您要把所有操作符放在开头也可以。可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外直接用符号形式的操作符，比如 <code>&amp;&amp;</code> 和 <code>~</code>, 不要用词语形式的 <code>and</code> 和 <code>compl</code>.</p>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><blockquote>
<p><code>return</code> 表达式里时没必要都用圆括号。</p>
</blockquote>
<p>假如您写 <code>x = epr</code> 时本来就会加上括号，那 <code>return expr;</code> 也可如法炮制。</p>
<p>函数返回时不要使用圆括号:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">return</span> result;                  <span class="comment">// 返回值很简单，没有圆括号。</span></div><div class="line"><span class="comment">// 可以用圆括号把复杂表达式圈起来，改善可读性。</span></div><div class="line"><span class="keyword">return</span> (some_long_condition &amp;&amp;</div><div class="line">        another_condition);</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">return</span> (value);                <span class="comment">// 毕竟您从来不会写 var = (value);</span></div><div class="line"><span class="keyword">return</span>(result);                <span class="comment">// return 可不是函数！</span></div></pre></td></tr></table></figure>
<h3 id="变量及数组初始化"><a href="#变量及数组初始化" class="headerlink" title="变量及数组初始化"></a>变量及数组初始化</h3><blockquote>
<p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可.</p>
</blockquote>
<p>您可以用 <code>=</code>, <code>()</code> 和 <code>{}</code>, 以下都对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</div><div class="line"><span class="keyword">int</span> x&#123;<span class="number">3</span>&#125;;</div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Some Name"</span>)</span></span>;</div><div class="line"><span class="built_in">string</span> name = <span class="string">"Some Name"</span>;</div><div class="line"><span class="built_in">string</span> name&#123;<span class="string">"Some Name"</span>&#125;;</div></pre></td></tr></table></figure>
<p>请务必小心列表初始化 {…} 用 <code>std::initializer_list</code> 构造函数初始化出的类型。非空列表初始化就会优先调用 <code>std::initializer_list</code>, 不过空列表初始化除外，后者原则上会调用默认构造函数。为了强制禁用 <code>std::initializer_list</code> 构造函数，请改用括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">100</span>, <span class="number">1</span>);  <span class="comment">// A vector of 100 1s.</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// A vector of 100, 1.</span></div></pre></td></tr></table></figure>
<p>此外，列表初始化不允许整型类型的四舍五入，这可以用来避免一些类型上的编程失误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pi</span><span class="params">(<span class="number">3.14</span>)</span></span>;  <span class="comment">// 可 -- pi == 3.</span></div><div class="line"><span class="keyword">int</span> pi&#123;<span class="number">3.14</span>&#125;;  <span class="comment">// Compile error: narrowing conversion.</span></div></pre></td></tr></table></figure>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><blockquote>
<p>预处理指令不要缩进, 从行首开始.</p>
</blockquote>
<p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 可 - directives at beginning of line</span></div><div class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 -- 行开头起。</span></span></div><div class="line">    DropEverything();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    BackToNormal();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 差 - indented directives</span></div><div class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</div><div class="line">    <span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING  <span class="comment">// 错了！ "#if" 应该放在行开头</span></span></div><div class="line">    DropEverything();</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span>                <span class="comment">// 错了！ "#endif" 不要缩进</span></span></div><div class="line">    BackToNormal();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="类格式"><a href="#类格式" class="headerlink" title="类格式"></a>类格式</h3><blockquote>
<p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每次缩进 1 个空格.</p>
</blockquote>
<p>类声明 (对类注释不了解的话, 参考 类注释) 的基本格式如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> MyClass : <span class="keyword">public</span> OtherClass &#123;</div><div class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有 1 空格缩进!</span></div><div class="line">  MyClass();  <span class="comment">// 照常，2 空格缩进。</span></div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</div><div class="line">  ~MyClass() &#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_some_var</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> some_var_;</div><div class="line">  <span class="keyword">int</span> some_other_var_;</div><div class="line">  DISALLOW_COPY_AND_ASSIGN(MyClass);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意事项:</p>
<ul>
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>
<li>关键词 <code>public:</code>, <code>protected:</code>, <code>private:</code> 要缩进 1 个空格.</li>
<li>除第一个关键词 (一般是 <code>public</code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>
<li>这些关键词后不要保留空行.</li>
<li><code>public</code> 放在最前面, 然后是 <code>protected</code>, 最后是 <code>private</code>.</li>
<li>关于声明顺序的规则请参考 声明顺序 一节.</li>
</ul>
<h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><blockquote>
<p>构造函数初始值列表放在同一行或按四格缩进并排几行.</p>
</blockquote>
<p>下面两种初始值列表方式都可以接受:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 当全放在一行合适时：</span></div><div class="line">MyClass::MyClass(<span class="keyword">int</span> var) : some_var_(var), some_other_var_(var + <span class="number">1</span>) &#123;</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 如果要断成多行，缩进四格，冒号放在第一行初始化句：</span></div><div class="line">MyClass::MyClass(<span class="keyword">int</span> var)</div><div class="line">    : some_var_(var),             <span class="comment">// 4 空格缩进</span></div><div class="line">      some_other_var_(var + <span class="number">1</span>) &#123;  <span class="comment">// 对准</span></div><div class="line">  ...</div><div class="line">  DoSomething();</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="名字空间格式化"><a href="#名字空间格式化" class="headerlink" title="名字空间格式化"></a>名字空间格式化</h3><blockquote>
<p>名字空间内容不缩进.</p>
</blockquote>
<p>名字空间 不要增加额外的缩进层次, 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> &#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确。命名空间内没有额外的缩进。</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;  <span class="comment">// namespace</span></div></pre></td></tr></table></figure>
<p>不要缩进名字空间:</p>
<p>Warning</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 错，缩进多余了。</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;  <span class="comment">// namespace</span></div></pre></td></tr></table></figure>
<p>声明嵌套命名空间时，每命名空间都独立成行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> foo &#123;</div><div class="line"><span class="keyword">namespace</span> bar &#123;</div></pre></td></tr></table></figure>
<h3 id="水平留白"><a href="#水平留白" class="headerlink" title="水平留白"></a>水平留白</h3><blockquote>
<p>水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白.</p>
</blockquote>
<p>常规:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前恒有空格。</span></div><div class="line">  ...</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格。</span></div><div class="line"><span class="keyword">int</span> x[] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 大括号内部可与空格紧邻也不可，不过两边都要加上。</span></div><div class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格。</span></div><div class="line"><span class="keyword">class</span> Foo : <span class="keyword">public</span> Bar &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// 至于内联函数实现，在大括号内部加上空格并编写实现。</span></div><div class="line">  Foo(<span class="keyword">int</span> b) : Bar(), baz_(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话，不加空格。</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开。</span></div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（确信没有其他人在处理). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p>
<p>循环和条件语句:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格。</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格。</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格。</span></div><div class="line"><span class="keyword">switch</span> (i) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</div><div class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻。</span></div><div class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号，但这很少见。总之要一致。</span></div><div class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</div><div class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格，； 前可以加个空格。</span></div><div class="line"><span class="keyword">switch</span> (i) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格。</span></div><div class="line">    ...</div><div class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码，加个空格。</span></div></pre></td></tr></table></figure>
<p>操作符:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 赋值操作系统前后恒有空格。</span></div><div class="line">x = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// 其它二元操作符也前后恒有空格，不过对 factors 前后不加空格也可以。</span></div><div class="line"><span class="comment">// 圆括号内部不紧邻空格。</span></div><div class="line">v = w * x + y / z;</div><div class="line">v = w*x + y/z;</div><div class="line">v = w * (x + z);</div><div class="line"></div><div class="line"><span class="comment">// 在参数和一元操作符之间不加空格。</span></div><div class="line">x = <span class="number">-5</span>;</div><div class="line">++x;</div><div class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>模板和转换:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 尖叫括号(&lt; and &gt;) 不与空格紧邻，&lt; 前没有空格，&gt;( 之间也没有。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; x;</div><div class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);</div><div class="line"></div><div class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以，但要保持一致。</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span> *&gt; x;</div><div class="line"><span class="built_in">set</span>&lt;<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;&gt; x;        <span class="comment">// 在 C++11 代码里可以这样用了。</span></div><div class="line"><span class="built_in">set</span>&lt;<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; &gt; x;       <span class="comment">// C++03 中要在 &gt; &gt; 里留个空格。</span></div><div class="line"></div><div class="line"><span class="comment">// 您或许可以在 &lt; &lt; 里加上一对对称的空格。</span></div><div class="line"><span class="built_in">set</span>&lt; <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; &gt; x;</div></pre></td></tr></table></figure>
<h3 id="垂直留白"><a href="#垂直留白" class="headerlink" title="垂直留白"></a>垂直留白</h3><blockquote>
<p>垂直留白越少越好.</p>
</blockquote>
<p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p>
<p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 取决于你的判断. 但通常是垂直留白越少越好.</p>
<p>空行心得如下：</p>
<ul>
<li>函数体内开头或结尾的空行可读性微乎其微。</li>
<li>在多重 if-else 块里加空行或许有点可读性。</li>
</ul>
<p>译者 (YuleFox) 笔记</p>
<ol>
<li>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</li>
<li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li>
<li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</li>
<li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li>
<li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</li>
<li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</li>
<li><code>.</code>/<code>-&gt;</code> 操作符前后不留空格, <code>*</code>/<code>&amp;</code> 不要前后都留, 一个就可, 靠左靠右依各人喜好;</li>
<li>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</li>
<li>初始化用 <code>=</code> 还是 <code>()</code> 依个人喜好, 统一就好;</li>
<li><code>return</code> 不要加 <code>()</code>;</li>
<li>水平/垂直留白不要滥用, 怎么易读怎么来.</li>
<li>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (.cc 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然.</li>
</ol>
<p>译者（acgtyrant）笔记</p>
<ol>
<li>80 行限制事实上有助于避免代码可读性失控，比如超多重嵌套块，超多重函数调用等等。</li>
<li>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码，不像奇葩的 Windows.</li>
<li>Google 强调有一对 if-else 时，不论有没有嵌套，都要有大括号。Apple 正好 <a href="http://coolshell.cn/articles/11112.html" target="_blank" rel="external">有栽过跟头</a> .</li>
<li>其实我主张指针／地址操作符与变量名紧邻，<code>int* a, b vs int *a, b</code>, 新手会误以为前者的 <code>b</code>是 <code>int *</code> 变量，但后者就不一样了，高下立判。</li>
<li>在这风格指南里我才刚知道 C++ 原来还有所谓的 <a href="http://en.cppreference.com/w/cpp/language/operator_alternative" target="_blank" rel="external">Alternative operator representations</a>, 大概没人用吧。</li>
<li>注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事，我就差点混淆了它们的翻译。</li>
<li>事实上，如果您熟悉英语本身的书写规则，就会发现该风格指南在格式上的规定与英语语法相当一脉相承。比如普通标点符号和单词后面还有文本的话，总会留一个空格；特殊符号与单词之间就不用留了，比如 <code>if (true)</code> 中的圆括号与 <code>true</code>.</li>
<li>本风格指南没有明确规定 void 函数里要不要用 return 语句，不过就 Google 开源项目 leveldb 并没有写；此外从 <a href="http://stackoverflow.com/questions/9316717/is-a-blank-return-statement-at-the-end-of-a-function-whos-return-type-is-void-ne" target="_blank" rel="external">Is a blank return statement at the end of a function whos return type is void necessary?</a> 来看，<code>return;</code> 比 <code>return ;</code> 更约定俗成（事实上 cpplint 会对后者报错，指出分号前有多余的空格），且可用来提前跳出函数栈。</li>
</ol>
<h2 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h2><p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p>
<h3 id="现有不合规范的代码"><a href="#现有不合规范的代码" class="headerlink" title="现有不合规范的代码"></a>现有不合规范的代码</h3><blockquote>
<p>对于现有不符合既定编程风格的代码可以网开一面.</p>
</blockquote>
<p>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心可以与代码原作者或现在的负责人员商讨, 记住, 一致性 包括原有的一致性.</p>
<h3 id="Windows-代码"><a href="#Windows-代码" class="headerlink" title="Windows 代码"></a>Windows 代码</h3><blockquote>
<p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.<br>如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p>
</blockquote>
<ul>
<li>不要使用匈牙利命名法 (比如把整型变量命名成 <code>iNum</code>). 使用 Google 命名约定, 包括对源文件使用 <code>.cc</code> 扩展名.</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 <code>DWORD</code>, <code>HANDLE</code> 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 但还是尽量使用原有的 C++ 类型, 例如, 使用 <code>const TCHAR *</code> 而不是 <code>LPCTSTR</code>.</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有 warnings 当作 errors 处理.</li>
<li>不要使用 <code>#pragma once</code>; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 <code>#ifndef SRC_DIR_BAR_H_</code>, 参考 #define 保护 一节).</li>
<li>除非万不得已, 不要使用任何非标准的扩展, 如 <code>#pragma</code> 和 <code>__declspec</code>. 允许使用 <code>__declspec(dllimport)</code> 和 <code>__declspec(dllexport)</code>; 但你必须通过宏来使用, 比如 <code>DLLIMPORT</code> 和 <code>DLLEXPORT</code>, 这样其他人在分享使用这些代码时很容易就去掉这些扩展.</li>
</ul>
<p>在 Windows 上, 只有很少的一些情况下, 我们可以偶尔违反规则:</p>
<ul>
<li>通常我们 禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 <code>_ATL_NO_EXCEPTIONS</code> 以禁用异常. 你要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 启用编译器异常也可以. (注意这只是为了编译 STL, 自己代码里仍然不要含异常处理.)</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 <code>StdAfx.h</code> 或 <code>precompile.h</code> 的文件. 为了使代码方便与其他项目共享, 避免显式包含此文件 (<code>precompile.cc</code>), 使用 <code>/FI</code> 编译器选项以自动包含.</li>
<li>资源头文件通常命名为 <code>resource.h</code>, 且只包含宏的, 不需要遵守本风格指南.</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote>
<p>运用常识和判断力, 并 保持一致.</p>
</blockquote>
<p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 if 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (<code>*</code>) 围成一个盒子状, 你同样要这么做.</p>
<p>风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示了全局的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也影响阅读, 所以要尽量避免.</p>
<p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离我第一次接触 Google Cpp 编码风格指南已经过去了八年，现在再来看看，感觉别有一番风味。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="编程" scheme="http://wdxtub.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
      <category term="风格" scheme="http://wdxtub.com/tags/%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>【C++ 编程思想】读书笔记</title>
    <link href="http://wdxtub.com/2017/01/29/thinking-in-cpp-clip/"/>
    <id>http://wdxtub.com/2017/01/29/thinking-in-cpp-clip/</id>
    <published>2017-01-28T23:43:32.000Z</published>
    <updated>2017-01-29T01:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文源自我大学时阅读本书的笔记，算是对自己的『温故知新』。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.29: 完成初稿</li>
</ul>
<h2 id="第1章-对象导言"><a href="#第1章-对象导言" class="headerlink" title="第1章 对象导言"></a>第1章 对象导言</h2><p>本章将介绍面向对象程序设计(OOP)的基本概念，包括OOP开发方法的概述。</p>
<h3 id="1-1-抽象的过程"><a href="#1-1-抽象的过程" class="headerlink" title="1.1 抽象的过程"></a>1.1 抽象的过程</h3><p>所有的程序语言都提供抽象。可以说，人们能解决的问题的复杂性直接与抽象的类型和质量有关。汇编语言时对底层机器的小幅度抽象。其后的许多所谓“命令式”语言(例如Fortran、Basic和C)都是对汇编语言的抽象。OPP允许程序员用问题本市的术语来描述问题，而不是用要运行解决方案的计算机的术语来描述问题。每个对象看上去像一台小计算机，它有状态，有可执行的运算。这似乎是现实世界中对象的很好类比，它们都有特性和行为。</p>
<p>面向对象语言的五个基本特性：</p>
<ol>
<li>万物皆对象。</li>
<li>程序就是一组对象，对象之间通过发送消息互相通知做什么。</li>
<li>每个对象都有它子集的由其他对象构成的存储区。</li>
<li>每个对象都有一个类型。</li>
<li>一个特定类型的所有对象都能接收相同的消息。</li>
</ol>
<h3 id="1-2-对象有一个接口"><a href="#1-2-对象有一个接口" class="headerlink" title="1.2 对象有一个接口"></a>1.2 对象有一个接口</h3><p>创建抽象数据类型是面向对象程序设计的基本思想。抽象数据类型几乎能完全像内部类型一样工作。</p>
<p>类描述了一组有相同特性(数据元素)和相同行为(功能)的对象，因此类实际上就是数据类型。面向对象程序设计的难题之一，是在问题空间中的元素和解空间中的对象之间建立一对一的映射。</p>
<p>必须有一种方法能向对象作出请求，使得它能做某些事情。可以向对象发出的请求是由它的接口(interface)定义的，而接口由类型确定。接口规定我们能向特定的对象发出什么请求。然后，必须有代码满足这种请求，再加上隐藏的数据，就组成了实现(implementation)。</p>
<h3 id="1-3-实现的隐藏"><a href="#1-3-实现的隐藏" class="headerlink" title="1.3 实现的隐藏"></a>1.3 实现的隐藏</h3><p>C++语言使用了三个明确的关键字来设置类中的边界：public、private 和 protected。public 意味着随后的定义对所有人都可用。相反，private 关键字则意味着，除了该类型的创建者和该类型的内部成员函数之外，任何人都不能访问这些定义。继承的类可以访问 protected 成员，但不能访问 private 成员。</p>
<h3 id="1-4-实现的重用"><a href="#1-4-实现的重用" class="headerlink" title="1.4 实现的重用"></a>1.4 实现的重用</h3><p>代码重用是面向对象程序设计语言的最大优点之一。可以用任何数量和类型的其他对象组成新类，通过组合得到新类所希望的功能。因为这是由已经存在的类组成新类，所以称为组合(composition)【或者更通常称为聚合(aggregation)】。组合常常被称为“has-a(有)”关系。</p>
<p>当创建新类时，程序员应当首先考虑组合，因为它更简单和更灵活。如果采用组合的方法，设计将变得清晰。</p>
<h3 id="1-5-继承：重用接口"><a href="#1-5-继承：重用接口" class="headerlink" title="1.5 继承：重用接口"></a>1.5 继承：重用接口</h3><p>克服许多困难去创造一个类，并随后强制性地创造一个有类似功能地全新地类，似乎很愚蠢。如果能选取已存在地类、克隆它，然后对这个克隆增加和修改，则是再好不过地事。这是继承(inheritance)带来地好处，缺点是，如果原来的类(称为基类、超类或父类)被修改，则这个修改过的“克隆”(称为派生类、继承类或子类)也会表现出这些改变。</p>
<p>当我们从已经存在的类型来继承时，我们就创造了一个新类型。这个新类性不仅包含那个已经存在的类型的所有成员，还复制了这个基类的接口，这意味着这个派生类与这个基类是相同类型的。 </p>
<p>有两种方法能使新派生类区别于原始基类。第一种相当直接，简单地向派生类添加全新的函数。这些新函数不是基类接口的一部分。着意味着，这个基类不能做我们希望它做的事情，所以必须添加函数。</p>
<p>虽然继承有时意味着向接口添加新函数，但这未必真的需要。是新类有别于基类的第二个和更重要的方法是，改变已经存在的基类函数的行为，这称为重载(overriding)这个函数。为了重载函数，可以简单地再派生类中创建新定义。相当于说：“我正再使用同一个接口函数，但是我希望它为我做不同的事情。”</p>
<p><strong>1.5.1 is-a 关系和 is-like-a 关系</strong></p>
<p>只重载基类(并且不添加基类中没有的新成员函数)的继承意味着派生类和基类是完全相同的类型，因为它们有相同的接口。结果是，我们可以用派生类的对象代替基类的对象。因此这被认为是纯代替(pure substitution)，常常被称为代替原则(substitution principle)。这种情况下，我们常把基类和派生类直接的关系看作是一个“is-a(是)”关系。</p>
<p>有时需要向一个派生类型添加新的接口元素，这样就扩展了接口并创建了新类型。这个新类型仍然可以代替这个基类，但这个代替不是完美的，因为这些新函数不能从基类访问，这可以描述为“is-like-a(像)”关系。</p>
<h3 id="1-6-具有多态性的可互换对象"><a href="#1-6-具有多态性的可互换对象" class="headerlink" title="1.6 具有多态性的可互换对象"></a>1.6 具有多态性的可互换对象</h3><p>如果试图把派生类型的对象看做是比它们自身更一般的基本类型(圆形看做形体，自行车看做车辆)，这里就有一个问题：如果一个函数告诉一个一般的形体去绘制它子集，或者告诉一个一般的车辆去行驶，则编译器再编译时就不能确切地知道应当执行哪段代码。同样地问题是，消息发送时，程序员并不想知道将执行哪段代码。编译器不能确切地知道执行哪段代码，那么它应该怎么办呢？</p>
<p>在面向对象的程序设计中，答案非常新奇：编译器并不做传统意义上的函数调用。非OOP编译器产生的函数调用会导致与被调用代码的早捆绑(early binding)，其意思是：编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。</p>
<p>在OOP中，知道程序运行时，编译器才能确定执行代码的地址，所以，当消息被发送给一般对象时，需要采用其他的方案。为了解决这一问题，面向对象语言采用晚捆绑(late binding)的思想。当给对象发送消息时，在程序运行时才去确定被调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回值的类型检查【其中不采用这种处理方式的语言称为弱类型(weakly typed)语言】，但是它并不知道将执行的确切代码。</p>
<p>为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的二进制代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址(详见第15章)。这样每个对象就能根据这段二进制代码的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应当做什么。</p>
<p>我们可以用关键字 virtual 声明他希望某个函数有晚捆绑的灵活性。在 C++ 中，必须记住添加 virtual 关键字，因为根据规定，默认情况下成员函数不能动态捆绑。virtual 函数(虚函数)可用来表示出在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。</p>
<p>我们把处理派生类型就如同处理其基类型的过程称为向上类型转换(upcasting)。编译器和运行系统可以处理这些细节，我们只需要知道它会这样做和知道如何用它设计程序就行了。如果一个成员函数是virtual的，则当我们给一个对象发送消息时，这个对象将做正确的事情，即使是在有向上类型转换的情况下。</p>
<h3 id="1-7-创建和销毁对象"><a href="#1-7-创建和销毁对象" class="headerlink" title="1.7 创建和销毁对象"></a>1.7 创建和销毁对象</h3><p>对象的数据存放在何处？如何控制对象的生命期？不同的设计语言有不同的处理方式。C++ 才去的方法是把效率控制作为最重要的问题，所以它为程序员提供了一个选择。为了最大化运行速度，通过将对象存放在栈中或静态存储区域中，存储和生命期可以在编写程序时确定。栈是内存中的一个区域，可以直接由微处理器在程序执行期间存放数据。在栈中的变量有时称自动变量(automatic variable)或局部变量(scoped variable)。静态存储区简单说是内存的一个固定块，在程序开始执行以前分配。使用栈或静态存储区，可以快速分配和释放，但是我们因此也牺牲了灵活性。</p>
<p>第二种方法是在称为堆(heap)的区域动态创建对象。用这种方法，可以直到运行时还不知道需要多少个对象，它们的生命期是什么和他们的准确数据类型是什么。这些决定是在程序运行之中作出的。如果需要心的对象，直接使用new关键字让它在堆上生成。当使用结束时，用关键字delete释放。</p>
<p>另一个问题是对象的生命期。如果在栈上或在静态存储上创建一个对象，编译器决定这个对象持续多长时间并能自动销毁它。然后，如果在堆上创建它，编译器则不知道它的生命期。在C++中，程序员必须编程决定何时销毁此对象。作为一个替换，运行环境可以提供一个称为垃圾收集器(garbage collector)的功能。当然，使用垃圾收集器编写程序是非常方便的，但是它需要所有应用软件能承受垃圾收集器的存在及垃圾收集的系统开销。</p>
<h3 id="1-8-异常处理：应对错误"><a href="#1-8-异常处理：应对错误" class="headerlink" title="1.8 异常处理：应对错误"></a>1.8 异常处理：应对错误</h3><p>从程序设计语言出现开始，错误处理就是最重要的问题之一。因为设计一个好的错误处理方案非常困难，许多语言忽略这个问题，将这个问题转交给库的设计者，而库的设计者往往采取不彻底的措施，即可以在许多情况下起作用，但很容易被绕考，通常是被忽略。</p>
<p>异常处理(exception handling)将错误处理直接与程序设计语言甚至有时是操作系统联系起来。异常是一个对象，它在出错的地方被抛出，并且被一段用以处理特定类型错误的异常处理代码(exception handler)所接收。异常处理似乎是另一个并行的执行路径，在出错的时候被调用。由于它使用一个单独的执行路径，它并不需要干涉正常的执行代码。因为不需经常检查错误，代码可以很简洁。另外，异常并不同于一个由函数返回的错误值或标记，后两者可以被忽略，而异常不能被忽略，必须保证它们在某些点上进行处理。最后，异常提供了一个从错误状态中进行可靠恢复的方法。除了从这个程序中退出以外，我们常常还可以作出正确的设置，并且回复程序执行，这有助于产生更健壮的系统。</p>
<h3 id="1-9-分析和设计"><a href="#1-9-分析和设计" class="headerlink" title="1.9 分析和设计"></a>1.9 分析和设计</h3><p>方法(method)［通常称为方法论(methodology)］是一系列的过程和探索，用以降低程序设计问题的复杂性。</p>
<p>经历开发过程时，最重要的问题是：不要迷路。如果不定因素不止一个，在没有创建一个能工作的原型之前，不要计划它将用多长时间和花费多少，这里的自由度太大了。</p>
<p>应当牢记我们正在努力寻找的是什么：</p>
<ul>
<li>什么是对象(如何将项目分成多个组成部分？)</li>
<li>它们的接口是什么？(需要向每个对象发送什么信息？)</li>
</ul>
<p>整个过程可以分5个阶段完成，阶段0只是使用一些结构的初始约定。</p>
<p><strong>1.9.1 第0阶段：制定计划</strong></p>
<p>我们必须首先决定在此过程中应当有哪些步骤。无论建造什么系统，不管如何复杂，都有其基本的目的，有其要处理的业务，有所满足的基本需要。通过各种观察，我们将最终找出它的核心，通常简单而又直接。</p>
<p>这个相当重要，因为它设定了项目的基调，这是一种任务陈述。我们不必一开始就让它正确，但是要不停地努力使其越来越正确。</p>
<p><strong>1.9.2 第1阶段：我们在做什么</strong></p>
<p>这一阶段我们有必要把注意力始终放在核心问提上：确定这个系统要做什么。为此，最有价值的工具是一组所谓的“用例(use case)”。用例之明了系统中的关键特性，它们将展现我们使用的一些节本的类。它们实际上是对类似于下列问题的描述性回答：</p>
<ul>
<li>“谁将使用这个系统？”</li>
<li>“执行者用这个系统做什么？”</li>
<li>“执行者如何用这个系统工作？”</li>
<li>“如果其他人也做这件事，或者同一个执行者有不同的目标，该怎么办？(揭示变化)”</li>
<li>“当使用这个系统时，会发生什么问题？(揭示异常)”</li>
</ul>
<p>只要符合用户的使用感受，系统实际上如何实现并不重要。</p>
<p><strong>1.9.3 第2阶段：我们将如何建立对象</strong></p>
<p>在这一阶段，我们必须作出设计，描述这些类和它们如何交互。确定类和交互的出色技术就是：<br>类职责协同(Class-Responsibility-Collaboration，CRC)卡片。</p>
<p>这个技术非常简单：只要有一组小空白卡片，在上面书写。每张卡片描述一个类，所写的内容有：</p>
<ul>
<li>类的名字。体现类行为的本质，一目了然的作用。</li>
<li>类的职责。它应当做什么。通常，它可以仅由成员函数的名字陈述。</li>
<li>类的协同：它与其他类有哪些交互？如果一张小卡片上放不下类所需要的信息，那么这个类就太复杂了(或者是考虑过细了，或者应当创建多个类)。理想的类应该一目了然。</li>
</ul>
<p>对象开发准则：</p>
<ul>
<li>让特定问题生成一个类，然后在解决其他问题期间让这个类生长和成熟。</li>
<li>记住，发现所需要的类(和它们的接口)，是设计系统的主要内容。如果已经有了那些类，这个项目就不困难了。</li>
<li>不要强迫自己在一开始就知道每一件事情，应当不断学习。</li>
<li>开始编程，让一部分能够运行，这样就可以证明或否定已生成的设计。不要害怕过程型大杂烩式的代码──类的隔离性可以控制它们。坏的类不会破坏好的类。</li>
<li>尽量保持简单。具有明显用途的不太清楚的对象比很复杂的接口好。从小的和简单的类开始，当我们对它有了较好的理解时再拓展这个类接口，但是很难从一个类中删去元素。</li>
</ul>
<p><strong>1.9.4 第3阶段：创建核心</strong></p>
<p>这是从粗线条设计向便宜和执行可执行代码体的最初转换阶段，特别是，它将证明或者否定我们的体系结构。这不是一遍的过程，而是反复地建立系统的一系列步骤的开始。</p>
<p><strong>1.9.5 第4阶段：迭代用例</strong></p>
<p>一旦代码框架运行起来，我们增加的每一组特征本身就是一个小项目。在一次迭代(iteration)期间，我们增加一组特征，一次迭代是一个相当短的开发时期。</p>
<p>理想情况下，每次迭代为一到三个星期，在这个期间的最后，我们得到一个集成的、测试过的、比前一周期有更多功能的系统。</p>
<p>通过这些过程，我们可以更早地揭露和解决严重问题，客户有足够的机会改变它们的意见，程序员会更满意，能更精确地掌握项目。</p>
<p><strong>1.9.6 第5阶段：进化</strong></p>
<p>这是开发周期中，传统上称为“维护”的一个阶段。我们不可能第一次就使软件正确，所以应当为学习、返工和修改留有余地。</p>
<p>“使软件正确”的意思不只是使程序按照要求和用例工作，还意味着我们理解代码的内部结构，并且认识到它能很好地协同工作，没有拙笨的语法和过大的对象，也没有难看的暴露的代码。</p>
<p><strong>1.9.7 计划的回报</strong></p>
<p>提出一个漂亮的方案感觉上更接近于艺术，而不是技术。精致总是有回报的，这不是一种虚浮的追求。它不仅给除了一个容易建造和调试的程序，而且容易理解和维护，这就是其经济价值的体现。</p>
<h3 id="1-10-极限编程-eXtreme-Programming-XP"><a href="#1-10-极限编程-eXtreme-Programming-XP" class="headerlink" title="1.10 极限编程(eXtreme Programming,XP)"></a>1.10 极限编程(eXtreme Programming,XP)</h3><p>XP既是程序设计工作的哲学，又是做程序设计的一组原则。有两个原则最重要：“先写测试”和“结对编程”。</p>
<p>先写测试有两个及其重要的作用：</p>
<ul>
<li>它强制类的接口有清楚的定义。</li>
<li>能在每次编连软件时运行这些测试。</li>
</ul>
<p>结对编程(pair programming)反对深植于我们心中的个人主义，一个人编写代码时另一个人在思考。思考者的头脑中保持总体概念，不仅是手头问题这一段，而且还有XP指导方针。这种结对方式，使事情顺畅、有章可循。</p>
<h2 id="第2章-对象的创建与使用"><a href="#第2章-对象的创建与使用" class="headerlink" title="第2章 对象的创建与使用"></a>第2章 对象的创建与使用</h2><h3 id="2-1-语言的翻译过程"><a href="#2-1-语言的翻译过程" class="headerlink" title="2.1 语言的翻译过程"></a>2.1 语言的翻译过程</h3><p>任何一种计算机语言都要从某种人们理解的形式(源代码)转化成计算机能执行的形式(机器指令)。通常，翻译器分为两类：解释器(interpreter)和编译器(compiler)。</p>
<p><strong>解释器(interpreter)</strong></p>
<p>将源代码转化成一些动作并立即执行这些动作。使用解释器有许多好处。从写代码到执行代码的转换几乎能立即完成，并且源代码总是显存，所以一旦出现错误，解释器能很容易地指出。另外的优点是较好的交互性和适于快速程序开发。</p>
<p>做大项目时候就有某些局限性。要求一次输入整个源代码，一旦出现错误，就很难调试。</p>
<p><strong>编译器(compiler)</strong></p>
<p>编译器直接把源代码转化成汇编语言或机器指令。某些语言可以分别编译各段程序，最后使用连接器(linker)把各段程序连接成一个完整的可执行程序。这个过程称为分段编译(separate compilation)。</p>
<p>某些语言(特别是C/C++)编译时，首先要对源代码执行预处理。预处理器(preprocessor)是一个简单的程序，用程序员(利用预处理器指令)定义好的模式代替源代码中的模式。</p>
<p>编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元并把它们按树形结构组织起来。有时候会在编译的第一遍和第二遍之间使用全局优化器(global optimizer)来生成更短、更快的代码。</p>
<p>编译的第二遍由代码生成器(code generator)遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。</p>
<p>类型检查(type checking)是编译器在第一遍中完成的。类型检查是检查函数参数是否正确使用，以防止许多程序设计错误。由于类型检查是在编译阶段而不是程序运行阶段进行的，所以称之为静态类型检查(static type checking)。在C++里可以不使用静态类型检查。我们可以自己做动态类型检查──这只需要写一些代码。</p>
<h2 id="第3章-C-中的C"><a href="#第3章-C-中的C" class="headerlink" title="第3章 C++中的C"></a>第3章 C++中的C</h2><h3 id="3-1-指定存储空间分配"><a href="#3-1-指定存储空间分配" class="headerlink" title="3.1 指定存储空间分配"></a>3.1 指定存储空间分配</h3><p><strong>3.1.1 全局变量</strong></p>
<p>全局变量是在所有函数体的外部定义的，程序的所有部分(甚至其他文件中的代码)都可以使用。全局变量不受作用域的影响，总是可用的(也就是说，全局变量的生命期一直到程序的结束)。如果在一个文件中存在全局变量，那么这个文件可以使用这个数据。</p>
<p><strong>3.1.2 局部变量</strong></p>
<p>局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量(automatic variable)，因为它们在进入作用域时自动生成，离开作用域时自动消失。<br>寄存器变量是一种局部变量，最好避免使用关键字register。</p>
<p><strong>3.1.3 静态变量</strong></p>
<p>关键字static有一些独特的意义。通常，函数中定义的局部变量在函数作用域结束时小时。当再次调用这个函数时，会重新创建该变量的存储空间，其值会被重新初始化。如果想使局部变量的值在程序的整个生命期里仍然存在，就可以定义函数的局部变量为static，并给它一个初始值。初始化只在函数第一次调用时执行，函数调用之间变量的值保持不变。用这种方式，函数可以“记住”函数调用之间的一些信息片段。</p>
<p>static变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易地改变。这会使错误局部化。</p>
<p>static的第二层意思和前面的含义相关，即“在某个作用域外不可访问”。当应用static于函数名和所有函数外部的变量时，它的意思是“在文件的外部不可以使用这个名字”。函数名或变量是局部于文件的；我们说它具有文件作用域(file scope)。即使在另一个文件用extern声明，连接器也不会找到它。</p>
<p><strong>3.1.4 外部变量</strong></p>
<p>extern关键字告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它，这个变量或函数可能在另一个文件中或者在当前文件的后面定义。</p>
<p><strong>连接(linkage)</strong></p>
<p>连接用连接器所见的方式描述存储空间。连结方式有两种：内部连接(internal linkage)和外部连接(external linkage)。内部连接意味着只对正被编译的文件创建存储空间。用内部连接，别的文件可以使用相同的标识符或全局变量，连接器不会发现冲突──也就是为每一个标识符创建单独的存储空间。在C和C++中，内部连接是由关键字static指定的。</p>
<p>外部连接意味着所有被编译过的文件创建一片单独的存储空间。一旦创建存储空间，连接器必须解决所有对这片存储空间的引用。</p>
<h3 id="3-2-运算符及其使用"><a href="#3-2-运算符及其使用" class="headerlink" title="3.2 运算符及其使用"></a>3.2 运算符及其使用</h3><p>所有的运算符都会从它们的操作数中产生一个值。除了赋值、自增、自减运算符之外，运算符所产生的值不会修改操作数。修改操作数被称为副作用(side effect)。一般使用修改操作数的运算就是为了产生这种副作用。</p>
<p><strong>3.2.1 逗号运算符</strong></p>
<p>可以作为一个运算符用于分隔表达式。在这种情况下，它只产生最后一个表达式的值。在逗号分隔的列表中，其余的表达式的计算只完成它们的副作用。</p>
<p>通常，除了作为一个分隔符，逗号最好不作他用，因为人们不习惯把它看作是运算符。</p>
<h2 id="第4章-数据抽象"><a href="#第4章-数据抽象" class="headerlink" title="第4章 数据抽象"></a>第4章 数据抽象</h2><p>库只是他人已经写好的一些代码，按照某种方式包装在一起。通常，最小的包是带有拓展名(如lib)的文件和向编译器声明库中有什么的一个或多个头文件。在跨越多种体系结构的平台(例如Linux和Unix)上，通常，提供库的最明智的方法是使用源代码，这样它就能在心的目标机上被重新配置和编译。</p>
<p>所以，库大概是改进生产效率的最重要的方法。C++的主要设计目标之一就是使库使用起来更加容易。</p>
<h3 id="4-1-什么是对象"><a href="#4-1-什么是对象" class="headerlink" title="4.1 什么是对象"></a>4.1 什么是对象</h3><p>在C++中，对象就是变量，它的最纯正的定义是“一块存储区”(更明确的说法是，“对象必须有惟一的标识”，在C++中是一个惟一的地址)。它是一块空间，在这里能存放数据，而且还隐含着对这些数据进行处理的操作。</p>
<h3 id="4-2-抽象数据类型"><a href="#4-2-抽象数据类型" class="headerlink" title="4.2 抽象数据类型"></a>4.2 抽象数据类型</h3><p>将数据连同函数捆绑在一起的能力可以用于创建新的数据类型。这常常被称为封装(encapsulation)。称为抽象数据类型(abstract data type)，也许这是因为它能允许从问题空间抽象概念到解空间。对抽象数据类型[有时称为用户定义类型(user-defined type)]的类型检查就像对内建类型的类型检查一样严格。</p>
<h3 id="4-3-头文件"><a href="#4-3-头文件" class="headerlink" title="4.3 头文件"></a>4.3 头文件</h3><p>头文件是我们和我们的库的用户之间的合约。这份合约描述了我们的数据结构，为函数调用贵点了参数和返回值。</p>
<p>通过要求我们在使用结构和函数之前声明所有这些结构和函数，在定义成员函数之前声明这些成员函数，编译器强制履行这个合约。</p>
<p>放到头文件中的基本原则是“只限于声明”，即只限于对编译器的信息，不涉及通过生成代码或创建变量而分配存储的任何信息。</p>
<p><strong>4.3.1 头文件的标准</strong></p>
<p>对于包含结构的每个头文件，应当首先检查这个头文件是否已经包含在特定的cpp文件中，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_FLAG</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_FLAG</span></div><div class="line"><span class="comment">// Type declaration here...</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HEADER_FLAG</span></span></div></pre></td></tr></table></figure>
<p>防止多次包含的这些预处理器语句常常称为包含守卫(include guard)。</p>
<h2 id="第5章-隐藏实现"><a href="#第5章-隐藏实现" class="headerlink" title="第5章 隐藏实现"></a>第5章 隐藏实现</h2><h3 id="5-1-设置限制"><a href="#5-1-设置限制" class="headerlink" title="5.1 设置限制"></a>5.1 设置限制</h3><p>在任何关系中，设立相关各方面都遵从的边界是很重要的。需要控制对结构成员的访问有两个理由：一是让客户程序员远离一些它们不需要使用的工具，这些工具对数据类型内部的处理来说是必需的，但对客户程序员解决特定问题的接口却不是必须的。另一个理由是允许库的设计者改变struct的内部实现，而不必担心会对客户程序员产生影响。</p>
<h3 id="5-2-C-的访问控制"><a href="#5-2-C-的访问控制" class="headerlink" title="5.2 C++的访问控制"></a>5.2 C++的访问控制</h3><p>引进了三个访问说明符(access specifier)：public、private和protected。无论什么时候使用访问说明符，后面必须加一个冒号。</p>
<ul>
<li><code>public</code> 意味着在其后声明的所有成员可以被所有的人访问。</li>
<li><code>private</code> 关键字则意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问。</li>
<li><code>protected</code> 与 <code>private</code> 基本相似，只有一点不同：继承的结构可以访问 protected 成员，但不能访问 private 成员。</li>
</ul>
<h3 id="5-3-友元"><a href="#5-3-友元" class="headerlink" title="5.3 友元"></a>5.3 友元</h3><p>如果想允许显示地不属于当前结构的一个成员函数访问当前结构中的数据，可以在该结构内部声明这个函数为friend(友元)。注意，一个 friend 必须在一个结构内声明，这一点很重要。</p>
<p><strong>5.3.1 嵌套友元</strong></p>
<p>嵌套的结构并不能自动获得访问private成员的权限。要获得访问私有成员的权限，必须存手特定的规则：首先声明(而不定义)一个嵌套的结构，然后声明它是全局范围使用的一个friend，最后定义这个结构。结构的定义必须与friend声明分开，否则编译器将不把它看做成员。</p>
<p><strong>5.3.2 它是纯面向对象的吗</strong></p>
<p>C++ 不是完全的面向对象语言，而只是一个混合产品。增加 friend 关键字就是为了用来解决一些实际问题。这也说明了这种语言是不纯的。毕竟 C++ 语言的设计目的是使用，而不是追求理想的抽象。</p>
<h3 id="5-4-对象布局"><a href="#5-4-对象布局" class="headerlink" title="5.4 对象布局"></a>5.4 对象布局</h3><p>访问说明符是结构的一部分，它们并不影响从这个结构创建的对象。程序开始运行之前，所有的访问说明信息都消失了。访问说明信息通常是在编译期间消失的。</p>
<p>一般说来，在程序员编写程序时，依赖特定实现的任何东西都是不合适的。如确有必要，这些特定实现部分应封装在一个结构之内，这样当环境改变时，只需修改一个地方就行了。</p>
<h3 id="5-5-类"><a href="#5-5-类" class="headerlink" title="5.5 类"></a>5.5 类</h3><p>访问控制通常是指实现细节的隐藏(implementation hiding)。将函数包含到一个结构内(常称为封装)来产生一种带数据和操作的数据类型，由访问控制在该数据类型之内确定边界。</p>
<p>然后在 C+ +中的 class 逐渐变成了一个非必要的关键字。它和 struct 的每个方面都是一样的，除了 class 中的成员默认为 private，而 struct 中的成员默认为 public。</p>
<h3 id="5-6-句柄类"><a href="#5-6-句柄类" class="headerlink" title="5.6 句柄类"></a>5.6 句柄类</h3><p>C++ 中的访问控制允许将实现部分与接口部分分开，但实现部分的隐藏是不完全的。编译器仍然必须知道一个对象所有部分的声明。但 C++ 要尽可能多地在编译期间作静态类型检查。这意味着尽早捕获错误，也意味着程序具有更高的效率。然后包含似有实现部分会带来两个影响：一是既是客户程序员不能轻易地访问私有实现部分，但可以看到它；二是造成一些不必要的重复编译。</p>
<p><strong>5.6.1 隐藏实现</strong></p>
<p>有些项目不可让最终客户程序员看到其实现部分，就有必要把一个变一号的实际结构放在实现文件中，而不是让其暴露在头文件中。</p>
<p><strong>5.6.2 减少重复编译</strong></p>
<p>在我们的编译环境中，当一个文件被修改，或它所依赖的头文件被修改时，项目管理员需要重复编译该文件。这意味着程序员无论何时修改了一个类，无论修改的是公共的接口部分，还是私有成员的声明部分，他都必须再次编译包含头文件的所有文件。这就是通常所说的易碎的基类问题(fragile base-class problem)。对于一个大的项目而言，在开发初期这可能非常难以处理，因为内部实现部分可能需要经常改动。如果这个项目非常大，用于编译的时间过多可能妨碍项目的快速转型。</p>
<p>解决这个问题的技术有时称为句柄类(handle class)或称为“Cheshire cat”。有关实现的任何东西都消失了，只剩一个单指针“smile”。该指针指向一个结构，该结构的定义与其所有的成员函数的定义一同出现在实现文件中。这样，只要接口部分不改变，头文件就不需变动，而实现部分可以按需要任意更改，完成后只需要对实现文件进行重新编译，然后重新连接到项目中。</p>
<h2 id="第6章-初始化与清除"><a href="#第6章-初始化与清除" class="headerlink" title="第6章 初始化与清除"></a>第6章 初始化与清除</h2><p>C++中，初始化和清楚的概念是简化库的使用的关键所在，并可以减少那些在客户程序员忘记去完成这些操作时会引起的细微错误。</p>
<h3 id="6-1-用构造函数确保初始化"><a href="#6-1-用构造函数确保初始化" class="headerlink" title="6.1 用构造函数确保初始化"></a>6.1 用构造函数确保初始化</h3><p>类的设计者可以通过提供一个叫做构造函数(constructor)的特殊函数来保证每个对象都被初始化。如果一个类有构造函数，编译器在创建对象时就自动调用这一函数。构造函数的名字与类的名字一样。这样的函数在初始化时会被自动调用。</p>
<p>构造函数和析构函数是两个非常特殊的函数：它们没有返回值。</p>
<p>在程序中创建和消除一个对象的行为非常特殊，就像出生和死亡，而且总是由编译器来调用这些函数以确保它们被执行。如果它们有返回值，要么编译器必须知道如何处理返回值，要么就只能由客户程序员子集来显式的调用构造函数与析构函数，这样一来，安全性就被破坏了。</p>
<h3 id="6-2-用析构函数确保清除"><a href="#6-2-用析构函数确保清除" class="headerlink" title="6.2 用析构函数确保清除"></a>6.2 用析构函数确保清除</h3><p>在一个库中，对于一个曾经用过的对象，如果不做处理，对象就永远不会消失。在C++中，清除就像初始化一样重要，它通过析构函数来保证清除的执行。</p>
<p>析构函数的语言与构造函数一样，用类的名字作为函数名。然而析构函数前面加上一个代字号(～)，以和构造函数区别。</p>
<p>当对象超出它的作用域时，编译器将自动调用析构函数。</p>
<h3 id="6-3-清除定义块"><a href="#6-3-清除定义块" class="headerlink" title="6.3 清除定义块"></a>6.3 清除定义块</h3><p>在C++中，应该在尽可能靠近变量的使用点处定义变量，并在定义时就初始化。这是出于安全性的考虑，通过减少变量在块中的生命周期，就可以减少该变量在块的其他地方被误用的机会。</p>
<h3 id="6-4-集合初始化"><a href="#6-4-集合初始化" class="headerlink" title="6.4 集合初始化"></a>6.4 集合初始化</h3><p>集合(aggregate)就是多个事物聚集在一起。这个定义包括混合类型的集合。</p>
<h3 id="6-5-默认构造函数"><a href="#6-5-默认构造函数" class="headerlink" title="6.5 默认构造函数"></a>6.5 默认构造函数</h3><p>默认构造函数(default constructor)就是不带任何参数的构造函数。一旦有了一个构造函数，编译器就会确保不关在什么情况下它总是会被调用。</p>
<p>尽管编译器会创建一个默认的构造函数，但是编译器合成的构造函数的行为很少是我们期望的。我们应该把这个特征看成是一个安全网，但尽量少用它。一般说来，应该明确地定义子集的构造函数，而不让编译器来完成。</p>
<h2 id="第7章-函数重载与默认参数"><a href="#第7章-函数重载与默认参数" class="headerlink" title="第7章 函数重载与默认参数"></a>第7章 函数重载与默认参数</h2><p>能使名字方便使用，是任何程序设计语言的一个重要特征。</p>
<p>尽管函数重载对构造函数来说是必须的，但是它仍然是一个通用的方便手段，并可以与任意函数一起使用。另外，函数重载意味着，我们有两个库，它们都有同名的函数，只要它们的参数列表不同就不会发生冲突。</p>
<h3 id="7-1-名字修饰"><a href="#7-1-名字修饰" class="headerlink" title="7.1 名字修饰"></a>7.1 名字修饰</h3><p>可以对不同的函数用同样的名字，只要求函数的参数不同，编译器会修饰这些名字、范围和参数来产生内部名以供它和连接器使用。</p>
<p><strong>7.1.1 用返回值重载</strong></p>
<p>仅仅依靠返回值来重载函数实在过于微妙，所以在 C++ 中禁止这样做。</p>
<p><strong>7.1.2 类型安全连接</strong></p>
<p>对名字修饰还可以带来一个额外的好处。在 C 中，如果用户错误地声明了一个函数，或者更糟糕地，一个函数还没声明就调用了，而编译器则按照函数被调用的方式去推断函数的声明。若这样的推断不正确，那么就会变成一个很难发现的错误。</p>
<p>在 C++ 中，所有的恶函数在被使用前都必须事先声明，因此出现上述情况的机会大大减少了。名字修饰会给我们提供一个安全网，这也就是人们常说的类型安全连接(type-safe linkage)。</p>
<h3 id="7-2-默认参数"><a href="#7-2-默认参数" class="headerlink" title="7.2 默认参数"></a>7.2 默认参数</h3><p>默认参数(default argument)是在函数声明时就已给定的一个值，如果在调用函数时没有指定这一参数的值，编译器就会自动地插上这个值。</p>
<p>在使用默认参数时必须记住两条规则。第一，只有参数列表的后部参数才是可默认的，也就是说，不可以在一个默认参数后面又跟一个非默认的参数。第二，一旦在一个函数调用中开始使用默认参数，那么这个参数后面的所有参数都必须是默认的。</p>
<p>默认参数只能放在函数声明中，通常在一个头文件中。编译器必须在使用该函数之前知道默认值。有时人们为了阅读方便在函数定义处放上你一些默认的注释值。</p>
<h2 id="第8章-常量"><a href="#第8章-常量" class="headerlink" title="第8章 常量"></a>第8章 常量</h2><p>常量概念(由关键字const表示)是为了使程序员能够在变和不变之间画一条界线。这在C++程序设计项目中提供了安全性和可控性。</p>
<h3 id="8-1-指针"><a href="#8-1-指针" class="headerlink" title="8.1 指针"></a>8.1 指针</h3><p>可以使指针成为 const。当处理 const 指针时，编译器仍将努力避免存储分配并进行常量折叠。如果程序员以后想在程序代码中改变 const 这种指针的使用，编译器将给出通知。这大大增加了安全性。</p>
<p>当使用带有指针的 const 时，有两种选择：const 修饰指针正指向的对象，或者 const 修饰在指针里存储的地址。</p>
<p><strong>8.1.1 指向const的指针</strong></p>
<p>定义指针的技巧是在标识符的开始处读它并从里向外读。<code>const</code> 修饰“最靠近”它的那个。如：<code>const int* u;</code> 可以读成：<code>u</code> 是一个指针，它指向一个 <code>const int</code>。</p>
<h3 id="8-2-const-指针"><a href="#8-2-const-指针" class="headerlink" title="8.2 const 指针"></a>8.2 const 指针</h3><p>使指针本身称为一个 const 指针，必须把 cons t标明的部分放在 <code>*</code> 的右边。如：<code>int d = 1; int * const w = &amp;d;</code> 可以读成 <code>w</code> 是一个 <code>const</code> 指针指向一个 <code>int</code>。<br>因为指针本身现在是 <code>const</code>指针，编译器要求给它一个初始值，这个值在指针生命期内不变。然而要改变它所指向的值是可以的：<code>*w = 2;</code></p>
<p>当然也可以把一个const指针指向一个const对象。</p>
<p>如果可能的话，一行只定义一个指针，并尽可能在定义时初始化。</p>
<p><strong>8.1.3 赋值和类型检查</strong></p>
<p>可以把一个非const对象的地址赋给一个const指针，因为也许有时不想改变某些可以改变的东西。然后不能把一个const对象的地址赋给一个非const指针，因为这样做可能通过被赋值的指针改变这个对象的值。</p>
<h3 id="8-3-函数参数和返回值"><a href="#8-3-函数参数和返回值" class="headerlink" title="8.3 函数参数和返回值"></a>8.3 函数参数和返回值</h3><p><strong>8.3.1 传递 const 值</strong></p>
<p>如果函数是按值传递，则可用指定参数是 const 的。这里参数不能被改变。所以它其实是函数创建者的工具，而不是函数调用者的工具。</p>
<p>为了不使调用者很小，在函数内部用 const 限定参数优于在参数表里用 const 限定参数。可以用一个指针来实现，但更好的语法形式是“引用”。简而言之，引用相一个被自动间接引用的常量指针，它的作用是成为对象的别名。为建立一个引用，在定义里使用 <code>&amp;</code>。</p>
<p><strong>8.3.2 返回 const 值</strong></p>
<p>如果一个函数的返回值是一个常量(const)，这就约定了函数框架里的原变量不会被修改。另外，因为这是按值返回的，所以这个变量被制成副本，舍得初值不会被返回值所修改。</p>
<p>对于内部类型来说，按值返回的是否是一个 const，是无关紧要的，所以按值返回一个内部类型时，应该去掉 const，从而不使客户程序员混淆。</p>
<p>当处理用户定义的类型时，按值返回常量是很重要的。如果一个函数按值返回一个类对象为 const时，那么这个函数的返回值不能是一个左值(不能被赋值或修改)。</p>
<p><strong>8.3.3 传递和返回地址</strong></p>
<p>如果传递或返回一个地址(一个指针或一个引用)，客户程序员去取地址并修改其初值是可能的。如果使这个指针或者引用成为 const，就会阻止这类事的发生，这是非常重要的事情，事实上，无论什么时候传递一个地址给一个函数，都应该尽可能用 const 修饰它。如果不这样做，就不能以 const 指针参数的方式使用这个函数。</p>
<h3 id="8-4-类"><a href="#8-4-类" class="headerlink" title="8.4 类"></a>8.4 类</h3><p><strong>8.4.1 类里的 const</strong></p>
<p>常数表达式使用常量的地方之一是在类里。典型的例子是在一个类里建立一个数组，并用 <code>const</code> 代替 <code>#define</code> 设置数组大小。数组大小一直隐藏在类里，这样，如果用 size 表示数组大小，就可以把 size 这个名字用在另一个类里而不发生冲突。</p>
<p>读者可能认为合乎逻辑的选择是把一个 const 放在类里。但这样不会产生预期的效果。在一个类里，const 又部分恢复到它在C语言中的含义。它在每个类对象里分配存储并代表一个值，这个值一旦被初始化以后就不能改变。在一个类里使用 const 意味着“在这个对象生命期内，它是一个常量”。然而，对这个常量来讲，每个不同的对象可以含有一个不同的值。</p>
<p>这样，在一个类里建立一个普通的(非static的)const时，不能给它初值。这个初始化工作比须在构造函数里进行，当然，要在构造函数的某个特别的地方进行。因为 const 必须在建立它的地方被初始化，所以在构造函数的主体里，const 必定已被初始化了。否则，就只有等待，直到在构造函数主体以后的某个地方给它初始化，这意味着过一会儿才给 const 初始化。当然，无法防止在构造函数主体的不同地方改变 const 的值。</p>
<p><strong>构造函数初始化列表</strong></p>
<p>在构造函数里有个专门初始化的地方，这就是构造函数初始化列表(constructor initializer list)，起初用在机成立。构造函数初始化列表是一个出现在函数参数表和冒号后，但在构造函数主体开头的花括号前的“函数调用列表”。这提醒人们，表里的初始化发生在构造函数的任何代码执行之前。这是初始化所有 <code>const</code> 的地方，若 <code>size</code> 是 <code>Fred</code> 类的一个 <code>const</code> 成员的话，其正确形式是：<code>Fred::Fred(int sz) : size(sz){}</code></p>
<p>把一个内部类型风装载一个类里以保证用构造函数初始化，这是很有用的。</p>
<p><strong>8.4.2 编译期间类里的常量</strong></p>
<p>若要让类有编译期间的常量成员，就要求使用另外一个关键字 <code>static</code>。在这种情况下，关键字<code>static</code> 意味着“不管类的对象被创建多少次，都只有一个实例”。因此，一个内部类型的 <code>static const</code> 可以看作一个编译期间的常量。</p>
<p>必须在 <code>static const</code> 定义的地方对它进行初始化。</p>
<p><strong>8.4.3 const对象和成员函数</strong></p>
<p>如果声明一个成员函数为 <code>const</code> (修饰符 <code>const</code> 放在函数参数表的后面)，则等于告诉编译器该成员函数可以为一个 <code>const</code> 对象所调用。一个没有被明确声明为 <code>const</code> 的成员函数被堪称是将要修改数据成员的函数，而且编译器不允许它为一个 <code>const</code> 对象所调用。</p>
<p>关键字 <code>const</code> 必须同样的方式重复出现在定义里，否则编译器把它看成一个不同的函数！</p>
<p>一个 <code>const</code> 成员函数调用 <code>const</code> 和非 <code>const</code> 对象是安全的，因此，可以把它看做成员函数的最一般形式。不修改数据成员的任何函数都应该把它们声明为 <code>const</code>，这样它可以和 <code>const</code> 对象一起使用。</p>
<h3 id="8-5-volatile"><a href="#8-5-volatile" class="headerlink" title="8.5 volatile"></a>8.5 volatile</h3><p><code>volatile</code> 的语法与 const 是一样的，但是 volatile 的意思是“在编译器认识的范围外，这个数据可以被改变”。不知何故，环境正在改变数据(可能通过多任务、多线程或者中断处理)，所以，<code>volatile</code> 告诉编译器不要擅自作出有关该数据的任何假定，优化期间尤其如此。</p>
<h2 id="第9章-内联函数"><a href="#第9章-内联函数" class="headerlink" title="第9章 内联函数"></a>第9章 内联函数</h2><p>C++ 从 C 中集成的一个重要特征是效率。加入 C++ 的效率显著地低于 C 的效率，那么就会有很大一批程序员不去使用它。</p>
<p>为了既保持预处理器宏的效率又增加安全性、而且还能像一般成员函数一样可以在类里访问自如，C++ 引入了内联函数(inline function)</p>
<h3 id="9-1-预处理器的缺陷"><a href="#9-1-预处理器的缺陷" class="headerlink" title="9.1 预处理器的缺陷"></a>9.1 预处理器的缺陷</h3><p>预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器的行为一样。</p>
<h3 id="9-2-内联函数"><a href="#9-2-内联函数" class="headerlink" title="9.2 内联函数"></a>9.2 内联函数</h3><p>在解决 C++ 中宏访问 <code>private</code> 类成员的问题过程中，所有和预处理器宏有关的问题也随之排除了。这是通过使宏被编译器控制来实现的。在 C++ 中，宏的概念是作为内联函数(inline function)来实现的，而内联函数无论从哪一方面上说都是真正的函数。</p>
<p>任何在类中定义的函数自动成为内联函数，但也可以在非类的函数前面加上inline关键字使之称为内联函数。但为了使之有效，必须使函数体和声明结合在一起，否则，编译器将它作为普通函数对待。</p>
<p>一般应该把内联定义放在头文件里。当编译器看到这个定义时，它把函数类型(函数名+返回值)和函数体放到符号表里。当使用函数时，编译器检查以确保调用是正确的且返回值被正确使用，然后将函数调用替换为函数体，因而消除了开销。内联代码的确占用空间，但假如函数较小，这实际上比为了一个普通函数调用而产生的代码(参数压栈和执行CALL)占用的空间还小。</p>
<p><strong>9.2.1 类内部的内联函数</strong></p>
<p>类内部的内联函数节省了在外部定义成员函数的额外步骤，所以我们一定想在类声明内每一处都使用内联函数。但应记住，使用内联函数的目的是减少函数调用的开销。但是，假如函数较大，由于需要在调用函数的每一处重复复制代码，这样将使代码膨胀，在速度方面获得的好处就会减少。</p>
<p><strong>9.2.2 访问函数</strong></p>
<p>在类中内联函数的最重要的使用之一是用做访问函数(access function)。这是一个小函数，它容许读或修改对象状态──即一个或几个内部变量。即最通常所说的set与get方法(修改器和访问器)。</p>
<h3 id="9-3-内联函数和编译器"><a href="#9-3-内联函数和编译器" class="headerlink" title="9.3 内联函数和编译器"></a>9.3 内联函数和编译器</h3><p>对于函数，编译器在它的符号表里放入函数类型(即包括名字和参数类型的函数原型及函数的返回类型)。另外，当编译器看到内联函数和对内联函数体的分析没有发现错误时，就将对应于函数体的代码也放入符号表。代码是以源程序形式存放还是以编译过的汇编指令形式存放取决于编译器。</p>
<p>当调用一个内联函数时，编译器首先确保调用正确，即所有的参数类型必须满足：要么与函数参数表中的参数类型一样，要么编译器能够将其转换为正确类型，并且返回值在目标表达式里应该是正确类型或可改变为正确类型。</p>
<p><strong>9.3.1 限制</strong></p>
<p>有两种编译器不能执行内联的情况。在这些情况下，它就像对非内联函数一样，根据内联函数定义和为函数建立存储空间，简单地将其转换为函数的普通形式。</p>
<p>加入函数太复杂，编译器将不能执行内联。这取决于特定的编译器，但对大多数编译器这时都回放弃内联方式，因为这时内联可能不能提高任何效率。一般地，任何种类的循环都被认为太复杂。</p>
<p>内联仅是编译器的一个建议，编译器不会被强迫内联任何代码。一个好的编译器将会内联小的、简单的函数，同时明智地忽略那些太复杂的内联。这将给我们想要的结果──具有宏效率的函数调用的真正语义学。</p>
<p><strong>9.3.2 向前引用</strong></p>
<p>当一个内联函数在类中向前引用一个还没有声明的函数时，是可以正常工作的，因为C++语言规定：只有在类声明结束后，其中的内联函数才会被计算。</p>
<h2 id="第10章-名字控制"><a href="#第10章-名字控制" class="headerlink" title="第10章 名字控制"></a>第10章 名字控制</h2><p>创建名字是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量的名字。</p>
<p>关于 <code>static</code> 的所有使用最基本的概念是指“位置不变的某个东西”，不管这里是指在内存中的物理位置还是指在文件中的可见性。</p>
<h3 id="10-1-来自-C-语言中的静态元素"><a href="#10-1-来自-C-语言中的静态元素" class="headerlink" title="10.1 来自 C 语言中的静态元素"></a>10.1 来自 C 语言中的静态元素</h3><p>在 C 和 C++ 中，static 都有两种基本的含义，并且这两种含义经常是相互冲突的：</p>
<ul>
<li>在固定的地址上进行存储分配，也就是说对象是在一个特殊的静态数据区(static data area)上创建的，而不是每次函数调用时在堆栈上产生的。这也是静态存储的概念。</li>
<li>对一个特定的编译单位来说是局部的。这样，<code>static</code> 控制名字的可见性(visibility)，所以这个名字在这个单元或类外是不可见的。这也描述了连接的概念，它决定连接器将看到哪些名字。</li>
</ul>
<p><strong>10.1.1 函数内部的静态变量</strong></p>
<p>通常，在函数体内定义一个局部变量时，编译器在每次函数调用时使堆栈的指针下移到一个适当的位置，为这些局部变量非配内存。如果这个变量又一个初始化表达式，那么每当程序运行到此处，初始化就被执行。</p>
<p>然而，有时想在两次函数调用之间保留一个变量的值，可以通过定义一个全局变量来实现，但这样一来，这个变量就不仅仅只受到这个函数的控制。C和C++都允许在函数内部定义一个static对象，这个对象将存储在静态数据区中，而不是在堆栈中。这个对象只在第一次调用是初始化一次，以后它将在两次函数调用之间保持它的值。</p>
<p><strong>10.1.2 控制连接</strong></p>
<p>一般情况下，在文件作用域(file scope)内的所有名字(即不嵌套在类或函数中的名字)对程序中的所有翻译单元来说都是可见的。这就是所谓的外部连接(external linkage)，因为在连接时这个名字对连接器来说是可见的，对单独的翻译单元来说，它是外部的。全局变量和普通函数都有外部连接。</p>
<p>在文件作用域内，一个被明确声明为 <code>static</code> 的对象或函数的名字对翻译单元来说是局部于该单元的。这些名字有内部连接(internal linkage)。</p>
<p>内部连接的一个好处是这个名字可以放在一个头文件中。</p>
<h2 id="第11章-引用和拷贝构造函数"><a href="#第11章-引用和拷贝构造函数" class="headerlink" title="第11章 引用和拷贝构造函数"></a>第11章 引用和拷贝构造函数</h2><h3 id="11-1-C-中的指针"><a href="#11-1-C-中的指针" class="headerlink" title="11.1 C++ 中的指针"></a>11.1 C++ 中的指针</h3><p>C 不允许随便地把一个类型的指针赋给另一个类型，但允许通过 <code>void*</code> 来实现。由于 C 的这种功能允许把任何一种类型看做别的类型处理，这就在类型系统中流下了一个大的漏洞。C++ 不允许这样做，如果真想把某种类型当作别的类型处理，则必须显示地使用类型转换。</p>
<h3 id="11-2-C-中的引用"><a href="#11-2-C-中的引用" class="headerlink" title="11.2 C++ 中的引用"></a>11.2 C++ 中的引用</h3><p>引用(reference)(&amp;)就像能自动地被编译器间接引用的常量型指针。它常用于函数的参数表中和函数的返回值，但也可以独立使用。</p>
<p>使用引用时有一定的规则：</p>
<ul>
<li>当引用被创建时，它必须被初始化(指针则可以在任何时候被初始化)。</li>
<li>一旦一个引用被初始化为指向一个对象，它就不能改变为另一个对象的引用(指针则可以在任何时候指向另一个对象)。</li>
<li>不可能有NULL引用。必须确保引用是和一块合法的存储单元关联。</li>
</ul>
<p><strong>11.2.1 函数中的引用</strong></p>
<p>最经常看见引用的地方是在函数参数和返回值中。当引用被用做函数参数时，在函数内任何对引用的更改将对函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。</p>
<p>如果从函数中返回一个引用，必须像从函数中返回一个指针来一样对待。当函数返回时，无论引用关连的是什么都应该存在，否则，将不知道指向哪一个内存。</p>
<p>若想要改变指针本身而不是它所指向的内容，函数参数变成指针的引用，用不着取得指针的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>*&amp; i)</span></span>&#123;i++&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> *i = <span class="number">0</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	increment(i);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; “i = ” &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>1.2.2 参数传递准则</strong></p>
<p>当给函数传递参数时，人们习惯上是通过常量引用来传递。这种简单习惯可以大大提高效率：传值方式需要调用构造函数和析构函数，然而，如果不想改变参数，则可以通过常量引用传递，它仅需要将地址压栈。</p>
<h3 id="11-3-拷贝构造函数"><a href="#11-3-拷贝构造函数" class="headerlink" title="11.3 拷贝构造函数"></a>11.3 拷贝构造函数</h3><p>这是一个更令人混淆的概念，常被称为X(X&amp;)(“X引用的X”)，在函数调用时，这个构造函数是控制通过传值方式传递和返回用户定义类型的根本所在。这是很重要的。</p>
<p><strong>11.3.1 按值传递和返回</strong></p>
<p>在 C 和 C++ 中，参数是从右向左进栈的，然后调用函数，调用代码负责清理栈中的参数。但是要注意，通过按值传递方式传递参数时，编译器简单地将参数拷贝压栈──编译器知道拷贝有多大，并知道如何对参数压栈，对它们正确拷贝。</p>
<h2 id="第13章-动态对象创建"><a href="#第13章-动态对象创建" class="headerlink" title="第13章 动态对象创建"></a>第13章 动态对象创建</h2><p>有时我们能知道程序中对象的确切数量、类型和生命期。但情况不总是这样。为了解决这个普遍的编程问题，在运行时可以创建和销毁对象是最基本的要求。C 提供了动态内存分配(dynamic memory allocation)函数 <code>malloc()</code> 和 <code>free()</code>，这些函数在运行时从堆(也称自由内存)中分配存储单元。</p>
<p>然而，在C++中这些函数将不能很好的运行。因为构造函数不允许我们向它传递内存地址来进行初始化。</p>
<p>C++ 是如何保证正确的初始化和清理，有允许我们在堆上动态创建对象呢？</p>
<p>答案是，使动态对象称为语言的核心。<code>malloc</code> 和 <code>free</code> 是库函数，因此不在编译器控制范围之内。然而，如果我们有一个完成动态内存分配及初始化组合动作的运算符和另一个完成清理及释放内存组合动作的运算符，编译器仍可以保证所有对象的构造函数和析构函数会被调用。</p>
<h3 id="13-1-对象创建"><a href="#13-1-对象创建" class="headerlink" title="13.1 对象创建"></a>13.1 对象创建</h3><p>当创建一个C++对象，会发生两件事：</p>
<ul>
<li>为对象分配内存。</li>
<li>调用构造函数来初始化那个内存。</li>
</ul>
<p>到目前为止，因该确保步骤2一定发生。C++强迫这样做是因为未初始化的对象是程序出错的主要原因。对象在那里和如何创建无关紧要──构造函数总是需要被调用。</p>
<p>然而，步骤1可以用几种方式或在可选择的时间发生：</p>
<ol>
<li>在静态存储区域，存储空间在程序开始之前就可以分配。这个存储空间在整个程序运行期间都存在。</li>
<li>无论何时到达一个特殊的执行点(左大括号)时，存储单元都可以在栈上被创建。除了执行点(右大括号)，这个存储单元自动被释放。这些栈分配运算内置于处理器的指令集中，非常有效。然而，在写程序时，必须知道需要多少个存储单元，以便编译器生成正确的指令。</li>
<li>存储单元也可以从一块称为堆(也被称为自由存储单元)的地方分配。这被称为动态内存分配。在运行时调用程序分配这些内存。这意味着可以在任何时候决定分配内存及分配多少内存。当然也需负责决定何时释放内存。这块内存的生存期由我们选择决定──而不受范围决定。</li>
</ol>
<p><strong>13.1.1 C 从堆中获取存储单元的方法</strong></p>
<p>为了在运行时动态分配内存，如 <code>malloc()</code> 和 <code>free()</code>。这些函数是有效的但较原始的，需要编程人员理解和小心使用。例如，必须对分配的空间进行显式地类型转换，还需要自行调用初始化的函数(构造函数并不能被显式地调用)。这很容易出错。所以，C 程序设计者常常在静态内存区域使用虚拟内存机制分配很大的变量数组以避免使用动态内存分配。为了在 C++ 中使得一般的程序员可以安全使用库函数而不费力，所以 C 的动态内存方法是不可接受的。</p>
<p><strong>13.1.2 operator new</strong></p>
<p>C++ 中的解决方案是把船舰一个对象所需的所有动作都结合在一个称为 new 的运算符里。当用new(new的表达式)创建一个对象时，它就在堆里为对象分配内存并为这块内存调用构造函数。等价于调用 <code>malloc()</code> 函数并调用构造函数。返回一个指向该对象的this指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType *fp = <span class="keyword">new</span> MyType;</div></pre></td></tr></table></figure>
<p>默认的 new 还进行检查以确信在传递地址给构造函数之前内存分配是成功的，所以不必显式地确定调用是否成功。</p>
<p>我们可以看到，在堆里创建对象的过程变得简单了──只是一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。这样在堆里创建一个对象何在栈里创建一个对象一样容易。</p>
<p><strong>13.1.3 operator delete</strong></p>
<p>delete 表达式首先调用析构函数，然后释放内存(常调用free())。正如 new 表达式返回一个指向对象的指针一样，delete 表达式需要一个对象的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">delete</span> fp；</div></pre></td></tr></table></figure>
<p><code>delete</code> 只用于删除由 <code>new</code> 创建的对象。</p>
<p><strong>13.1.4 内存管理的开销</strong></p>
<p>当在堆栈里自动创建对象时，对象的大小和它们的生存期被准确地内置在生成的代码里，这是因为编译器知道确切的类型、数量和范围。而在堆里创建的对象还包括另外的时间和空间的开销。以下是一个典型情况：</p>
<p>调用 <code>malloc()</code>，即从堆里搜索一块足够大的内存来满足请求，可以通过检查按某种方式排列的映射或目录来实现，这样的映射或目录用以显示内存的使用情况。这个过程很快但可能要试探几次，所以它可能是不确定的──即每次运行 <code>malloc()</code>并不是花费了相同的时间。</p>
<h3 id="13-2-用于数组的-new-和-delete"><a href="#13-2-用于数组的-new-和-delete" class="headerlink" title="13.2 用于数组的 new 和 delete"></a>13.2 用于数组的 new 和 delete</h3><p>在栈或堆上创建一个对象数组是同样容易的。但这里有一个限制条件：由于不带参数的构造函数必须被每一个对象调用，所以除了在栈上整体初始化外还必须有一个默认的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType *fp = <span class="keyword">new</span> MyType[<span class="number">100</span>];</div><div class="line">MyType *fp2 = <span class="keyword">new</span> MyType;</div></pre></td></tr></table></figure>
<p>我们知道其实fp和fp2是数组的起始地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">delete</span> fp2; <span class="comment">// OK</span></div><div class="line"><span class="keyword">delete</span> fp; <span class="comment">// Not the desired effect</span></div></pre></td></tr></table></figure>
<p>对于 fp 来说，另外 99 个析构函数没有调用，正确应该这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">delete</span> []fp；</div></pre></td></tr></table></figure>
<p>空的方括号告诉编译器产生代码，该代码的任务是将从数组创建时存放在某处的对象数量取回，并为数组的所有对象调用析构函数。</p>
<p><strong>13.2.1 使指针更像数组</strong></p>
<p>上面定义的 fp 可以被修改指向任何类型，但这对于一个数组的起始地址来说没有什么意义。一般来讲，把它定义为常量会更好些，因为这样任何修改指针的企图都会被认为出错。</p>
<p>使得指针指向的int不能修改(指针可以修改)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="keyword">const</span>* q = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];   or</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>* q = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div></pre></td></tr></table></figure>
<p>使得指针不能被修改(数组可以修改)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> q = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div></pre></td></tr></table></figure>
<h3 id="13-3-耗尽内存"><a href="#13-3-耗尽内存" class="headerlink" title="13.3 耗尽内存"></a>13.3 耗尽内存</h3><p>当 <code>operator new()</code> 找不到组够大的连续内存块来安排对象时，一个称为 new-handler 的特殊函数将会被调用。首先，检查指向函数的指针，如果指针非 0，那么它指向的函数将被调用。<br> new-handler 的默认动作是产生一个异常(throw an exception)。</p>
<h2 id="第14章-继承和组合"><a href="#第14章-继承和组合" class="headerlink" title="第14章 继承和组合"></a>第14章 继承和组合</h2><p>C++ 中最重要的特征之一是代码重用。但是如果希望更进一步，就不能仅仅用拷贝代码和修改代码的方法，而是要做更多的工作。</p>
<p>关键技巧是使用这些类，但不修改已存在的代码。第一种方法很直接：我们简单地在心类中创建已存在类的对象。因为新类是由已存在的类的对象组合而成，所以这种方法称为组合(composition)。</p>
<p>第二种方法要复杂些。我们创建一个新类作为一个已存在类的类型。我们不修改已存在的类，而是采取这个已存在类的形式，并将代码加入其中。这种巧妙方法称为继承(inheritance)，其中大量的工作是由编译器完成。继承是面向对象程序设计的基石。</p>
<p>在语法上和行为上，组合和继承大部分是相似的。</p>
<h3 id="14-1-组合语法"><a href="#14-1-组合语法" class="headerlink" title="14.1 组合语法"></a>14.1 组合语法</h3><p>直接把子对象放入新对象的组成中即可。</p>
<p>访问嵌入对象(称为子对象)的成员的成员函数只需再一次的成员选择。更常见的是把嵌入的对象设为私有，因此它们将称为内部实现的一部分(这意味着如果我们原因，可以改变这个实现)。新类的公有接口函数包括了对嵌入对象的使用，但没有必要模仿这个对象的接口。</p>
<h3 id="14-2-继承语法"><a href="#14-2-继承语法" class="headerlink" title="14.2 继承语法"></a>14.2 继承语法</h3><p>当继承时，我们会发现“这个新类很像原来的类”。我们规定，在代码中和原来一样给出该类的名字，但在类的左括号的前面，加一个冒号和基类的名字(对于多重继承，要给出多个基类名，它们之间用逗号分开)。当昨晚这些时，将会自动地得到基类中的所用数据成员和成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Y：<span class="keyword">public</span> X&#123;<span class="comment">//......&#125;</span></div></pre></td></tr></table></figure>
<p>我们可以看到 <code>Y</code> 对 <code>X</code> 进行了继承，这意味着Y将包含X中的所有数据成员和成员函数。所有X中的私有成员在Y中仍然是私有的，因为Y对X进行了继承并不意味着Y可以不遵守保护机制。</p>
<p>这里基类前面是 <code>public</code>。由于在继承时，基类中所有的成员都是被预设为私有的，所以如果基类的前面没有 <code>public</code>，这意味着基类的所有公有成员将在派生类中变为私有的。这显然不是所希望的，我们希望基类中的所有公有成员在派生类中仍是公有的，这可以在继承时通过使用关键字 <code>public</code> 来实现。</p>
<p>倘若 <code>X</code> 和 <code>Y</code> 类中均有一个 <code>set()</code> 函数，那么将会使用 <code>Y</code> 中重新定义的版本。这也就是说，如果不想使用某个继承而来的函数，我们可以改变它的内容。然而，当我们重新定义了一个函数之后，仍可能想调用基类的函数，为了调用基类 <code>X</code> 的 <code>set()</code> 函数，必须使用作用域运算符来显示地表明基类名。</p>
<h3 id="14-3-构造函数的初始化列表"><a href="#14-3-构造函数的初始化列表" class="headerlink" title="14.3 构造函数的初始化列表"></a>14.3 构造函数的初始化列表</h3><p>在 C++ 中保证正确的初始化是多么重要，这一点在组合和继承中也是一样。当创建一个对象时，编译器确保调用了所有子对象的构造函数。</p>
<p>但是，如果子对象没有默认构造函数或如果想改变构造函数的某个默认参数，就会出现问题，因为这个新类的构造函数没有权利访问这个子对象的私有数据成员，所以不能直接对它们初始化。</p>
<p>解决的方法很简单：对于子函数调用构造函数，C++ 为此提供了专门的语法，即构造函数的初始化表达式表。构造函数的初始化表达式的形式模仿继承活动。</p>
<p>对于继承，我们把基类至于冒号和这个类体的左括号之间。而在构造函数的初始化表达式中，可以将对子对象构造函数的调用语句放在构造函数参数表和冒号之后，在函数体的左括号之前。对于从 <code>Bar</code> 继承来的类 <code>MyType</code>，如果 <code>Bar</code> 的构造函数只有一个 <code>int</code> 型参数，则可以表示为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType::MyType(<span class="keyword">int</span> i) : Bar(i) &#123; <span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p><strong>14.3.1 成员对象初始化</strong></p>
<p>对于组合，也可以对成员对象使用同样语法，只是所给出的不是类名，而是对象的名字。如果在初始化表达式表中有多个构造函数的调用，应当用逗号加以隔开：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">MyType2::MyType(<span class="keyword">int</span> i) : Bar(i), m(i+<span class="number">1</span>) &#123; <span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>这是类 <code>MyType2</code> 构造函数的开头，该类是从 <code>Bar</code> 继承来的，并且包含一个称为m的成员对象。请注意，虽然可以在这个构造函数的初始化表达式表中看到基类的类型，但只能看到成员对象的标识符。</p>
<p><strong>14.3.2 在初始化表达式中的内部类型</strong></p>
<p>构造函数的初始化表达式表允许我们显式地调用成员对象的构造函数。它的主要思想是，在进入新类的构造函数体之前调用所有其他的构造函数。这样，对于子对象的成员函数所做的任何调用都总是转到了这个被初始化的对象中。即使编译器可以隐藏地调用默认的构造函数，但在没有对所有的成员对象和基类对象的构造函数进行调用之前，就没有办法进入该构造函数体。这是 C++ 的一个强化的机制，它确保了，如果没有调用对象的构造函数，就别想向下进行。</p>
<p>对于哪些没有构造函数的内部类型嵌入对象，这一切会怎么样？</p>
<p>为了使语法一致，可以把内部类型看做这样一种类型，它只有一个取单个参数的构造函数，而这个参数与正在初始化的变量类型相同。于是可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">float</span> f;</div><div class="line">	<span class="keyword">char</span> c;</div><div class="line">	<span class="keyword">char</span>* s;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	X() : i(<span class="number">7</span>), f(<span class="number">1.4</span>), c(‘x’), s(“howdy”) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些“伪构造函数调用”操作可以进行简单的赋值。这种方法很方便，并且具有良好的编码风格。甚至在类之外创建内部类型的变量是，也可以使用伪构造函数语法。</p>
<p>这使得内部类型的操作有点类似于对象，但是这些并不是真正的构造函数。特别地，如果没有显式的进行伪构造函数调用，初始化是不会执行的。</p>
<h3 id="14-4-组合和继承的联合"><a href="#14-4-组合和继承的联合" class="headerlink" title="14.4 组合和继承的联合"></a>14.4 组合和继承的联合</h3><p>还可以把组合和继承放在一起使用。</p>
<p><strong>自动析构函数调用</strong></p>
<p>虽然常常需要在初始化表达式表中显式构造函数调用，但并不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且它并不取任何参数。然而，编译器仍要保证所有的析构函数被调用，这意味着，在整个层次中的所有析构函数中，从派生类最底层的析构函数开始调用，一直到根层。</p>
<p><strong>14.4.1 构造函数和析构函数调用的次序</strong></p>
<p>构造是从类层次的最根处开始，而在每一层，首先会调用基类构造函数，然后调用成员对象构造函数。调用析构函数则严格按照构造函数相反的次序──这是很重要的，因为要考虑潜在的相关性(对于派生类中的构造函数和析构函数，必须假设基类子对象仍然可供使用并且已经被构造了──或者还未被消除)。</p>
<p>另一个有趣现象是，对于成员对象，构造函数调用的次序完全不受构造函数的初始化表达式表中的次序影响。该次序是由成员对象在类中声明的次序所决定的。</p>
<h3 id="14-5-名字隐藏"><a href="#14-5-名字隐藏" class="headerlink" title="14.5 名字隐藏"></a>14.5 名字隐藏</h3><p>如果继承一个类并且对它的成员函数重新进行定义，可能会出现两种情况：</p>
<p>第一种是正如在基类中所进行的定义一样，在派生类的定义中明确地定义操作和返回类型。这称之为对普通成员函数的重定义(redefining)，而如果基类的成员函数是虚函数的情况，又可称之为重写(overriding)。</p>
<p>任何时候重新定义了基类中的一个重载函数，在新类之中所有其他版本则被自动地隐藏了。</p>
<p>如果通过修改基类中一个成员函数的操作与/或返回类型来改变了基类的接口，我们就没有使用继承通常所提供的功能，而是按另一种方式来重用了该类。这并不一定意味着做错了，只是由于继承的最终目标是为了实现多态性(polymorphism)。</p>
<h3 id="14-6-非自动继承的函数"><a href="#14-6-非自动继承的函数" class="headerlink" title="14.6 非自动继承的函数"></a>14.6 非自动继承的函数</h3><p>不是所有的函数都能自动地从基类继承到派生类中的。构造函数和析构函数用来处理对象的创建和析构操作，但它们只知道对它们的特定层次上的的对象做些什么。所以，在该类以下各个层次中的所有构造函数和析构函数都必须被调用，也就是说，构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。</p>
<p>另外，<code>operator=</code> 也不能被继承，因为它完成类似于构造函数的活动。</p>
<p><strong>14.6.1 继承和静态成员函数</strong></p>
<p>静态(static)成员函数与非静态成员函数的共同点：</p>
<ul>
<li>它们均可被继承到派生类中。</li>
<li>如果我们重新定义了一个静态成员，所有在基类中的其他重载函数会被隐藏。</li>
<li>如果我们改变了基类中一个函数的特征，所有使用该函数名字的基类版本都将会被隐藏。然而，静态(static)成员函数不可以是虚函数(virtual)。</li>
</ul>
<h3 id="14-7-组合与继承的选择"><a href="#14-7-组合与继承的选择" class="headerlink" title="14.7 组合与继承的选择"></a>14.7 组合与继承的选择</h3><p>组合通常是在希望新类内部具有已存在类的功能时使用，而不是希望已存在类作为它的接口。这就是说，嵌入一个对象用以实现新类的功能，而新类的用户看到的是新定义的接口而不是来自老类的接口。为此，在新类的内部嵌入已存在的 <code>private</code> 对象。</p>
<p>有时，又希望允许类用户直接访问新类的组成，这就让成员对象是 <code>public</code>。由于成员对象使用自己的访问控制，所以是安全的，而当用户了结了我们所做的组装工作时，会更容易理解接口。</p>
<p>is-a 关系用继承表达，has-a 关系用组合表达。</p>
<p><strong>14.7.1 子类型设置</strong></p>
<p>如果由一个已存在的类创建一个新类，并且希望这个类的每件东西都进来，就称为子类型化(subtyping)。这个新类与已存在的类有着严格相同的接口(希望增加任何我们想要加入的其他成员函数)，所以能在已经用过这个已存在的类的任何地方使用这个新类，这就是必须使用继承的地方。</p>
<p><strong>14.7.2 私有继承</strong></p>
<p>通过在基类表中去掉 <code>public</code> 或通过显式地声明 <code>private</code>，可以私有地继承基类。当私有继承时，我们是“照此实现”；也就是说，创建的新类具有基类的所有数据和功能，但这些功能是隐藏的，所以它只是部分的内部实现。该类的用户访问不到这些内部功能，并且一个对象不能被看做是这个基类的实例。</p>
<p>为了完整性，<code>private</code> 继承被包含在该语言中。但是通常希望使用组合而不是 <code>private</code> 继承。</p>
<p><strong>14.7.2.1 对私有继承成员公有化</strong></p>
<p>私有继承时，基类的所有 <code>public</code> 成员都变成了 <code>private。如果希望其中的任何一个是可视的，只要用派生类的</code>public` 部分声明它们的名字即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">using</span> Pet::eat;</div></pre></td></tr></table></figure>
<p>其中 <code>Pet</code> 是私有继承的类，这样就可以使用 <code>Pet</code> 类中的 <code>eat</code> 成员函数。</p>
<p>这样，如果想要隐藏基类的部分功能，则 <code>private</code> 继承是有用的。注意给出一个重载函数的名字将使基类中的所有它的重载版本公有化。</p>
<p>在使用 <code>private</code> 继承取代组合之前，应当仔细考虑，当与运行时类型标识相连时，私有继承特别复杂。</p>
<h3 id="14-8-protected"><a href="#14-8-protected" class="headerlink" title="14.8 protected"></a>14.8 protected</h3><p>实际项目中，有时希望某些东西隐藏起来，但仍允许其派生类的成员访问，此时可用 <code>protected</code>。它的意思是：“就这个类的用户而言，它是 <code>private</code> 的，但它可被从这个类继承来的任何类使用”。</p>
<p>最好让数据成员是 <code>private</code>，因为我们应该保留改变内部实现的权利。然后才能通过 <code>protected</code> 成员函数控制对该类的继承者的访问。</p>
<p><strong>14.8.1 protected</strong></p>
<p>保护继承的派生类意味着对其他类来说是“照此实现”，但它是对于派生类和友元是“is-a”。它是不常用的，它的存在只是为了语言的完备性。</p>
<h3 id="14-9-运算符的重载与继承"><a href="#14-9-运算符的重载与继承" class="headerlink" title="14.9 运算符的重载与继承"></a>14.9 运算符的重载与继承</h3><p>除了赋值运算符以外，其余的运算符可以自动地继承到派生类中。</p>
<h3 id="14-10-多重继承"><a href="#14-10-多重继承" class="headerlink" title="14.10 多重继承"></a>14.10 多重继承</h3><p>直到我们已经很好地学会程序设计并完全理解这个语言时，我们才能试着去用多重继承。不管我们如何认为我们必须用多重继承，我们总是能通过单继承完成。</p>
<p>多重继承引起很多含糊的可能性。</p>
<h3 id="14-11-渐增式开发"><a href="#14-11-渐增式开发" class="headerlink" title="14.11 渐增式开发"></a>14.11 渐增式开发</h3><p>继承和组合的优点之一是它支持渐增式开发(incremental development)，它允许在已存在的代码中引进代码，而不会给原来的代码带来错误。</p>
<p>认识到程序开发就像人的学习过程一样，是一个渐增的过程，这是很重要的。我们能做尽可能多的分析，但当开始一个项目时，我们仍不可能知道所有的答案。</p>
<p>记住，继承首先是表示一种关系，即“新类属于老类的类型(a type of)”。我们的程序不应当关心怎样怎样摆布位，而应当关心如何创建和处理各类型的对象，以便用问题空间的术语表示模型。</p>
<h3 id="14-12-向上类型转换"><a href="#14-12-向上类型转换" class="headerlink" title="14.12 向上类型转换"></a>14.12 向上类型转换</h3><p>继承最重要的方面不是它为新类提供了成员函数，而是它是基类与新类之间的关系，这种关系可被描述为：“新类属于原有类的类型”。</p>
<p>这个描述不仅仅是一种想象的解释继承的方法──它直接由编译器支持。将新类的引用或指针转变成基类的引用或指针的活动被称为向上类型转换(upcasting)。</p>
<p><strong>14.12.1 为什么要“向上类型转换”</strong></p>
<p>这个术语的引入是有其历史原因的，而且它也与类继承图的传统画法有关：在顶部是根，向下生长。</p>
<p>向上类型转换总是安全的。因为是从更专门的类型到更一般的类型──对于这个类接口可能出现的唯一事情是它失去成员函数，而不是获得它们。这就是编译器允许向上类型转换而不需要显式地说明或做其他标记的原因。</p>
<p><strong>14.12.2 向上类型转换和拷贝构造函数</strong></p>
<p>必须记住无论何时我们在创建了子集的拷贝构造函数时，都要正确地调用基类拷贝构造函数(正如编译器所作的)。</p>
<h2 id="第15章-多态性和虚函数"><a href="#第15章-多态性和虚函数" class="headerlink" title="第15章 多态性和虚函数"></a>第15章 多态性和虚函数</h2><ul>
<li>多态性(在C++中通过虚函数来实现)是面向对象程序设计语言中数据抽象和继承之外的第三个基本特性。</li>
<li>多态性(polymorphism)提供了接口与具体实现之间的另一层隔离，从而将“what”与“how”分离开来。多态性改善了代码的组织性和可读性，同时也使创建的程序具有可拓展性。</li>
<li>封装(encapsulation)通过组合特性和行为来生成心的数据类型。访问控制通过使细节数据设为 private，将接口从具体实现中分离开来。</li>
</ul>
<h3 id="15-1-C-程序员的演变"><a href="#15-1-C-程序员的演变" class="headerlink" title="15.1 C++ 程序员的演变"></a>15.1 C++ 程序员的演变</h3><p>C程序员可以用三步演变为C++程序员。</p>
<ul>
<li>第一步：简单地把C++作为一个“更好的C”。</li>
<li>第二步：进入“基于对象”的C++。</li>
<li>第三步：了解和使用虚函数，这是理解面向对象程序设计的转折点。不用虚函数，就等于还不懂得面向对象程序设计(OOP)，虚函数增强了类型概念，而不只是在结构内部隐蔽地封装代码。</li>
</ul>
<h3 id="15-2-向上类型转换"><a href="#15-2-向上类型转换" class="headerlink" title="15.2 向上类型转换"></a>15.2 向上类型转换</h3><p>取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这被称为向上类型转换(upcasting)，因为继承树的绘制方式是以基类为顶点的。</p>
<h3 id="15-3-捆绑"><a href="#15-3-捆绑" class="headerlink" title="15.3 捆绑"></a>15.3 捆绑</h3><p>把函数体与函数调用相联系称为捆绑(binding)。当捆绑在程序运行之前(由编译器和连接器)完成时，这称为早捆绑(early binding)。C编译只有一种函数调用方式，就是早捆绑。晚捆绑(late binding)意味着捆绑根据对象的类型，发生在运行时。晚捆绑又称为动态捆绑(dynamic binding)或运行时捆绑(runtime binding)。对于一种编译语言，编译器并不知道实际的对象类型，但它插入能找到和调用正确函数体的代码。</p>
<h3 id="15-4-虚函数"><a href="#15-4-虚函数" class="headerlink" title="15.4 虚函数"></a>15.4 虚函数</h3><p>对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数时使用virtual关键字。晚捆绑支队virtual函数起作用，而且只在使用含有virtual函数的基类的地址时发生，尽管它们也可以在更早的基类中定义。</p>
<p>为了创建一个像virtual这样的成员函数，可以简单地在声明这个函数时使用virtual关键字。仅仅在声明的时候需要使用关键字virtual，定义时并不需要。如果一个函数在基类中被声明为virtual，那么在所有的派生类中它都是virtual的。在派生类中virtual函数的重定义通常称为重写(overriding)。</p>
<p>注意，仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。</p>
<p><strong>15.4.1 拓展性</strong></p>
<p>在一个设计风格良好的OOP程序中，大多数甚至所有的函数都可以沿用基类的某个模型，只需与基类接口通信。这样的程序是可拓展的(extensible)，因为可以通过从公共基类继承新数据类型而增加新功能。操作基类接口的函数完全不需要改变就可以适合于这些新类。</p>
<h3 id="15-5-C-如何实现晚捆绑"><a href="#15-5-C-如何实现晚捆绑" class="headerlink" title="15.5 C++如何实现晚捆绑"></a>15.5 C++如何实现晚捆绑</h3><p>关键字 <code>virtual</code> 告诉编译器它不应当执行早捆绑，相反，它应当自动安装对于实现晚捆绑必需的所有机制。</p>
<p>为了达到这个目的，典型的编译器对每个包含虚函数的类创建一个表(VTABLE)。在VTABLE中，编译器放置特定类的虚函数的地址。在每个带有虚函数的类中，编译器秘密地防止一个指针，称为vpointer(缩写为VPTR)，指向这个对象 VTABLE。当通过基类指针做虚函数调用时(也就是做多台调用时)，编译器静态地插入能取得这个 VPTR 并在 VTABLE 表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。</p>
<p>为每个类设置 VTABLE，初始化 VPTR、为虚函数调用插入代码，所有这些都是自动发生的。利用虚函数，即使在编译器还不知道这个对象的特定类型的情况下，也能调用这个对象中正确的函数。</p>
<p><strong>15.5.1 存放类型信息</strong><br>如果有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针(VPTR)，指向一个存放函数地址的表。我们只需要一个表，因为所有虚函数地址都包含在这个但个表里。</p>
<h3 id="15-6-为什么需要虚函数"><a href="#15-6-为什么需要虚函数" class="headerlink" title="15.6 为什么需要虚函数"></a>15.6 为什么需要虚函数</h3><p>C++ 并不是对于绝对地址的一个简单的 CALL，而是为设置虚函数调用需要两条以上的复杂的汇编指令。这既需要代码空间，又需要执行时间。</p>
<p>一些面向对象的语言已经接受了这种途径，即晚捆绑对于面向对象程序设计是性质所固有的，所以应当总是出现，它不应当是可选的，而且用户并不一定需要知道它。这是在创造语言的设计时决定的，而这种特殊的方法对于许多语言是适合的(smalltalk、Java和Python)。</p>
<p>virtual 关键字可以改变程序的效率。当设计类时，我们不应当为效率问题担心。如果使用多态，就处处使用虚函数。当试图加速代码时，只需寻找可以不使用虚函数的函数。</p>
<p>有些证据表明，C++ 中的规模和速度改进效果是在 C 的规模和速度的 10% 之内，并且常常更接近。能够得到更小的规模和更高速度的原因是 C++ 可以有比 C 更快的方法设计程序，而且设计的程序更小。</p>
<h3 id="15-7-抽象基类和纯虚函数"><a href="#15-7-抽象基类和纯虚函数" class="headerlink" title="15.7 抽象基类和纯虚函数"></a>15.7 抽象基类和纯虚函数</h3><p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类对象。就可以在基类中加入至少一个纯虚函数(pure virtual function)，来使基类成为抽象(abstract)类。纯虚函数使用关键字 <code>virtual</code>，并且在其后面加上 <code>=0</code>。如果试着生成一个抽象类的对象，编译器会制止他。</p>
<p>当继承一个抽象类时，必须实现所有的纯虚函数，否则继承出的类也将是一个抽象类。创建一个纯叙述函数允许在接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。同时纯虚函数要求继承出的类对它提供一个定义。</p>
<p>建立公共接口的唯一原因是它能对于每个不同的子类有不同的表示。它建立一个基本的格式，用来确定什么是对于所有派生类是公共的──除此之外，别无用途。当仅希望通过一个公共接口来操纵一组类，且这个公共接口不需要实现(或者不需要完全实现)时，可以创建一个抽象类。语法为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>这样做，等于告诉编译器在 VTABLE 中为函数保留一个位置，但在这个特定位置中不放地址。只要有一个函数在类中被声明为纯虚函数，则 VTABLE 就是不完全的。</p>
<p>如果一个类的  是不完全的，当试图创建这个类的对象时，编译器就发出一个出错信息。这样，编译器就保证了抽象类的纯洁性，就不会被误用了。</p>
<p>一个类若全是纯虚函数，就称为纯抽象类(pure abstract class)。纯序函数是非常有用的，因为它们使得类有明显的抽象性，并告诉用户和编译器打算如何使用。</p>
<p>注意，纯虚函数禁止对抽象类的函数以传值方式调用。这也是防止对象切片(object slicing)的一种方法。通过抽象类，可以保证在向上类型转换期间总是使用指针或引用。</p>
<h3 id="15-8-继承和-VTABLE"><a href="#15-8-继承和-VTABLE" class="headerlink" title="15.8 继承和 VTABLE"></a>15.8 继承和 VTABLE</h3><p>当实现继承和重新定义一些虚函数时，编译器对新类创建一个新的 VTABLE表，并且插入新函数的地址，对于没有重新定义的虚函数使用基类函数的地址。无论如何，对于可被创建的每个对象(即它的类不含有纯虚函数)，在 VTABLE 中纵有一个函数地址的全集，所以绝对不能对不在其中的地址进行调用(否则结果将是灾难性的)。</p>
<p>若在派生(derived)类中继承或增加新的虚函数，那么通过基类的指针是无法进行调用的。</p>
<p>如果知道保存在一般容器中的所有对象的确切类型，会使我们的设计工作在最佳状态(或者没有选择)。这就是运行时类型辨认(Run-Time Type Identification,RTTI)问题。RTTI是有关向下类型转换基类指针到派生类指针的问题。向上类型转换是自动发生的，不需强制，因为它是绝对安全的。向下类型转换是不安全的，因为这里没有关于实际类型的编译时信息，所以必须准确地知道这个类实际是什么类型。如果把它转换称错误的类型，就会出现麻烦。</p>
<p><strong>15.8.1 对象切片</strong></p>
<p>当多态地处理对象时，传地址与传值有明显的不同。如果对一个对象进行向上类型转换，而不使用地址或引用，这个对象将会被“切片”，直到剩下来的是适合于目的的子对象。确切地来说，派生类对象会被切片成一个基类对象。</p>
<p>对象切片实际上是当它拷贝到一个新的对象时，去掉原来对象的一部分，而不是像使用指针或引用那样简单地改变地址和内容。因此，不常使用对象向上类型转换，事实上，通常要提防或防止这种操作。</p>
<h3 id="15-9-重载和重新定义"><a href="#15-9-重载和重新定义" class="headerlink" title="15.9 重载和重新定义"></a>15.9 重载和重新定义</h3><p>重新定义一个基类中的重载函数将会隐藏所有该函数的其他基类版本。而当对虚函数进行这些操作的时候，情况会有点不同。</p>
<p>编译器不允许我们改变重新定义过的虚函数的返回值(如果不是虚函数，则是允许的)。这是一个非常重要的限制，因为编译器必须保证我们能够多态地通过基类调用函数，若返回值不同，那么就会产生问题。</p>
<p>如果重新定义了基类中的一个重载成员函数，则在派生类中其他的重载函数将会被隐藏。例如，基类中有 <code>f(int)</code> 和 <code>f(string)</code> 这样的重载函数，如果我在派生类中重新定义了 <code>f(int)</code>，那么对于这个派生类来说，<code>f(string)</code>就被隐藏了，不可用了。</p>
<p><strong>15.9.1 变量返回类型</strong></p>
<p>通常，我们不能在重新定义过程中修改虚函数的返回类型，但是也有特例，如果返回一个指向基类的指针或引用，则该函数的重新定义版本可以从基类返回的内容中返回一个指向派生类的指针或引用。</p>
<h3 id="15-10-虚函数和构造函数"><a href="#15-10-虚函数和构造函数" class="headerlink" title="15.10 虚函数和构造函数"></a>15.10 虚函数和构造函数</h3><p>当创建一个报含有虚函数的对象时，必须初始化它的 VPTR 以指向相应的 VTABLE。这必须在对虚函数进行任何调用之前完成。编译器在构造函数开头部分秘密地插入能初始化VPTR的代码。</p>
<p>当寻找效率漏洞时，我们必须明白，编译器正在插入隐藏代码到我们构造函数中。这些隐藏代码不仅必须初始化 VPTR，而且还必须检查this的值(以免operator new返回零)和调用基类构造函数。放在一起，这些代码可以影响我们认为是一个小内联函数的调用。特别是，构造函数的规模会抵消函数调用代价的减少。如果做大量的内联构造函数调用，代码长度就会增长，而在速度上没有任何好处。</p>
<p>当然，也许并不会立即把所有这些小构造函数都变成非内联，因为它们更容易写为内联构造函数。但是，当我们正在调整我们的代码时，务必去掉这些内联构造函数。</p>
<p><strong>15.10.1 构造函数调用次序</strong></p>
<p>所有基类构造函数总是在继承类构造函数中被调用。派生类只访问它自己的成员，而不访问基类的成员。只有基类构造函数能正确地初始化它自己的成员。如果不在构造函数初始化表达式表中显式地调用基类构造函数，他就调用默认构造函数。如果没有默认构造函数，编译器将报告错误。</p>
<p>构造函数调用的顺序是重要的。当继承时，必须知道基类的全部成员并能访问基类的任何 <code>public</code> 和 <code>protected</code> 成员。在通常的成员函数中，构造已经发生，所以这个对象的所有部分的成员都已经建立。然而，在构造函数中，必须想办法保证所有成员都已经建立。保证它的惟一方法是让基类构造函数首先被调用。</p>
<p>只要可能，我们应当在构造函数初始化表达式表中初始化所有的成员对象。只要遵从这个做法，我们就能保证初始化所有基类成员和当前对象的成员对象。</p>
<p><strong>15.10.2 虚函数在构造函数中的行为</strong></p>
<p>对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。</p>
<p>构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象──我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员。这将导致灾难的发生。</p>
<p>当一个构造函数被调用时，它做的首要事情之一就是初始化它的 VPTR。然而，它只能知道它属于“当前”类──即构造函数所在类。于是它完全忽视这个对象是否是基于其他类的。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码──既不是为基类，也不是为它的派生类。VPTR 的状态是由被最后调用的构造函数确定的。</p>
<p>当这一系列构造函数调用正发生时，每个构造函数都已经设置 VPTR 指向子集的 VTABLE。如果函数调用使用虚机制，它将只产生通过它自己的 VTABLE 的调用，而不是最后派生的 VTABLE。</p>
<p>总之，在构造函数中调用虚函数都不能得到预期的结果。</p>
<h3 id="15-11-析构函数和虚拟析构函数"><a href="#15-11-析构函数和虚拟析构函数" class="headerlink" title="15.11 析构函数和虚拟析构函数"></a>15.11 析构函数和虚拟析构函数</h3><p>构造函数是不能为虚函数的。但析构函数能够且常常必须是虚的。</p>
<p>构造函数有一项特殊工作，即一块一块地组合成一个对象。它首先调用基类构造函数，然后调用在继承顺序中的更晚派生的构造函数。类似地，析构函数也有一项特殊工作，即它必须拆卸属于某层次类的对象。析构函数自最晚派生的类开始，并向上到基类。</p>
<p>如果通过指向某个对象基类的指针操纵这个对象(也就是通过它的一般接口操纵这对象)，当我们想在 <code>delete</code> 在栈中已经用new创建的对象的指针时，就会出现这个问题。如果这个指针是指向基类的，在 <code>delete</code> 期间，编译器只能知道调用这个析构函数的基类版本，幸运的是，析构函数可以是虚函数。</p>
<p>不把析构函数设为虚函数是一个隐匿的错误，因为它常常不会对程序有直接的影响，但是会不知不觉引入存储器泄露(关闭程序时内存未释放)。同样，这样的析构操作还有可能掩盖发生的问题。</p>
<p><strong>15.11.1 纯虚析构函数</strong></p>
<p>尽管纯虚析构函数在标准 C++ 中是合法的，但在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。纯虚析构函数和非纯虚虚构函数之间的唯一不同之处在于纯虚析构函数使得基类是抽象类，所以不能创建一个基类的对象(如果基类的任何其他函数是纯虚函数，也是具有同样的效果)。</p>
<p>当从某个含有虚析构函数的类中继承出一个类，情况变得有点复杂。不像其他的纯虚函数，我们不要求在派生类中提供纯虚函数的定义。</p>
<p>一般来说，如果在派生类中基类的纯虚函数(和所有其他纯虚函数)没有重新定义，则派生类将会成为抽象类。但是这里编译器将会自动地为每个类生成一个析构函数定义，基类的析构函数被重写(重新定义)，因此编译器会提供定义并且派生类实际上不会成为抽象类。</p>
<p>当我们的类仅含有一个纯虚函数时，就会发现这个唯一的差别：析构函数。这里析构函数的纯虚性的唯一效果是阻止基类的实例化。如果有其他的纯虚函数，则它们会阻止基类的实例化。</p>
<p>作为一个准则，任何时候我们的类中都要有一个虚函数，我们应当立即增加一个虚析构函数(即使它什么也不做)。这样，我们保证在后面不会出现问题。</p>
<p><strong>15.11.2 析构函数中的虚机制</strong></p>
<p>在析构期间，有一些我们可能不希望马上发生的情况。如果正在一个普通的成员函数中，并且调用一个虚函数，则会使用晚捆绑机制来调用这个函数。而对于析构函数，这样不行，不论是虚的还是非虚的。在析构函数中，只有成员函数的“本地”版本被调用；虚机制被忽略。</p>
<p><strong>15.11.3 创建基于对象的继承</strong></p>
<p>负责动态对象创建(使用 <code>new</code>)的对象进行 <code>delete</code> 调用的称之为“所有者”。在使用容器时的问题是，它们需要足够的灵活性用来接收不同类型的对象。为了做到这一点，容器使用 <code>void</code> 指针，因此它们并不知道所包容对象的类型。删除一个 <code>void</code> 指针并不调用析构函数，所以容器并不负责清除它的对象。</p>
<p>一种方法要求我们要为想在容器中容纳的每一种类型都派生出新类。</p>
<p>问题是我们希望容器可以容纳更多的类型，但我们不想使用 <code>void</code> 指针。另外一种解决方法是使用多态性，它通过强制容器内的所有对象从同一个基类继承而来。也就是说，容器容纳了具有同一基类的对象，并随后调用虚函数──特别地，我们可以调用虚析构函数来解决所有权问题。</p>
<p>这种解决方法使用单根继承(singly-rooted hierarchy)或基于对象的继承(object-based hierarchy)。事实上，除了 C++，每种面向对象的语言都强制使用这样的体系──当创建一个类时，都会直接或间接地从一个公共基类中继承出它，这个基类是由该语言的创建者生成的。C++ 中认为，强制地使用这个公共基类会引起太多的开销，所有便没有使用它。</p>
<h3 id="15-12-运算符重载"><a href="#15-12-运算符重载" class="headerlink" title="15.12 运算符重载"></a>15.12 运算符重载</h3><p>就像对成员函数那样，我们可以使用 virtual 运算符。然而，因为我们可能对两个不知道类型的对象进行操作，所以实现 virtual 运算符通常会很复杂。这通常用于处理数学部分。</p>
<h3 id="15-13-向下类型转换"><a href="#15-13-向下类型转换" class="headerlink" title="15.13 向下类型转换"></a>15.13 向下类型转换</h3><p>C++ 提供了一个特殊的称为 <code>dynamic_cast</code> 的显式类型转换(explicit cast)，它就是一种安全类型向下类型转换(type-safe downcast)的操作。当使用 <code>dynamic_cast</code> 来试着向下类型转换一个特定的类型，仅当类型转换是正确的并且是成功的时，返回值会是一个指向所需类型的指针，否则它将会返回0来表示这并不是正确的类型。</p>
<p>当使用 <code>dynamic_cast</code> 时，必须对一个真正多态的层次进行操作──它含有虚函数──这因为 <code>dynamic_cast</code> 使用了存储在 VTABLE 中的信息来判断实际的类型，所以运行时需要一点额外的开销。</p>
<h2 id="第16章-模板介绍"><a href="#第16章-模板介绍" class="headerlink" title="第16章 模板介绍"></a>第16章 模板介绍</h2><p>继承和组合提供了重用对象代码的方法，而 C++ 的模板特征提供了重用源代码的方法。</p>
<h3 id="16-1-容器"><a href="#16-1-容器" class="headerlink" title="16.1 容器"></a>16.1 容器</h3><p>在一般程序设计问题中，程序员在编写程序时并不知道将来需要创建多少个对象。C++ 中有更好的解决方法：用 <code>new</code> 创建所需要的对象，将其指针放入容器中，待实际实用时将其取出并进行处理。用这种方法，所创建的只是确实需要的对象。通常，在启动程序时没有可用的初始化条件。<code>new</code> 允许等待，直到在环境中相关事件发生后，再实际地创建这个对象。</p>
<h3 id="16-2-模板综述"><a href="#16-2-模板综述" class="headerlink" title="16.2 模板综述"></a>16.2 模板综述</h3><p>有三种源代码重用的方法：</p>
<p>C方法：应该摒弃，由于它表现繁琐、易发生错误、缺乏美感，是非常低效的技术。</p>
<p>Smalltalk方法：通过继承来实现代码重用，既简单又直观。每个容器类包含通用的基类Object的项目。这是一种单纯的技巧，因为Smalltalk类层次上的任何类都源于Object的派生，任何容器可容纳任何类(包括容器本身)。这种基于通用的基类(常称为Object，在Java中也有类似情况)的单树形层次类型称为“基于对象的层次结构”。</p>
<p><strong>16.2.1 模板方法</strong></p>
<p>尽管具有多重继承的基于对象的层次结构在概念上是直观的，但是在实践上较为困难。</p>
<p>模板对源代码进行重用，而不是通过继承和组合重用目标代码。容器不再存放称为Object的通用基类，而是存放一个未指明的参数。当用户使用模板时，参数由编译器来替换。</p>
<p>C++ 中，模板实现了参数化类型(parameterized type)的概念。模板方法的另一个优点是，使对继承不熟悉、不适应的新程序员也能正确地使用密封的容器类。</p>
<h3 id="16-3-模板语法"><a href="#16-3-模板语法" class="headerlink" title="16.3 模板语法"></a>16.3 模板语法</h3><p>template 这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码时，必须指定这些类型以使编译器能够替换它们。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> Array&#123;</div><div class="line">	<span class="keyword">enum</span>&#123; size = <span class="number">100</span> &#125;;</div><div class="line">	T A[size];</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;....&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	Array&lt;<span class="keyword">int</span>&gt; ia;</div><div class="line">	Array&lt;<span class="keyword">double</span>&gt; da;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>T</code> 是替换参数，它代表一个类型名称。在容器类中，它将出现在那些原本由某以特定类型出现的地方。</p>
<p><strong>16.3.1 非内联函数定义</strong></p>
<p>有时我们希望有非内联成员函数的定义。这时编译器需要在成员函数定义之前看到 <code>template</code> 声明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> Array&#123;</div><div class="line">	<span class="keyword">enum</span>&#123; size = <span class="number">100</span> &#125;;</div><div class="line">	T A[size];</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="keyword">int</span> index) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>注意在引用模板的类名的地方，必须伴游该模板的参数列表。可以想象，在内部，使用模板参数列表中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。</p>
<p>在 <code>template&lt;...&gt;</code> 之后的任何东西都意味着编译器在当时不为它分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉同一模板的多重定义。所以为了使用方便，几乎总是在头文件中放置全部的模板声明和定义。</p>
<p>可以认为模板为 C++ 提供了一种弱类型(weak typing)机制，C++ 通常是强类型语言。</p>
<p><strong>16.3.2 模板中的常量</strong></p>
<p>模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间编程模板的特定示例的常量。我们甚至可以对这些参数使用默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">int</span> size = <span class="number">100</span>&gt;</div><div class="line"><span class="keyword">class</span> Array&#123;</div><div class="line">	T <span class="built_in">array</span>[size];</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里的 size 决不存放在类中，但对它的使用就如同是成员函数中的数据成员。</p>
<p>如果某个类有一个指向 Array 的指针，而不是指向类型 Array 的嵌入对象。该指针在构造函数中不被初始化，而是推迟到第一次访问时。这称为懒惰初始化(lazy initialization)。如果创造大量的对象，但不访问每一个对象，为了节省存储，可以使用懒惰初始化技术。</p>
<h3 id="16-4-打开和关闭所有权"><a href="#16-4-打开和关闭所有权" class="headerlink" title="16.4 打开和关闭所有权"></a>16.4 打开和关闭所有权</h3><p>以值包含对象的容器通常无需担心所有权问题，因为它们清晰地拥有它们所包含的对象。但是，如果容器内包含指向对象的指针(这种情况在C++中相当普遍，有其在多态的情况下)，而这些指针很可能用于程序的其他地方，那么删除该指针指向的对象会导致在程序的其他地方的指针对已销毁的对象进行引用。为了避免上述情况，在设计和使用容器时必须考虑所有权问题。</p>
<p>处理所有权问题的最好方法是由客户程序员来选择。这常常通过构造函数的一个参数来完成，它默认地指明所有权。</p>
<h3 id="16-5-以值存放对象"><a href="#16-5-以值存放对象" class="headerlink" title="16.5 以值存放对象"></a>16.5 以值存放对象</h3><p>如果我们没有模板，那么在一个一般的容器内创建对象的一个拷贝是一个复杂的问题。使用模板，事情噢那个就相对简单了，只要说我们存放对象而不是指针就行了。</p>
<h3 id="16-6-迭代器简介"><a href="#16-6-迭代器简介" class="headerlink" title="16.6 迭代器简介"></a>16.6 迭代器简介</h3><p>迭代器(iterator)是一个对象，它在其他对象的容器上遍历，每此选择它们中的一个，不需要提供对这个容器的实现的直接访问。迭代器提供了一种访问元素的标准方法，无论容器是否提供了直接访问元素的方法。迭代器常常与容器类联合使用，而且迭代器在标准 C++ 容器的设计和使用中是一个基本概念。迭代器也是一种设计模式(design pattern)。</p>
<p>迭代器通常模仿大多数指针的运算。然而，不同的是，迭代器的设计更安全，所以数组越界的可能性更小。</p>
<p>习惯上，用构造函数来创建迭代器，并把它与一个容器对象联系，并且在它的生命期中，不把它与不同的容器联系。</p>
<h2 id="第19章-深入理解模板"><a href="#第19章-深入理解模板" class="headerlink" title="第19章 深入理解模板"></a>第19章 深入理解模板</h2><p>C++ 模板应用的便利性远远超出了它只是一种“T类型容器”(containers of T)的范畴。尽管其最初的设计动机是为了能产生类型安全的通用容器，但在现在 C++ 中，模板也用来生成自定义代码，这些代码通过编译时的程序设计构造来优化程序的执行。</p>
<h3 id="19-1-模板参数"><a href="#19-1-模板参数" class="headerlink" title="19.1 模板参数"></a>19.1 模板参数</h3><p>模板有两类：函数模板和类模板。二者都是由它们的参数来完全地描绘模板的特性。每个模板参数描述了下述内容之一：</p>
<ul>
<li>类型(或者是系统固有类型或者是用户自定义类型)。</li>
<li>编译时常数值(例如，整数、指针和某些静态实体的引用，通常是作为无类型参数的引用)。</li>
<li>其他模板。</li>
</ul>
<p><strong>5.1.1 无类型模板参数</strong></p>
<p>一个无类型模板参数必须是一个编译时所知的整数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">size_t</span> N&gt;</div></pre></td></tr></table></figure>
<p><strong>5.1.2 默认模板参数</strong></p>
<p>在类模板中，可以为模板参数提供默认(缺省)参数，但是在函数模板中却不行。作为默认的模板参数，它们只能被定义一次，编译器会知道第一次的模板声明或定义。一旦引入了一个默认参数，所有它之后的模板参数也必须具有默认值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源自我大学时阅读本书的笔记，算是对自己的『温故知新』。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="Cpp" scheme="http://wdxtub.com/tags/Cpp/"/>
    
      <category term="经典" scheme="http://wdxtub.com/tags/%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>第三十三周 - 笔墨登场</title>
    <link href="http://wdxtub.com/2017/01/27/pen-and-ink/"/>
    <id>http://wdxtub.com/2017/01/27/pen-and-ink/</id>
    <published>2017-01-27T03:55:43.000Z</published>
    <updated>2017-01-27T07:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>起承转合连接着横竖撇捺儿，不能学白字先生不认偏旁笔划儿；辞旧迎新爆竹里炸出一个“福”字儿，五谷丰登米仓里屯着一个“丰”字儿。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.27: 完成初稿</li>
</ul>
<p>除夕啦春节啦，凑上年假居然有十天假期啦，特别感人呀！相比去年在匹兹堡过春节的天寒地冻，在广州在家里过节，开心指数有了成倍的提高。更不用说工作后终于能够自食其力，买买买再也不用眨眼睛。回国后的第一个春节，工作后的第一个春节，同一个春节给了我不一样的触动。对于生活，更加意识到了家人和朋友的重要性，大家在一起最重要就是开心；对于事业，更加坚定了信念，再次以『新参者』的态度去迎接挑战。</p>
<p><img src="/images/14854999393273.jpg" alt=""></p>
<p>年前终于买了属于自己的 Mavic Pro，借此机会去了不少地方借助『天空之眼』去看世界，也很开心能跟不同的朋友分享自己的感受。终于找到了一个值得投入的兴趣爱好，也在吃饭逛街看电影之外找到了更加有意思的活动。对我来说又找到了久违的热血与激情，每一次起飞和降落，都是非常有意思的体验。这么一说，就差一个女朋友一起到处去『飞』啦。</p>
<p>这周我的微博数量终于突破了五位数，不过博客的访问量还是没有能够在年前突破五十万，这个任务就交给接下来的十一个月吧！辛辛苦苦一年，也该休息休息，想想将来了。其中一个可见的将来是，这会是『大疆周记』的最后一篇了。</p>
<p>在大疆的这段时间得到了非常多的帮助和信任，也确确实实感受到了自己的成长，只是有的时候年轻的心还是不安于平淡安稳，于是公司利益与个人方向便出现了偏差。人生难得几回搏，害怕自己变得只敢去做平淡却不大会出差错的事情，希望自己能够一直跳动的追逐着，永远不要停下。</p>
<p>在这里祝大家新年快乐，新的一年希望能认识更多的朋友，飞得更高，看更大的世界。</p>
<p>古人云字如其人，透着一股精气神儿。俗话说师傅领进门儿，心要静手要勤，修行全看个人儿。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起承转合连接着横竖撇捺儿，不能学白字先生不认偏旁笔划儿；辞旧迎新爆竹里炸出一个“福”字儿，五谷丰登米仓里屯着一个“丰”字儿。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="春节" scheme="http://wdxtub.com/tags/%E6%98%A5%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>【降临】披着科幻皮的语言学</title>
    <link href="http://wdxtub.com/2017/01/23/arrival-movie/"/>
    <id>http://wdxtub.com/2017/01/23/arrival-movie/</id>
    <published>2017-01-22T23:57:07.000Z</published>
    <updated>2017-01-23T11:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>语言和文字的出现对任何一个物种来说都是里程碑式的大事，于是，文科生终于拯救了一次世界。（微量剧透）</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.23: 完成初稿</li>
</ul>
<p><img src="/images/14851294600253.jpg" alt=""></p>
<p>『烧脑』和『神作』这两个词都被滥用了，稍微需要推理和重组内容的就可以称之为『烧脑』，做几张酷炫的海报和几个宣传视频就可以叫『神作』。实话说，《降临》这部电影既算不上烧脑，也难以触及神作的标准，但导演和故事所想要表达的东西对于我这个非主流理科生来说还是很对胃口的，这里就想到哪里是哪里，写写我自己的感受吧。</p>
<p>我对语言的认识最初来源于父亲，虽然他一直说我对此有天赋，但是我一直是持怀疑态度的，毕竟很难分辨这到底是不是为了鼓励我让我好好学习的套路。直到后来因为要出国而开始准备托福和 GRE，我才意识到小时候我爸并没有说假话，蓝皮的长难句分析我翻了一遍就过去了，因为除了个别没有见过的表达方式，更多的长难句对我来说就和普通的句子没啥差别，既然一眼就能明白整个句子要表达什么，也就无需去分析句子的语法与词组的搭配了。</p>
<p>这样的自我感觉良好终结于遇到 CMU 语言系的一位教授，是他真正带我走进了语言学的大门。从修辞到文章组织，从语言到思维，我才意识到之前的想法是错误的，句子要表达的意思实际上是根植于语法与搭配中的，不存在『跳过』某步骤的说法，所谓『一眼就能明白句子的意思』不过是我认为的惯用法投射到了原文上，至于是不是原文想要表达的意思，不知道。而只有当明白了组成原文的每一个语言要素，才有可能真正明白其意思，简单来说就是从前我是以中文的模子去套英文，后来我学会了用英文本身去解释英文。</p>
<p>然后就会发现，虽然很多时候这两种方式都可以得到句子的意思，但其实是有细微差别的，只是这样的差别并不影响理解罢了。这里的原因也很简单，重要的沟通都会尽量以低语境的条件展开，即隐藏信息和可能造成的歧义较少。同样，这也能够解释为什么中国留学生大多难过语言关，因为学一门语言最终是学它的思维方式，但这是一个需要时间和精力去琢磨的事情。很多人意识不到个中的技术含量，简单地归结于词汇量和语法的问题，那肯定难以跟外国同事深入沟通，毕竟越是深入沟通越是需要对语言细节的把握，这些恰恰是大部分留学生都欠缺的。</p>
<p>关于语言和思维的讨论，一个很有趣的例子是乔治·奥威尔在《一九八四》中所提到的『新话』，新话试图通过抹去对不够和谐的词汇及表达来控制人们的思维，因为你有一个想法，但是你都没办法表达出来，那么这个想法其实就可以认为是不存在的。我们换个角度去看这个问题，就会意识到语言是能够影响思维的。另一个表现语言影响思维的例子是《合金装备 V 幻痛》，这款游戏中的反派试图通过消灭语言来达到天下大同，因为他认为不同的语言造成了不同的思维，最终导致了这个世界四分五裂。</p>
<p>前面讨论了这么多语言与思维，对不对暂且不说，从这个角度出发，就比较能够了解本片想要表达的内容了：</p>
<blockquote>
<p>女主角学会了外星人不受时间维度控制的语言，于是用这门语言交流思考的时候自我意识就可以超越时间维度，从而能够感知从过去到未来所有自己已有的和会有的记忆。</p>
</blockquote>
<p>为了配合『非线性时间观』这个概念，影片通过各种闪回和倒置从结果一步步回溯到原因，实际上也是带观众体验了一把『非线性』（这里需要解释一下，其实倒序也是一种线性，但问题在于如果做成纯非线性的，估计电影就没人看得懂了）。</p>
<p>外星人的表达方式其实跟我平时写文章的流程很像，我会把一篇文章中想要表达的东西以关键词和零碎句子的方式随意写在一张白纸上，虽然看起来是提纲，其实就是一张写满各种词汇的纸罢了。真正成文的时候，我会对这些关键词进行重新组织与加工，梳理出来逻辑和递进关系，最终成为一篇完整的文章。</p>
<p>停。这里其实就说到了关键。甚至可以认为《三体》中三体人的交流方式也是如此。</p>
<p>《三体》中说过三体人可以直接交流想法，所以不存在套路和欺骗。那么直接交流想法的形式可能是怎么样的呢？复盘我刚才提到的写作流程，其实就可以窥见一二。事情是这样的：</p>
<ol>
<li>我有了一个想法，想要表达</li>
<li>我通过写下各种关键词来确定要表达内容的范围和主题</li>
<li>我对这些关键词进行重新组织，加入逻辑与层次</li>
<li>我把组织好的语言写成文章，大家按照我选择的逻辑和顺序进行阅读</li>
</ol>
<p>这四步是人类通常的沟通交流方式，第三步中可以加入各种反直觉的逻辑，那么如果我们的交流不需要这四步，只要到第二步就足够了呢？按照这个方式去思考，就会发现电影中外星人所使用的文字说得通了，即交流的是想法本身，而不是围绕这个想法所形成的语言，于是用什么方式去沟通不重要，顶多是不同的沟通方式限制能能够表达的范围和精确度（有的从词汇出发，有的从游戏出发）。外星人的文字可以看做是想法的形式化展现，没有特定的顺序和形状，只是处于一种混沌的状态，反而可以认为是『无损』的（因为加入了逻辑与层次实际上对信息进行了有损压缩）。</p>
<p>于是我在想其实这并不是一部标准意义上的『科幻』作品，但正如『科幻』本身就是一种想法，怎么去描述是另外一回事儿。片尾提出的问题其实也是老生常谈了，不妨再重复一次：</p>
<blockquote>
<p>如果让你拥有预知未来的能力，你愿意吗？如果你已经知道未来，你会去改变吗？</p>
</blockquote>
<p>至于影片本身，有点像语言学天赋筛选机，通晓母语是不足够的，要能真正理解两种语言及其所带来的思维方式的异同，恐怕才能真正享受这部电影所带来的头脑风暴体验吧。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://movie.douban.com/review/8178580/" target="_blank" rel="external">关于语言，意识和记忆的呓语</a></li>
<li><a href="https://movie.douban.com/review/8068844/" target="_blank" rel="external">因即是果，果即是因的语言体系</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;语言和文字的出现对任何一个物种来说都是里程碑式的大事，于是，文科生终于拯救了一次世界。（微量剧透）&lt;/p&gt;
    
    </summary>
    
      <category term="Movie" scheme="http://wdxtub.com/categories/Movie/"/>
    
    
      <category term="电影" scheme="http://wdxtub.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="语言" scheme="http://wdxtub.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="文明" scheme="http://wdxtub.com/tags/%E6%96%87%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>【Go Web 编程】读书笔记</title>
    <link href="http://wdxtub.com/2017/01/23/build-go-web-clip/"/>
    <id>http://wdxtub.com/2017/01/23/build-go-web-clip/</id>
    <published>2017-01-22T16:38:59.000Z</published>
    <updated>2017-01-23T01:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>复习一下 Go 和  Web 的相关知识。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.23: 完成初稿</li>
</ul>
<p>Go 的类型系统没有层级。用户不需要在定义类型之间花费时间。Go 是垃圾回收型预研，为并发执行与通信提供了基本的支持。</p>
<p>Go 使用 <code>package</code> 来组织代码。<code>main.main()</code> 函数是每一个独立的可运行程序的入口点。Go 使用 UTF-8 字符串和标志符，所以天生支持多语言。</p>
<p>Go 的 <code>if</code> 允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> x := dosomething(); x &gt; <span class="number">10</span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Oh"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Yeah"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Go 里面有两个保留的函数：<code>init</code> 函数（能够应用于所有的 package）和 <code>main</code> 函数（只能应用于 package main）。这两个函数在定义时不能有任何的参数和返回值。虽然一个 <code>package</code> 里面可以写任意多个 <code>init</code> 函数，但这无论是对于可读性还是以后的可维护性来说，都强烈建议用户在一个 <code>package</code> 中每个文件只写一个 <code>init</code> 函数。</p>
<p>引入包的操作有两个需要注意</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    f <span class="string">"fmt"</span></div><div class="line">    _ <span class="string">"github.com/wdxtub/wdx"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>第一种引入方式是把包命名成一个比较好记忆的名字。第二个使用 <code>_</code> 则是引入该包而不直接使用包里面的函数，主要是为了调用该包里的 <code>init</code> 函数。</p>
<p>如果匿名字段实现了一个方法，那么包含这个匿名字段的 <code>struct</code> 也能调用该方法。</p>
<p><code>interface</code> 就是一组抽象方法的集合，它必须由其他非 <code>interface</code> 类型实现，而不能自我实现，Go 通过 interface 实现了鸭子类型：当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来像鸭子，那么这只鸟就可以被称为鸭子。</p>
<p>空 interface 有点类似于 C 中的 <code>void*</code> 类型。</p>
<p><code>fmt.Println</code> 可以接受任意类型的数据，其源代码中可以看到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</div><div class="line">    String() <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，任何实现了 <code>String</code> 方法的类型都能作为参数被 <code>fmt.Println</code> 调用。</p>
<p>如何知道 <code>interface</code> 变量里面保存了什么类型的数值？可以使用 comma-ok 语法，比如 <code>value, ok = element.(T)</code> 如果 element 确实是 T 类型，那么 ok 为 true，反之为 false。</p>
<p>另外一种方式是使用 <code>switch</code>，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</div><div class="line">    <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="keyword">int</span>:</div><div class="line">            fmt.Printf(<span class="string">"int"</span>)</div><div class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</div><div class="line">            fmt.Printf(<span class="string">"string"</span>)</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            fmt.Printf(<span class="string">"unknown"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Go 中进行并行程序开发时要注意：不要通过共享来通信，而要通过通信来共享。</p>
<p>对于普通的上网过程，浏览器本身是一个客户端，输入 URL 时首先会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过 IP 地址找到 IP 对应的服务器后，要求建立 TCP 连接，等待浏览器发送完 HTTP Request 包之后，服务器收到请求包才开始处理请求包，调用自身服务，返回 HTTP Response 包，客户端收到来自服务器的响应后开始渲染这个 Response 包里的 body，收到全部内容后，断开与服务器之间的 TCP 连接。</p>
<p>以下均是服务器端的几个概念：</p>
<ul>
<li>Request: 用户请求的信息，用来解析用户的请求信息，包括 post, get, cookie, url 等信息</li>
<li>Response: 服务器需要反馈给客户端的信息</li>
<li>Conn: 用户的每次请求链接</li>
<li>Handler: 处理请求和生成返回信息的处理逻辑</li>
</ul>
<p>http 包执行流程</p>
<ol>
<li>创建 Listen Socket，监听指定的端口，等待客户端请求到来</li>
<li>Listen Socket 接受客户端的请求，得到 Client Socket，接下来通过 Client Socket 与客户端通信</li>
<li>处理客户端的请求，首先从 Client Socket 读取 HTTP 请求的协议头，如果是 post 方法，还可能要读取客户端提交的数据，然后交给相应的 handler 处理请求，handler 处理完毕准备好客户端需要的数据，通过 Client Socket 写给客户端</li>
</ol>
<p>开发 Web 的一个原则就是，不能信任用户输入的任何信息，所以验证和过滤用户的输入信息就变得非常重要。一般有两方面的数据验证，一个是在页面端的 js 验证，一个是在服务端验证。</p>
<p>要使表单能够上传文件，第一步是添加 form 的 <code>enctype</code> 属性，有如下三种情况：</p>
<ul>
<li><code>application/x-www-form-urlencoded</code> 发送前编码所有字符（默认）</li>
<li><code>multipart/form-data</code> 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值</li>
<li><code>text/plain</code> 空格转换为 <code>+</code>，但不对特殊字符编码</li>
</ul>
<p>Web 开发中一个很重要的议题就是如何做好用户整个浏览过程的控制，经典的解决方案是 cookie 和 session，cookie 是一种客户端机制，把用户数据保存在客户端，而 session 机制是一种服务端的机制，服务器使用一种类似于散列表的结构来保存信息，每一个网站访客都会被分配给一个唯一的标志符，即 sessionID，它的存放形式无非两种，要么经过 url 传递，要么保存在客户端的 cookies 里（当然也可以保存到数据库里，更安全，但是效率会下降）</p>
<p>cookie 是有时间限制的，根据生命期不同分成两种：会话 cookie 和持久 cookie。如果不设置过期时间，则表示这个 cookie 生命周期为凑够创建到浏览器关闭为止，只要关闭浏览器窗口，cookie 就消失了。这种生命期为浏览会话期的 cookie 被称为会话 cookie。会话 cookie 一般不保存在硬盘上而是保存在内存里。</p>
<p>如果设置了过期时间 <code>setMaxAge(606024)</code>，浏览器就会把 cookie 保存到硬盘上，关闭后再次打开浏览器，这些 cookie 依然有效直到超过设定的过期时间。存储在硬盘上的 cookie 可以在不同的浏览器进程间共享，比如两个 IE 窗口。而对于保存在内存的 cookie，不同的浏览器有不同的处理方式。</p>
<p>session 机制本身并不复杂，然而实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当做普适的。</p>
<p>session 的基本原理是由服务器为每个会话维护一份信息数据，客户端和服务端依靠一个全局唯一的标识来访问这份数据，以达到交互的目的。当用户访问 Web 应用时，服务端程序会随需要创建 session，这个过程可以概括为三个步骤：</p>
<ul>
<li>生成全局唯一标志符 sessionid</li>
<li>开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就回丢失，如果是电子商务类网站，这将造成严重的后果。所以为了解决这类问题，你可以将会话数据写到文件里或存储在数据库中，这样虽然会增加 I/O 开销，但是可以实现某种程度的 session 持久化，也更有利于 session 的共享</li>
<li>将 session 的全局唯一标志符发送给客户端</li>
</ul>
<p>这里最关键的是如何发送 sessionid，一般有两种方式：cookie 和 URL 重写。</p>
<ol>
<li>Cookie 方式中服务端通过设置 Set-cookie 头就可以将 session 的标志符传送到客户端，而客户端此后的每一次请求都会带上这个标志符，另外包含 session 信息的 cookie 会将失效时间设置为 0（会话 cookie），即浏览器进程有效时间。至于浏览器怎么处理这个 0，不同浏览器有不同方案，但差别都不会太大。</li>
<li>URL 重写方式，就是在返回给用户的页面里的所有 URL 后面追加 sessionid，这样用户收到响应后会自动带上 sessionid，这种做法比较麻烦，但是如果客户端禁用了 cookie，这样方案是首选。</li>
</ol>
<p>session 劫持是一种广泛存在的比较严重的安全威胁，在 session 技术中，客户端和服务端通过 session 的标志符来维护会话，但这个标志符很容易就能被嗅探到，从而被其他人利用，是中间人攻击的一种类型。</p>
<p>如何有效防止 session 劫持呢？其中一个解决方案就是 sessionID 的值只允许 cookie 设置，而不是通过 URL 重置方式设置，同时设置 cookie 的 httponly 为 true，这个属性是设置是否可通过客户端脚本访问这个设置的 cookie，可以防止这个 cookie 被 XSS 读取从而引起 session 劫持，也更难获取 sessionID。然后我们需要在每个请求里面加上隐藏 token，每次提交都需要认证，这样来进行防范。</p>
<p>还有一个解决方案是给 session 额外设置一个创建时间的值，一旦超过，则销毁并重新生成，在一定程度上可以防止 session 劫持的问题。</p>
<p><code>Unmarshal</code> 解析的时候 XML 元素和字段怎么对应起来呢？首先会读取 struct tag，如果没有，那么就寻找对应字段名。必须注意的是解析的时候 tag、字段名、XML 元素都是大小写敏感的，所以必须一一对应字段。</p>
<p>现在的网络编程几乎都是用 Socket 来编程。Socket 起源于 Unix，而 Unix 基本哲学之一就是『一切皆文件』，都可以用『打开 open - 读写 write/read - 关闭 close』模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 具有一个类似于打开文件的函数调用 <code>Socket()</code>，该函数返回一个整型的 Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。</p>
<p>常用的 Socket 类型有两种：流式 Socket(<code>SOCK_STREAM</code>)和数据报式 Socket(<code>SOCK_DGRAM</code>)。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket，对应于无连接的 UDP 服务应用。</p>
<p>Socket 有两种：TCP Socket 和 UDP Socket，TCP 和 UDP 是协议，而要确定一个进程需要三元组，还要 IP 地址和端口。</p>
<p>WebSocket 是 HTML5 的重要特性，它实现了基于浏览器的远程 Socket，它使浏览器和服务器可以进行全双工通信。在 WebSocket 出现之前，为了实现即时通信，采用的技术都是『轮询』，这样会占用大量带宽。WebSocket 采用了一些特殊的报头，使得浏览器和服务器只需要做一个握手的动作，就可以在浏览器和服务器之间建立一条连接通道。且此连接会保持在活动状态，你可以使用 JavaScript 来向连接写入或从中接收数据，就像在使用一个常规的 TCP Socket 一样。</p>
<p>WebSocket 的协议颇为简单，在第一次握手通过以后，连接便建立成功，其后的通讯数据都是以 <code>\x00</code> 开头，以 <code>\xFF</code> 结尾。</p>
<p>REST 是一种架构风格，汲取了 WWW 的成功经验：无状态，以资源为中心，充分利用 HTTP 协议和 URI 协议，提供统一的接口定义，使得它作为一种设计 Web 服务的方法而变得流行。在某种意义上，通过强调 URI 和 HTTP 等早期 Internet 标准，REST 是对大型应用程序服务器时代之前的 Web 方式的回归。</p>
<p>RPC 就是想实现函数调用模式的网络化。客户端就像调用本地函数一样，然后客户端把这些参数打包之后通过网络传递到服务端，服务端解包到处理过程中执行，然后执行的结果反馈给客户端。</p>
<p>RPC(Remote Procedure Call Protocol) 远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。它假定某些传输协议的存在，如 TCP 或 UDP，以便为通信程序之间携带信息数据。通过它可以使函数调用模式网络化。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>运行时，一次客户机对服务器的 RPC 调用，其内部操作大致有如下十步：</p>
<ol>
<li>调用客户端句柄；执行传送参数</li>
<li>调用本地系统内核发送网络消息</li>
<li>消息传送到远程主机</li>
<li>服务器句柄得到消息并取得参数</li>
<li>执行远程过程</li>
<li>执行的过程将结果返回服务器句柄</li>
<li>服务器句柄返回结果，调用远程系统内核</li>
<li>消息传回本地主机</li>
<li>客户句柄由内核接收消息</li>
<li>客户接受句柄返回的数据</li>
</ol>
<p>很多 Web 应用程序中的安全问题都是由于轻信了第三方提供的数据造成的。在使用第三方提供的数据，包括用户提供的数据时，首先检验这些数据的合法性非常重要，这个过程叫做过滤。</p>
<p>加密的本质就是扰乱数据，某些不可恢复的数据扰乱我们称为单向加密算法或者散列算法。另外还有一种双向加密方式，也就是可以对加密后的数据进行解密。</p>
<p>XSS 攻击：跨站脚本攻击(Cross-Site Scripting)是一种常见的 web 安全漏洞，它允许攻击者将恶意代码植入到提供给其他用户使用的页面中。不同于大说书攻击（一般只涉及攻击者和受害者），XSS 涉及到三方，即攻击者、客户端与 Web 应用。XSS 的攻击目标是为了盗取存储在客户端的 cookie 或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。</p>
<p>XSS 通常可以分为两大类：一类是存储型 XSS，主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面就可能受到攻击。这个流程简单可以描述为：恶意用户的 HTML 输入 Web 程序 - 进入数据库 - Web 程序 - 用户浏览器。另一类是反射型 XSS，主要做法是将脚本代码加入 URL 地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。</p>
<p>XSS 目前主要的手段和目的如下：</p>
<ul>
<li>盗用 cookie，获取敏感信息</li>
<li>利用植入 Flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 Java 等得到类似的曹禺</li>
<li>利用 iframe, frame, XMLHttpRequest 或上述 Flash 等方式，以（被攻击者）用户的身份执行一些管理动作</li>
<li>利用可被攻击的域收到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动</li>
<li>在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果</li>
</ul>
<p>防治 SQL 注入的方法：</p>
<ol>
<li>严格限制 Web 应用的数据库操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</li>
<li>检查输入的数据是否具有所期望的数据格式，严格限制变量的类型</li>
<li>对进入数据库的特殊字符进行转义处理</li>
<li>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句</li>
<li>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测，及时修补发现的 SQL 注入漏洞</li>
<li>避免网站打印出 SQL 错误信息，比如类型错误、字段不匹配等，把代码里的 SQL  语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入</li>
</ol>
<p>目前用的最多的密码存储方案是将明文密码做单向哈希后存储，常用算法包括 SHA-256, SHA-1, MD5 等，可用 rainbow table 破解。</p>
<p>安全性比较好的网站，都会用一种『加盐』的方式来存储密码，就是常说的 salt，先将用户输入的密码进行一次 MD5（或其他哈希算法）加密，将得到的 MD5 值前后加上一些只有管理员自己知道的随机串，再进行一次 MD5 加密。</p>
<p>专家级方案是 <code>scrypt</code>，由著名的 FreeBSD 黑客 Colin Percival 为其备份服务 Tarsnap 开发的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习一下 Go 和  Web 的相关知识。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="Go" scheme="http://wdxtub.com/tags/Go/"/>
    
      <category term="Web" scheme="http://wdxtub.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>【通天塔之聊聊无人机】拾 飞行安全指南</title>
    <link href="http://wdxtub.com/2017/01/21/drone-thought-flysafe/"/>
    <id>http://wdxtub.com/2017/01/21/drone-thought-flysafe/</id>
    <published>2017-01-21T00:13:28.000Z</published>
    <updated>2017-01-21T03:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为一个无人机近距离拍摄飞机的视频，大家都开始关注无人机的飞行安全问题了，这里我简单说一下自己的想法，并给出简单的飞行安全指南。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.21: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="http://wdxtub.com/2016/07/10/drone-thought-overview/">壹 总览</a></li>
<li><a href="http://wdxtub.com/2016/07/10/drone-thought-tech/">贰 技术趋势</a></li>
<li><a href="http://wdxtub.com/2016/07/11/drone-thought-nasa/">叁 NASA 的计划</a></li>
<li><a href="http://wdxtub.com/2016/07/12/drone-thought-nasa-tech/">肆 NASA 的技术思路</a></li>
<li><a href="http://wdxtub.com/2016/07/12/drone-thought-google/">伍 Google 的想法</a></li>
<li><a href="http://wdxtub.com/2016/07/19/drone-thought-amazon/">陆 Amazon 的想法</a></li>
<li><a href="http://wdxtub.com/2016/09/03/drone-thought-collision-avoidance/">柒 碰撞规避</a></li>
<li><a href="http://wdxtub.com/2016/11/05/drone-thought-atm/">捌 航空管理</a></li>
<li><a href="http://wdxtub.com/2017/01/21/drone-thought-utm/">玖 无人机交通管理</a></li>
<li><a href="http://wdxtub.com/2017/01/21/drone-thought-flysafe/">拾 飞行安全指南</a></li>
</ul>
<h2 id="飞行安全面面观"><a href="#飞行安全面面观" class="headerlink" title="飞行安全面面观"></a>飞行安全面面观</h2><p>任何安全问题其实都是非常复杂的问题，比方说，无人机的飞行安全，至少包括了：</p>
<ul>
<li>无人机本身的安全</li>
<li>空域的安全</li>
<li>信号的安全</li>
<li>可能影响到的设备的安全</li>
</ul>
<p>无人机本身的安全主要依靠设备制造商的技术升级，比方说利用视觉、红外等设备来进行智能避障，提供更加稳定的飞控核心保证在各种复杂情况仍旧能够保证平稳飞行。</p>
<p>空域安全主要是指不与空中已有的飞行器互相干扰甚至导致事故。这部分因为没有相关的法律法规和技术支持，很多时候需要依赖飞手本身的素质的提升，当然这部分也会不断完善，但想一口吃个胖子恐怕是很难的。</p>
<p>信号安全指的是控制无人机的信号不会被劫持或恶意利用，这个和任何无人/自动驾驶系统的道理都是一样的，一旦系统被攻破，可能造成非常严重的后果。目前可能因为保有量不算太多所以还没有被大规模攻击，但各个部分的安全，得在设计之初就考虑进去。</p>
<p>作为从业者，我希望所有的航拍/无人机爱好者能够做出负责任的行为。我们努力工作为无人机添加更多可能，是希望大家能在合理合法的范围内玩得更尽兴，能够给更多人换一个角度审视自己的机会，而不是让人出风头而做出危及公共安全的事情。</p>
<p>在冷兵器时代，弓和弩的出现是一次巨大的飞越，从此人们拥有了远距离攻击的能力。但是在历史的长河中，很多朝代都是禁弩的，为什么，因为威力大使用简单且难以管控，稍不注意可能就会造成重大事故。相反，弓原则上来说是不会被禁止的，一是因为威力较小，二是因为需要一定了熟练度才能灵活运用，三是因为弓是很多家庭的生产工具，不可能直接一刀切。</p>
<p>我觉得从这样的历史中，我们是可以学习一些东西的，以史为鉴可以知兴替。</p>
<h2 id="无人机飞手的自我修养"><a href="#无人机飞手的自我修养" class="headerlink" title="无人机飞手的自我修养"></a>无人机飞手的自我修养</h2><p>虽然现在的无人机大多宣传『到手即飞』，但其实驾驶无人机像开车一样，是需要一定的训练的，不然不出问题才是奇了怪了。我的建议是『到手』先『看飞行指南』，再『起飞』。</p>
<h3 id="起飞点"><a href="#起飞点" class="headerlink" title="起飞点"></a>起飞点</h3><p>首先是选择起飞点：</p>
<ul>
<li>空旷开阔</li>
<li>风力不易过大（尤其是在海边的时候）</li>
<li>雨雪不能飞（比如空气湿度极大，云层极低，都需要注意）</li>
<li>避免鸟群、人群、高大建筑物、磁场干扰地方（尤其是磁场干扰，很多时候难以肉眼发现，请根据指示进行操作）</li>
</ul>
<h3 id="起飞前"><a href="#起飞前" class="headerlink" title="起飞前"></a>起飞前</h3><p>然后是起飞前的准备：</p>
<ul>
<li>安装桨叶，对应安装</li>
<li>开启电源，确保自检正常</li>
<li>GPS 需要 3 格以上</li>
<li>电池预热至 20 度</li>
<li>信道红条过多不宜飞</li>
</ul>
<h3 id="飞行中"><a href="#飞行中" class="headerlink" title="飞行中"></a>飞行中</h3><p>飞行中主要是依靠视觉维持水平稳定，超声波维持竖直方向稳定。如果是室内飞行：</p>
<ul>
<li>速度不易过快</li>
<li>地面不应是纯色或纹理重复率极高（比如马赛克）</li>
<li>下方不宜有运动的物体</li>
<li>不宜有明暗快速变化</li>
<li>地面倾斜角不应大于 30 度</li>
<li>地面不能吸收超声波（超厚的地毯）</li>
<li>水面或透明物体上不行</li>
<li>考虑关闭 GPS 定位，打开三脚架模式，小心谨慎操作</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>飞行遇到特殊情况时：</p>
<ul>
<li>图传中断，用天线侧面对准飞机，恢复图传</li>
<li>信号丢失，会自动返回</li>
<li>悬停不稳，控制降落（指南针或 GPS），用姿态模式稳定</li>
<li>迷失机头，使用状态球</li>
<li>大风无法悬停，尽快降落</li>
</ul>
<h3 id="常见错误飞行"><a href="#常见错误飞行" class="headerlink" title="常见错误飞行"></a>常见错误飞行</h3><p>一定要尽量避免如下的错误操作：</p>
<ul>
<li>在空中内八或外八，导致电机直接关闭</li>
<li>桨没有安装好或卡稳</li>
<li>返航高度的设置不对，需要根据周边环境进行对应设置</li>
<li>不听从应用的建议强行飞行，导致电量过低无法返航</li>
<li>超视距飞行避障失败，要保证飞行高度高于环境所有的物体</li>
<li>倒飞，避障失效（最新的机型支持后向避障）</li>
<li>恶劣条件强行起飞</li>
<li>刹车后偏移撞机</li>
</ul>
<h3 id="电池保养"><a href="#电池保养" class="headerlink" title="电池保养"></a>电池保养</h3><p>使用和保养电池同样是有技巧的</p>
<ul>
<li>放电过流、放电过温、放电低温、电芯损坏</li>
<li>关闭电池再拔出电池</li>
<li>低温需要预热</li>
<li>不要低于 10% 长期放置</li>
<li>每隔三个月需要充放电一次</li>
<li>不要接触液体</li>
<li>确保外界温度</li>
<li>使用官方充电器，充电完毕时断开</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>无人机不是一个简单的小玩具，一定要仔细读说明书，安全飞行，飞得尽兴。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为一个无人机近距离拍摄飞机的视频，大家都开始关注无人机的飞行安全问题了，这里我简单说一下自己的想法，并给出简单的飞行安全指南。&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="安全" scheme="http://wdxtub.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="飞行" scheme="http://wdxtub.com/tags/%E9%A3%9E%E8%A1%8C/"/>
    
      <category term="意识" scheme="http://wdxtub.com/tags/%E6%84%8F%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【通天塔之聊聊无人机】玖 无人机交通管理</title>
    <link href="http://wdxtub.com/2017/01/21/drone-thought-utm/"/>
    <id>http://wdxtub.com/2017/01/21/drone-thought-utm/</id>
    <published>2017-01-21T00:13:19.000Z</published>
    <updated>2017-01-21T02:42:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>无规矩不成方圆，在地面上我们有红绿灯斑马线车道交规，但是在空中怎么建立一套规则呢？</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.21: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="http://wdxtub.com/2016/07/10/drone-thought-overview/">壹 总览</a></li>
<li><a href="http://wdxtub.com/2016/07/10/drone-thought-tech/">贰 技术趋势</a></li>
<li><a href="http://wdxtub.com/2016/07/11/drone-thought-nasa/">叁 NASA 的计划</a></li>
<li><a href="http://wdxtub.com/2016/07/12/drone-thought-nasa-tech/">肆 NASA 的技术思路</a></li>
<li><a href="http://wdxtub.com/2016/07/12/drone-thought-google/">伍 Google 的想法</a></li>
<li><a href="http://wdxtub.com/2016/07/19/drone-thought-amazon/">陆 Amazon 的想法</a></li>
<li><a href="http://wdxtub.com/2016/09/03/drone-thought-collision-avoidance/">柒 碰撞规避</a></li>
<li><a href="http://wdxtub.com/2016/11/05/drone-thought-atm/">捌 航空管理</a></li>
<li><a href="http://wdxtub.com/2017/01/21/drone-thought-utm/">玖 无人机交通管理</a></li>
<li><a href="http://wdxtub.com/2017/01/21/drone-thought-flysafe/">拾 飞行安全指南</a></li>
</ul>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>随着无人机出货量与保有量的爆发式增长，低空空域这个无主之地（主要指相关法律法规还没有跟上）便成了兵家必争之地，毕竟除了少部分专业航拍需求的用户，大部分是娱乐飞行的用户，再加上可能出现的无人机送货，怎么能让不同人不同公司以不同角色合理高效安全使用空域，就成了迫切需要解决的问题。</p>
<p>在无人机管理这个问题上，最有分量的玩家有且只有三个：中国、美国和欧洲。对应的系统称之为 Unmanned Aircraft System (UAS) Traffic Management (UTM)，下文统称为 UTM。</p>
<p>美国布局最早，而且有 FAA 和 NASA 一起参与，在理论建设上已经走在了前面。美国的问题主要在于『理论很美好现实很骨感』，现实中各大公司都有自己的利益主张，不同州甚至不同地区都可能有自己的倾向，更不必说孱弱的基础建设，虽然人少地广任你飞，但是很多时候连手机信号都没有的话，很多事情就会变得很麻烦。举个简单的例子，虽然部分禁飞区是写入到无人机的固件中的，但是很多动态的是需要通过网络传输到手机上，给用户进行提示的，结果一次飞行的时候因为没有网络，误入了禁飞区，万一有个什么意外发生，可就不是吃罚单这么简单了。</p>
<p>相较于美国的松散邦联，欧洲的各个国家间的合作本来就难以做到无隙，更不用说英国脱欧这一黑天鹅事件对欧盟的未来产生的巨大影响。欧洲现有的的研究计划很多是基于欧盟这个共同体的，但是随着欧盟的势力范围和影响力逐步下滑（还有令人头疼的难民问题），研究资金能不能及时到位，出台标准后能不能得到所有成员国的通过，通过了之后大家的执行情况如何，都是值得考虑的问题。更麻烦的是，面对新事物，因为欧洲没有一个绝对的领军组织，利益集团间的博弈可能会更加旷日持久。</p>
<p>最后说说中国，中国的情况主要在于法律法规的不完善和相关人才的缺失。我国的航空业起步较晚，并且因为国防压力，只有少部分空域被划分给了民航。而对于超低空的相关空域划分与规定更是基本空白，所以形成了现在睁一只眼闭一只眼，出事儿了再进行处理的方式。但政府和相关机构其实已经意识到了这个问题，也在努力寻找可能的解决方案。中国的优势在于，最大的消费级无人机厂商终于是自己人了，很多前瞻性的测试和验证，都可以快速在本土进行，而一旦确定便可以自上而下的施行，一开始肯定会比较严格，但是随着相关法律法规的完备以及政府接受程度的提升，未来依然有无限可能。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>作为未来无人飞行器的交通管理系统，UTM 作为核心系统，需要一系列配套的设备，相信这也会应运出一系列产业，毕竟我们已经把地面、地下、海洋和高空都利用了起来，就只剩下低空了。在我看来，至少有以下三个方面值得我们去探索：</p>
<h3 id="无人机信息管理"><a href="#无人机信息管理" class="headerlink" title="无人机信息管理"></a>无人机信息管理</h3><p>我们知道围绕大飞机我们有一系列的航行监控检测方式（即使如此仍旧可能出现 MH370 这样的悲剧），那么这样的方式是否适用于无人机？这样带来的经济效应和限制有多少？如何针对不同场景进行对应的信息管理？如何与现有的航空系统兼容？</p>
<p>只有有了这么一个系统，才能保证大量无人机飞行的安全和效率，这也能够极大促进产业本身的发展</p>
<h3 id="地面技术"><a href="#地面技术" class="headerlink" title="地面技术"></a>地面技术</h3><p>我们日常使用的手机的数据链路实际上是通过各个基站来完成覆盖的，那么对于物联网新宠无人机来说，因为硬件设备本身的限制，在通信和监管上都会面比较大的挑战，传统的导航设备也不一定适用于超低空的情况，据此，有没有可能发展出一套低成本高覆盖率的地面支持系统。作为核心的数据链路，最好在现有技术的基础上找到最合适的，一是保证不会干扰到大飞机，二是保证在无人机数量大了之后不会互相干扰。</p>
<p>这部分需要详尽的技术规格，而且也是一个较新的思路，结合地面设备配合，无人机可以有更多应用。</p>
<h3 id="安全与隐私"><a href="#安全与隐私" class="headerlink" title="安全与隐私"></a>安全与隐私</h3><p>无人机的流行意味着人人都可以接触到飞行器，可能会带来隐私和安全的问题，所以需要在技术的支撑下做合理的限制，尽可能不让无人机飞进限飞区。如何减少利用无人机进行违法和危险行为需要制造商和服务提供商共同拿出一套解决方案。现在主要是利用地理围栏和视觉进行安全上的保障，但最近发生的爱好者用无人机近距离拍摄飞机降落的视频告诉我们，这样的限制还远远不够。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个行业的健康发展离不开合理的规则和强大的基础设施支持，尤其是在萌芽阶段，更需要参与的各方用心呵护，而不是竭泽而渔快速透支未来的可能。</p>
<p>不过这事儿吧，也急不来，还是好好踏踏实实一步一个脚印把事情做好吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无规矩不成方圆，在地面上我们有红绿灯斑马线车道交规，但是在空中怎么建立一套规则呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="无人机" scheme="http://wdxtub.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="交通" scheme="http://wdxtub.com/tags/%E4%BA%A4%E9%80%9A/"/>
    
      <category term="管理" scheme="http://wdxtub.com/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第三十二周 - 如何</title>
    <link href="http://wdxtub.com/2017/01/20/what-about/"/>
    <id>http://wdxtub.com/2017/01/20/what-about/</id>
    <published>2017-01-20T13:00:38.000Z</published>
    <updated>2017-01-20T14:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>岁月在这儿，温凉如丝却也能灼身。青春是远方流动的河。要如何原谅时光遗失的过程，要如何才能容忍它发生，要如何才能想而不问。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2016.01.20: 完成初稿</li>
</ul>
<p>上周日是我司研发部 2016 年终晚宴的日子，作为工作人员，一大早抵达会展中心进行设备调试和彩排。第一次亲眼目睹够掌控这么大的空间的总导演，内心的敬佩之情已经溢出。从团队安排到场面控制，从每个细微流程的安排到临场的应变，感觉未来我要走的路还很长，但是能和这么厉害的人共事，多骂我两句我也乐意（虽然越是厉害的人越是以礼待人）。</p>
<p>年会一开始是研发的老大致辞，和我平时接触的感觉一样，直来直往一针见血，明确指出了 2017 是要修炼内功的一年，毕竟这两年团队扩张太快，管理和效率没有完全跟上，很多经验的积累和复用也不够正规。这让在主控台的我诚惶诚恐，因为我在负责的项目正是为修炼『内功』而搭建平台，忽然就感觉肩上的担子又重了一些。</p>
<p>有年会当然少不了抽奖，今年的抽奖软件是我花三天学了一下 vue.js 然后搞出来的，为了保证公平，肯定是需要 code review 的，主持人问到谁有问题的时候，万万没想到是大老板第一个站出来提问，我在主控台被耀眼的聚光灯照着，总算是有惊无险地给出了合理的解释。这样一来，我的代码就是老板认证的了，接下来公司的其他几个部门基本都用得是我写的抽奖软件了，因此也认识了不少新朋友，我还是很开心的。</p>
<p>按级别来成长是很稳但是也很可怕的一种方式，级别本身是是因为采样率过低而不得不采取的一种权衡机制，当一个人成为了这种机制本身的时候，很多年少时的梦都不再有了，只剩下升级瞬间得到的有效期极短的快乐。还是希望自己能坚持去做自己喜欢的事情，临危受命，总觉得还有很多事情是我必须要去做，而且也能做好的，要坚持。</p>
<p>做事情一定是会遇到各种各样的阻力的，但是有的时候最大的阻力可能是想要放弃的念头。大疆作为一个年轻的公司，有好的一面，当然也有不好的一面。我觉得更多还是要看到好的一面，然后努力去改变不好的一面。这么大的队伍，可能真的是很难照顾到每个人的情绪，但是还是要勇敢展现自己，努力去承担责任，先完成一个小目标嘛。</p>
<p>这周经历了比较大的情绪波动，但是还算是做出了正确的选择，经过这样一番挣扎，感觉自己也成长了不少，既然是自己相信的事情，就好好去做吧！</p>
<p>要如何离别仍须游荡的旅人，要如何让缘份就是缘份，如何凝视缘份看我们的每种眼神。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;岁月在这儿，温凉如丝却也能灼身。青春是远方流动的河。要如何原谅时光遗失的过程，要如何才能容忍它发生，要如何才能想而不问。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>做人，做事，做自己</title>
    <link href="http://wdxtub.com/2017/01/18/behave-handle-be-myself/"/>
    <id>http://wdxtub.com/2017/01/18/behave-handle-be-myself/</id>
    <published>2017-01-17T22:59:52.000Z</published>
    <updated>2017-01-23T01:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>士人有百折不回之真心，才有万变不穷之妙用。立业建功，事事要从实地着脚，若少慕声闻，便成伪果；讲道修德，念念要从虚处立基，若稍计功效，便落尘情。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.22: 更新参考文章</li>
<li>2017.01.18: 完成初稿</li>
</ul>
<p>最近有些迷茫，有些摇摆，但归根结底问自己，是有些不安，有些不安带来的不安分。昨天和朋友吃饭的时候不经意的一句话点醒了我，让我意识到了自己的很傻很天真。可能是临近春节的缘故，几个我一直在关注的老司机都写了颇为掏心窝的文章，我一面看一面反思。一是觉得把自己的经验分享出来真的可能让别人少走一些弯路，感谢前辈们的分享；二是认识到自己初出茅庐的局限性，感谢同事朋友们一路的提携指点。</p>
<p>这几天上班下班的路上都在思考这个事情，总结下来正是标题中的三点：做人、做事、做自己。这之中顺序很重要，万万不可费尽心思找捷径：先做人，再做事，最终做自己。</p>
<p>做人，核心就两点：<strong>信任</strong>与<strong>坚持</strong>。信任不必多说，相信队友会以高度责任心完成工作，相信努力与贡献最终会被大家认可。做到信任，很多短期的投机行为就没有存在的意义了，不要成为一个还没开始干活就各种谈条件的人，这样本身就是一种不信任。而坚持并没有想象中这么简单，一是面对不公平和委屈要坚持下来，二是要坚持去做那些自己觉得对的事情，不能说稍有不顺心或者没有达到预期就想着换个地方会不会更好。抄近路反而把时间蹉跎掉了，不值得，还是要把心思放在做事上，做出贡献的同时，努力提高自己的核心竞争力。朋友的一句话让我非常有感触『我一直以来都认为的事情是，外面的机会大把大把的，问题是我自己有没有准备好 』，我想大概说得就是这个道理吧。</p>
<p>做事，重点在于持续输出，无论是写博客还是做项目，短期内看不到爆发式效果是很正常的，就像我写了十个月博客只有不到 80 个粉丝一样，谁能想到几个月之后这个数字就突破五位数了呢？在每个节奏点上都不吃亏，可能就在追求局部最优中提早结束自己的上升期。做事，持续努力证明自己的贡献，持续靠谱赢得更广泛的信任，持续沟通找到最佳解决方案。最近为公司做的一个抽奖软件，本来是为自己部门做的，后来三四个其他部门都用上了，反馈也还不错，这个事情让我意识到了把事情做好不是说要搞多么高大上的东西，而就是在最合适的时间给出最合理的实际可用的解决方案。短期不合理是常态，也不可能存在一个一开始就尽善尽美的系统，但是与其去抱怨这抱怨那，不如努力把事情做得更好。不把事情做好就开始夸夸其谈，其实是没有什么意义的。把工作做好有技巧，但是没有捷径，积累阶段，多接触多学，路也会宽一些。</p>
<p>做自己，恐怕要先找到自己，找到自己的方法很多，但是最靠谱的寻找方式一定是去尝试，而不是以旁观者的身份去看。就好像看了很多人航拍的视频，不自己真正飞一下，根本是没有办法体会个中真义的。而如果找到了特别喜欢的事情，正好自己也有能力让它变得更好，那就应该踏踏实实做出对得起自己这份喜欢的贡献，即使是别人看不到的地方，也要做得简洁优雅，因为很多事情本就不是做给别人看的。</p>
<p>迷则乐境成苦海，如水凝为冰；悟则苦海为乐境，犹冰涣作水。可见苦乐无二境，迷悟非两心，只在一转念间耳。就一身了一身者，方能以万物付万物；还天下于天下者，方能出世间于世间。</p>
<p>最后还是要再感谢一下一路上帮助我点拨我的朋友，觉得自己很幸运，要努力对得起自己的这份幸运。</p>
<p>附：参考文章</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NjYxNDk4Mw==&amp;mid=2650720468&amp;idx=1&amp;sn=5e4068f79086897fc518b2c5d11c0f94&amp;chksm=beeceefc899b67ea5e2b4359526a7ddf9cb6dd9336352ce369cd4cfe73801eefa67f60541e5f#rd" target="_blank" rel="external">《厂职工和厂长的委屈》</a></li>
<li><a href="http://weibo.com/ttarticle/p/show?id=2309404065202692840548" target="_blank" rel="external">《打杂和搬砖》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;士人有百折不回之真心，才有万变不穷之妙用。立业建功，事事要从实地着脚，若少慕声闻，便成伪果；讲道修德，念念要从虚处立基，若稍计功效，便落尘情。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://wdxtub.com/categories/Thinking/"/>
    
    
      <category term="成长" scheme="http://wdxtub.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="态度" scheme="http://wdxtub.com/tags/%E6%80%81%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>第三十一周 - 初心不忘</title>
    <link href="http://wdxtub.com/2017/01/14/dont-forget-the-heart/"/>
    <id>http://wdxtub.com/2017/01/14/dont-forget-the-heart/</id>
    <published>2017-01-14T01:08:23.000Z</published>
    <updated>2017-01-14T02:07:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在的我们其实都一样，普普通通，匆匆忙忙。一个个平凡而年轻的脸庞，却有着自己，特别的小梦想。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2016.01.14 完成初稿</li>
</ul>
<p>随着气温骤降，广州和深圳终于有了冬天的感觉，这下无论是吃火锅还是吃烧烤都成了开心的选择，唯一不高兴的可能就是体重秤了。气温虽然低了，但是因为临近过年，大家的热情还是高涨的，尤其是在筹备年会这件事儿上，各个部门都都开始忙碌了起来。</p>
<p>我的活比较简单，就是写一个抽奖软件，因为要抽几百个奖项，所以逻辑上一定是要跟现场流程配合的，这就意味着，需求会经常改，我也只能通过一次一次的预演来尽量让抽奖的过程更加自然一些。其实我是非常享受这种努力打磨产品，然后再自己实现出来的感觉的，这种『掌控感』让人欲罢不能。</p>
<p>说是抽奖软件，其实就是一个网页，这是从易用性的角度所得出的技术选型，于是就选择了 Vue.js 来完成这个任务。都不知道当时自己哪来的自信，居然敢在从没有学过前端的时候，在截止日期如此临近的时候，选择一个对自己来说完全陌生的技术，简直完美演绎了 No Zuo No Die。但是神奇的是，居然三天内连学带弄，不但弄完了自己部门的抽奖软件，还顺手把另一个部门的做了，逻辑虽然有些不同，但是可能是一开始的数据结构设计得比较科学，只改几行代码就成。这里我要感谢靠谱的小军大哥在关键的几行代码上指点迷津，拯救了世界。这个故事告诉我们，司机还是老的好，胜读十年书小人书。</p>
<p>现在想来，用项目来逼迫着自己成长，其实还是挺有意思的事情，Vue.js 其实想说要学一两个月了，终于在年末来了个一步到位，虽然还有很多细节的部分没搞懂，比方说实现细节以及浏览器的特点，但是师傅领进门，修行靠个人，相信我的前端水平会随着 W.I.S.E 项目的陆续开展而快速进步的。就像学习计算机系统的时候要从底层的数电逻辑、门电路一路理解到汇编、高级语言，我觉得学习前端也要搞清楚从页面到浏览器最终实现这一整条完整的链路，这样遇到问题的时候才知道如何排查和解决，不然就只能完成一些机械重复的工作而没有任何成长了。</p>
<p>上个周末因为大学室友补办婚宴又回了广州，正好带着无人机飞飞飞飞完之后见到了久违的同学们。可是这种大场面就只能大家热闹一下，我还是觉得要深入聊聊天，得一对一，或者就是俩人一起录制一期『小土刀叨』播客嘛。周末航拍完之后彻底下定决心，买了 Mavic Pro，也于今天到货了。于我，新的创作时代开始了，但是从另一个角度看，颇有『一语成谶』的感觉。</p>
<p>趁着年末整理生活的时候，把自己的 <a href="https://github.com/wdxtub" target="_blank" rel="external">Github</a> 清理了一下，老的项目合并到了归档中，新的项目基本会围绕 <a href="https://github.com/wdxtub/wdxtub.github.io" target="_blank" rel="external">博客</a> 和 <a href="https://github.com/wdxtub/W.I.S.E" target="_blank" rel="external">W.I.S.E</a> 来进行了，噢，还有我的笔记归档 <a href="https://github.com/wdxtub/WDXpeak" target="_blank" rel="external">WDXpeak</a>。另外最近感觉利用收费来过滤非目标用户是挺好的办法，所以 W.I.S.E 在内测的时候不收费，但是进入公测的时候是会进行收费的（内测用户的数据不会丢失且我会个人掏腰包为内测用户提供两年的年费）。</p>
<p>跑步的意义是甩掉那些无意义的烦恼，整理生活的意义是把真正重要的烦恼变成目标，看看在一路烦恼过程中有没有什么可以改变的。年轻人不该安于现状，回忆也是为了更好地往前看。我还是想沿着抵抗力最大的路径走，想要去追寻更大的挑战。虽然我意识到 2017 仍旧是巨变的一年，但是没想到一切来的如此快。</p>
<p>那就面对疾风吧！</p>
<p>将来的我们，和今天不一样。天高海阔，任凭翱翔。一个个厚重而可靠的肩膀，滚烫的胸膛，不变的是倔强。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的我们其实都一样，普普通通，匆匆忙忙。一个个平凡而年轻的脸庞，却有着自己，特别的小梦想。&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【小土刀玩摄影】δ 个人航拍飞行器选购指南</title>
    <link href="http://wdxtub.com/2017/01/09/dji-tour-1/"/>
    <id>http://wdxtub.com/2017/01/09/dji-tour-1/</id>
    <published>2017-01-09T14:22:05.000Z</published>
    <updated>2017-01-11T00:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>假如你想换个角度从空中看世界，正好又不知道如何选择合适的个人航拍飞行器的话，那么看完这篇文章相信你心中会有答案。</p>
<p>注：本文主要介绍 Mavic Pro, Phantom 4 Pro 和 Phantom 4 这三款产品。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.11: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="http://wdxtub.com/2016/11/12/alpha-7-tour-1/">α 开拍</a></li>
<li><a href="http://wdxtub.com/2016/11/12/alpha-7-tour-2/">β 读说明书</a></li>
<li><a href="http://wdxtub.com/2016/11/16/alpha-7-tour-3/">γ 从镜头到构图</a></li>
<li><a href="http://wdxtub.com/2017/01/09/dji-tour-1/">δ 个人航拍飞行器选购指南</a></li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>时至今日，我还很清楚地记得第一次坐飞机时，从窗外往下看时的震撼：像血管一般的公路与河流，像蚂蚁一般的车辆与行人与像小朋友一般激动的自己。当我第一次在手机屏幕上看到无人机『看』到的景色时，我才意识到飞翔本身的无限可能。而在我用无人机飞行了 44 次，共 6 小时 15 分钟，总里程 31449 米之后，我能感觉到某种深埋心底的本能被唤醒了：原来我心中，有一个想要飞得更高的梦。</p>
<p>前几天在微博上发了一下自己用无人机拍摄的作品，不少朋友表示了好奇，于是在这里我把自己对无人机的理解和自己飞行的感受分享给大家，算是一个小小的导购吧。</p>
<h2 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h2><p>航拍航拍，有航也有拍，我们也正是通过这两个标准来选择最合适自己的航拍飞行器的。消费级无人机领域主要有两个品牌：一是大疆，二是其他。我就不推荐大家买非大疆的产品了，毕竟都是要买，为什么不买个飞着安全智能省心的呢？</p>
<p>大疆的航拍飞行器又主要分为两大类：一是个人航拍，二是专业航拍。考虑到我只在个人航拍上有一点点经验，专业航拍的部分我就不班门弄斧了。本文旨在从大疆推出的最新几款个人航拍产品中帮大家找到最合适自己的。</p>
<p>航拍中的『航』，是『拍』的基础，拍照需要稳定停在空中，摄像需要飞行动作连贯流畅，而拍摄过程的飞行也需要非常智能（避障、跟随等等）。与此同时，因为我们是通过手机屏幕来查看镜头所『看』到的图像的，所以保证图像的稳定传输也很重要。这里我总结出了几点，作为打分的依据，他们是：</p>
<ul>
<li><strong>悬停</strong>：指飞行器静止在空中某个位置而不飘移，尤其是在有风的时候，只有这样，拍出来的照片才不会虚</li>
<li><strong>机动</strong>：指飞行器运动时的可操作性与飞行安全性，当然还有最重要的续航</li>
<li><strong>图传</strong>：指飞行器与遥控器之间的信号传输的能力</li>
<li><strong>便携</strong>：指飞行器全套装备的编写程度，毕竟带着越轻松，拍得机会才更多</li>
</ul>
<p>而对于『拍』来说，各项指标基本和相机的评价标准差不多，虽然我不是专业玩相机的，但是也算是拍过一点点，这里就以我的个人主观感受来进行简单的评价，标准是：</p>
<ul>
<li><strong>镜头</strong>：主要是基本的镜头素质</li>
<li><strong>成像</strong>：软硬件配合的成像质量，包括色彩等等</li>
</ul>
<p>具体参数什么的可以去文中附带的链接中查看，我会从以上六个角度分别给不同的设备打出 0-10 的分数，并最终给出总分（诸如<strong>性价比</strong>之类的综合指标也考虑在内），供大家参考。</p>
<h2 id="Mavic-Pro"><a href="#Mavic-Pro" class="headerlink" title="Mavic Pro"></a><a href="http://www.dji.com/cn/mavic" target="_blank" rel="external">Mavic Pro</a></h2><p>开始之前我们先看一段视频 — <a href="https://www.skypixel.com/videos/7f05fe97-8d4c-4e2e-8c4a-a4778b20b6ba" target="_blank" rel="external">大疆“御”产品介绍</a>。</p>
<p><img src="/images/14840933196045.jpg" alt=""></p>
<p>飞 Mavic 的整体感觉是声音没那么大了，操作起来更轻盈的同时，甚至更稳一些（与 Phantom 4 对比）。可折叠所带来的便携性的意义可能比大多数人想象得要大得多，从一个航拍设备到一个像玩具的航拍设备所带来的飞跃，相信真正飞一次就能明显感觉到。</p>
<ul>
<li><strong>悬停</strong>：8 分。在风力不大的情况下，稳，真的稳如狗</li>
<li><strong>机动</strong>：7 分。起飞时明显能够感受到轻飞如燕的感觉，惯性也比 Phantom 系列小，得心应手</li>
<li><strong>图传</strong>：6 分。有干扰环境（比如说市区）的信号传输基本上 500 米以外就开始信号不稳了</li>
<li><strong>便携</strong>：9 分。整体打包的体积只有 Phantom 系列的三分之一不到，这样的飞跃真的改变游戏</li>
<li><strong>镜头</strong>：6 分。为了便携牺牲了镜头的质量，但是已经做得足够好了</li>
<li><strong>成像</strong>：7 分。白天效果不错，晚上基本不能放大看，有过饱和和过锐的倾向，但这些可以后期调整，无伤大雅</li>
</ul>
<p>总分：<strong>8 + 1 = 9 分</strong>。加的一分来自便携性带来的轻松以及本身的高性价比。</p>
<h2 id="Phantom-4-Pro"><a href="#Phantom-4-Pro" class="headerlink" title="Phantom 4 Pro"></a><a href="http://www.dji.com/cn/phantom-4-pro" target="_blank" rel="external">Phantom 4 Pro</a></h2><p>开始之前我们先看一段视频 — <a href="https://www.skypixel.com/videos/dji-phantom-4-pro" target="_blank" rel="external">DJI - Phantom 4 Pro 介绍视频</a>。</p>
<p>实话说，我没有飞过 Phantom 4 Pro，但是丰富的 Phantom 4 飞行经验告诉我，Phantom 4 Pro 所带来的改进，如果换个样子，真的可以直接叫 Phantom 5 了。如果不是 Mavic 太 666 完全碾压了 Phantom 4 的话，恐怕 4 Pro 还可以晚一点再出。新增的四向避障虽然左右方向只能在低速模式运行，但用作自动航拍跟踪的机器，是足够了的。后向避障的加入使得更多极限操作变得更加安全，新的 1 寸传感器也使得成像质量得到了质的提高，唯一的缺点，就是太贵以及不知道什么时候又被下一代产品打趴下了。</p>
<ul>
<li><strong>悬停</strong>：9 分。考虑到 Mavic 已经做到的稳如狗，这一点完全没有必要怀疑。</li>
<li><strong>机动</strong>：9 分。更加全面收集环境信息使得智能飞行的速度上限提高了不少，甚至拍公路片都毫无压力</li>
<li><strong>图传</strong>：7 分。目测大部分条件下飞个两三公里毫无压力，具体有待实测</li>
<li><strong>便携</strong>：6 分。重就一个字，不信全套背一次</li>
<li><strong>镜头</strong>：8 分。有了 RX100M3 的大底加成，剩下的就是看成像调教了</li>
<li><strong>成像</strong>：9 分。完全扭转了孱弱的夜景能力，如果主要拍夜景，不要犹豫了</li>
</ul>
<p>总分：<strong>9 - 1 = 8 分</strong>。减的一分来自较低的性价比以及贵出天际的配件价格。</p>
<h2 id="Phantom-4"><a href="#Phantom-4" class="headerlink" title="Phantom 4"></a><a href="http://www.dji.com/cn/phantom-4" target="_blank" rel="external">Phantom 4</a></h2><p>开始之前我们先看一段视频 - <a href="https://www.djivideos.com/video_play/2d54ffc1-b12e-48b7-9075-8cf4839872a6" target="_blank" rel="external">DJI - Phantom 4 介绍视频</a></p>
<p><img src="/images/14840933408171.jpg" alt=""></p>
<p>Phantom 4 是我飞得最多的一个机型，广州深圳上海南京，室内室外，甚至还用来在朋友的婚礼上送过一次戒指（没错就是模仿汪峰），也是我最为了解的机型。Phantom 4 标志着飞行器进入了机器视觉时代，为创作者提供了更大的想象空间。虽然只有前向和底部避障，悬停也不算特别稳，但其智能水平已经让我喜出望外。作为我航拍的启蒙伙伴，好用够用爱用就足以说明一切。</p>
<ul>
<li><strong>悬停</strong>：7 分。实话说，有些不够稳定，不知道是不是我用过的那一台的本身原因</li>
<li><strong>机动</strong>：8 分。跟着我全速跑毫无压力，问题来了，紧急刹车(机)的能力有待加强，侧面和后面都是瞎子让人飞起来有些担心</li>
<li><strong>图传</strong>：6 分。市区里干扰大非常煎熬，但是稍微空旷一些的地方，两三公里无压力</li>
<li><strong>便携</strong>：6 分。重就一个字，不信全套背一次</li>
<li><strong>镜头</strong>：7 分。比 Mavic 好点但是不如 4 Pro，总之是完全够用的</li>
<li><strong>成像</strong>：8 分。色彩还原真实，直接用相册自带的美化功能，就可以搞出大片的效果了</li>
</ul>
<p>总分：<strong>7 + 0.5 = 7.5 分</strong>。降价后性价比有一定提升，各类配件和 4 Pro 通用也是一个小小的加分项。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>追求便携买 Mavic Pro，真的会大大提高出门航拍的意愿</li>
<li>追求画质买 Phantom 4 Pro，和索尼 RX100M3 一样的传感器，用过的都知道靠谱</li>
<li>预算有限买 Mavic Pro，不得不说 Phantom 4 的处境很危险啊</li>
<li>那么什么时候买 Phantom 4 呢，下次打折促销的时候？毕竟只剩下性价比一个竞争力了</li>
</ul>
<p>PS: 有对无人机和航拍感兴趣的朋友可以来免费约飞，至于出不出台就要看我时间和心情了哈。下面是一些我看过感觉不错的评测和教学视频，看了估计就会买买买了，谨慎点开啊。</p>
<h2 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h2><ul>
<li><a href="http://www.bilibili.com/video/av7834320/" target="_blank" rel="external">《值不值得买》第119期：你能闭着眼睛开无人机吗——精灵4Pro</a></li>
<li><a href="http://www.bilibili.com/video/av7409541/" target="_blank" rel="external">《值不值得买》第111期：“御”疆飞翔——Mavic Pro</a></li>
<li><a href="https://www.skypixel.com/videos/141abac3-fa15-49c6-b8a4-266386220853" target="_blank" rel="external">“御” Mavic 系列教学视频—平行/锁定跟随与手势自拍</a></li>
<li><a href="https://www.skypixel.com/videos/eb0744b8-1e20-4f5e-b718-f940fe04838e" target="_blank" rel="external">“御” Mavic 系列教学视频-智能跟随</a></li>
<li><a href="https://www.skypixel.com/videos/53d996a6-91aa-4737-a9c2-c8896356c9e2" target="_blank" rel="external">“御” Mavic 系列教学视频-精准悬停</a></li>
<li><a href="https://www.skypixel.com/videos/0120380f-9692-49b8-ac10-485f4e77eed7" target="_blank" rel="external">“御” Mavic 系列教学视频-精准降落</a></li>
<li><a href="https://www.skypixel.com/videos/c99901cb-b0cd-4502-b221-baab945ce788" target="_blank" rel="external">“御” Mavic 系列教学视频-指点飞行</a></li>
<li><a href="https://www.skypixel.com/videos/1497efce-795a-4ccd-8e72-11df07e74d36" target="_blank" rel="external">Phantom4 Pro应用教学视频-相机使用</a></li>
<li><a href="https://www.skypixel.com/videos/59ae0fa6-cfbe-4ac0-b9dd-19c1a7947cd1" target="_blank" rel="external">Phantom 4 Pro 系列教学视频—指点飞行</a></li>
<li><a href="https://www.skypixel.com/videos/edf9eccf-9313-48c8-9062-6b3057598747" target="_blank" rel="external">Phantom 4 Pro 系列教学视频—手势自拍</a></li>
<li><a href="https://www.skypixel.com/videos/6228520f-8c47-4d00-85b3-d9bb169a6def" target="_blank" rel="external">Phantom 4 Pro 系列教学视频—智能跟随</a></li>
<li><a href="https://www.skypixel.com/videos/phantom-4-d5ba64f5-0086-4fc5-97a1-4141368a3d0a" target="_blank" rel="external">DJI - 大疆科技: Phantom 4智能飞行电池</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假如你想换个角度从空中看世界，正好又不知道如何选择合适的个人航拍飞行器的话，那么看完这篇文章相信你心中会有答案。&lt;/p&gt;
&lt;p&gt;注：本文主要介绍 Mavic Pro, Phantom 4 Pro 和 Phantom 4 这三款产品。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="无人机" scheme="http://wdxtub.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="航拍" scheme="http://wdxtub.com/tags/%E8%88%AA%E6%8B%8D/"/>
    
  </entry>
  
  <entry>
    <title>【星球大战外传：侠盗一号】醉卧沙场君莫笑</title>
    <link href="http://wdxtub.com/2017/01/07/starwars-rogue-one/"/>
    <id>http://wdxtub.com/2017/01/07/starwars-rogue-one/</id>
    <published>2017-01-07T02:12:00.000Z</published>
    <updated>2017-01-07T03:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>义军同盟并不那么有义，银河帝国也并不那么帝国，但星战系列有了新的气魄。注：本文包含少量剧透。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.06: 完成初稿</li>
</ul>
<p>我一直把星球大战划分到超级英雄电影这个类别中，毕竟主角最终总是要出来拯救世界的。虽然我至今没有完全弄明白原力是什么，但其实到最后我发现，重要的不是原力，而是那种对自己相信的东西的坚持，对自己珍惜的东西的守护。人固有一死，但能找到自己的使命并为之献身，也是一件幸福的事情。</p>
<p><img src="/images/14837607187817.jpg" alt=""></p>
<p>整部电影的时间不短，但故事内容异常庞大，不同阵营不同角色不同任务能够有条不紊的串联起来，最后还强行用 CG 和正传续上，简直加一秒。</p>
<p>自从在电影院看到海报时发现甄子丹和姜文的身影，我的心里其实是有点担忧的，毕竟『长城』里尿崩的中国演技着实令人尴尬。看完之后长吁一口气：还是有会演戏的中国演员的嘛，完美融入的同时甚至可以说非常出彩，以至于一觉醒来我脑海里留下的画面是甄子丹最后杀入枪林弹火的身影。</p>
<p>如果一定要为整部电影选一个关键词，那非『希望』莫属。但是在希望背后，是无数人的勇气与牺牲，最终化为一曲悲壮的赞歌：『人民战士驱虎豹，舍生忘死保和平。为什么战旗美如画，英雄的鲜血染红了她。为什么大地春常在，英雄的生命开鲜花』。这种精气神是从前的星战电影里所未曾着力刻画的，但是忽然在外传里这么展现出来，让人感觉非常震撼。</p>
<p>『希望』与『悲壮』通过侠盗一号小队的每个人的变化被展现得淋漓尽致，与此同时导演也非常克制，没有搞大段大段的煽情，反而是牺牲时的平静更让人感觉到难过。来不及悲伤啊！要继续战斗！所以当姜文义无反顾开始最后的战斗时，我想起的是亮剑里的台词：骑兵连，进攻！</p>
<p>除了英雄主义元素，片中还展现了其他一些主题，包括但不限于：</p>
<ul>
<li>当义军同盟发展到一定程度之后表现出和帝国一样的低效时，是不是每次都能有带主角光环的人站出来拯救世界？</li>
<li>战争的一方一旦拥有了压倒性的攻击手段，这场战争要怎么进行下去？</li>
<li>为了目的是否可以不择手段？还是目的本身只是干了伤天害理的事情之后用来心安的借口？</li>
<li>人与人工智能机器人要以什么样的方式相处，机器人出现了情感要怎么办？</li>
</ul>
<p>当然可能很多问题也许永远都找不到答案，这个时候像甄子丹一样快速默念：</p>
<blockquote>
<p>I am one with the Force, and the Force is with me.</p>
</blockquote>
<p>毕竟，古来征战几人回。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;义军同盟并不那么有义，银河帝国也并不那么帝国，但星战系列有了新的气魄。注：本文包含少量剧透。&lt;/p&gt;
    
    </summary>
    
      <category term="Movie" scheme="http://wdxtub.com/categories/Movie/"/>
    
    
      <category term="星球大战" scheme="http://wdxtub.com/tags/%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98/"/>
    
      <category term="外传" scheme="http://wdxtub.com/tags/%E5%A4%96%E4%BC%A0/"/>
    
      <category term="中国元素" scheme="http://wdxtub.com/tags/%E4%B8%AD%E5%9B%BD%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>第三十周 - どんなときも(任何时候)</title>
    <link href="http://wdxtub.com/2017/01/06/anytime/"/>
    <id>http://wdxtub.com/2017/01/06/anytime/</id>
    <published>2017-01-06T12:59:43.000Z</published>
    <updated>2017-01-07T02:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>无法超越的，既不是电车也非时间，很可能就是我自己。「喜欢的就是喜欢」，想要坚持可以这样说的感觉。</p>
<a id="more"></a>
<hr>
<p>新年的第一周是风平浪静的一周，按照计划该跑步跑步该看书看书该写博客写博客，仅此而已。春节忙着旅游忙着走亲访友，反而是元旦和春节的间隙更适合放松和休息。今天第一次从公司里领了新年礼盒，正应了『过了腊八就是年』的说法，年的气氛一下就充满了办公室。</p>
<p>当然工作还是得有条不紊的进行，比方说挑选年会要喝的红酒，写年会要用的抽奖软件，试穿年会的衣服等等。要参与各种各样的组织，我不但能够理解，甚至还很开心能够利用技术减轻大家的负担。学以致用起于学终于用，只有跳出技术本身才能发挥技术的最大价值，这种跨界的能力也许才是我未来的核心竞争力。</p>
<p>之前加了几个读书和跑步的群，但是发现在这两个事儿上，我既不需要别人鼓励也不需要只言片语的零碎分享，或者说读得越多跑得越多越意识到这俩事儿是非常私人的，超过三四个人就会变成闲聊群了，于是都默默退出了。当然，整篇的有主题的分享还是很有意义的，写一篇文章放到网上，就能跨越时间和空间跟有缘人分享，这么想想还是蛮神奇的。虽然最近世界走向封闭的趋势愈演愈烈，但我依然想让信息的流通更通畅些。公众号和各种封闭 App 虽然给出了许多优质内容，但是没办法自由流动，一滴水还是要融入大海里才不会干涸嘛。</p>
<p>新年的跑步计划已经轰轰烈烈开启了，每周一共跑个三四次基本也就差不多了，多了就有些累了。最近跟同学聊了聊，发现每周工作六天基本是常态化了。九九六的工作时间基本是正常工作制的两倍了，再加上要牺牲一天休息时间，三倍工资的话是可以考虑的。但从公司的角度来说肯定是希望出一个人的工资但是获得三倍的产出，这就是问题所在了。</p>
<p>年前参加了一下高中同学聚会，见到大家还是这么『纯洁』我就放心了，同学们分布在各行各业，新的一年一定要好好把播客节目做起来。随着 W.I.S.E. 项目的展开，也在慢慢接触各类新技术了，总体来说，新的一年还有好多值得期待的地方呀。</p>
<p>楼宇之间看起来如此狭小，随着夕阳西下焦躁的心情随之溶解。在迷茫中，持续探寻的日子，终会变为答案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无法超越的，既不是电车也非时间，很可能就是我自己。「喜欢的就是喜欢」，想要坚持可以这样说的感觉。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="新年" scheme="http://wdxtub.com/tags/%E6%96%B0%E5%B9%B4/"/>
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【自由软件，自由社会】读书笔记</title>
    <link href="http://wdxtub.com/2017/01/05/free-software-free-society-clip/"/>
    <id>http://wdxtub.com/2017/01/05/free-software-free-society-clip/</id>
    <published>2017-01-05T00:45:33.000Z</published>
    <updated>2017-01-06T23:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是理查德·斯托曼选集第三版的阅读笔记，我一直认为，互联网自由开放的精神是各种层出不穷创造力的来源，我也会尽我所能去捍卫它。</p>
<a id="more"></a>
<hr>
<p>我的感受：这本书主要是对与自由相关的几个重要概念的思考，比如GNU，甚至有些『极端』和『矫情』，正文之前反而更有趣一些。</p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>软件和硬件对我们的信息时代和互联网一样重要。自由软件被称为是革命性的政治理论,就如同我们可以控制自己的生活,我们也应该能够控制那些延伸我们身体的机器。</p>
<p>自由软件作为一种政治理论承认了软件和硬件系统在我们社会中所扮演的角色。批判之前和现在的制度是必要的。我们也许会发现自己无法修改既存制度。我们成为了别人制造的那些不公道制度的牺牲品,而他们本身就是不公道的。而这些制度的产出并非总是显而易见,特别是当我们被迫接受这些制度安排,尤其是当它们已变成标准化和品牌标准的时候。自由软件并不仅仅只是批评:它可以成为提供自由的替代品,依赖于自由的标准,自由地为大众使用。</p>
<p>自由软件提供了一种转变的范例,我们可以自由的从前人那里理解并学习,自由地成长和分享,从错误中学习,从学习中受益,并分享这些益处给每一个人。</p>
<p>投身于自由软件不仅仅是对于知识,同时也包括授权:授权学习,授权修改,授权分享,以及授权使之能够被分享。争取信息时代的自由需要拒绝在自由软件核心原则上妥协,并且要有牺牲精神。很多人可能拒绝这些负担,他们只想获得更多的财富;而其他人却在努力增加人类知识的深度和广度。通过实现自由软件,我们能发现一种面向长期愿景的可持续性发展模式,不仅增加了知识,同时切实可行的的将这些知识自由地分享给所有人。这份崇高的事业以其无差别的关怀泽及我们每一个人;从现实到超现实,自由软件都被涉及。</p>
<p>当我们的世界最终理解了代码的威力和危险,终于认识到代码和法律、政府一样,必须透明才能获得自由时,不妨回首看着这位强硬且不屈不挠的程序员,会发现他终身奋斗的景象终于实现:自由和知识可以在编译器下幸存。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>“自由软件”(FreeSoftware)表示的是那些尊重用户和社区自由的软件。粗略的说,它赋予用戶运行、复制、分发、学习、修改并改进软件的自由。</p>
<p>如果一个软件的用户拥有以下四项基本自由,那么该软件可以被称为自由软件:</p>
<ul>
<li>基于任何目的,按你的意愿运行软件的自由(自由之零)。</li>
<li>学习软件如何工作的自由,按你的意愿修改软件以符合你的计算的自由(自由之一)。可访问源代码是此项自由的先决条件。</li>
<li>分发软件副本的自由,因此你可以帮助你的邻居(自由之二)。</li>
<li>将你修改过的软件版本再分发给其他人的自由(自由之三)。这样可以让整个社区有机会共享你对软件的改动。可访问源代码是此项自由的先决条件。</li>
</ul>
<p>学校有一项社会使命:要教导学生成为一个坚强、有才能,独立、相互协作并且自由的社会中的一名公民。学校应该像推广保育和选举一样推广自由软件的使用。通过教授自由软件,学生能成为自由的数字化时代的合格公民。这项工作能帮助社会从整体上脱离大集团公司的统治。</p>
<p>自由软件鼓励每个人学习。自由软件社区反对“高高在上的技术”——这会让大众对技术的基本原理敬而远之。我们鼓励任何年龄层次学生或个人阅读源代码,而且,我们希望他们学得越多越好。</p>
<p>学校使用自由软件最深层次原因是可以进行德育教育。我们希望学校教给学生基本的知识和有用的技巧,但是这只是学校工作的一部分。学校最根本的一项职能,就是培养好公民——其中包括助人为乐的习惯。在计算机领域,这就意味着我们需要教授学生分享软件的精神。</p>
<p>教授学生使用自由软件,让他们参与自由软件社区,就是一门生动鲜活的公民教育课程。这门课程教授将会把学生培养成为具有公共服务精神的行为模范,而不是垄断企业的超级大亨。所有学校都应该使用自由软件。</p>
<p>从国家的计算主权角度来说,国家需要坚持自由软件的主张(国家控制其计算过程)。所有用户理所应当控制自己的计算过程,但国家有代表人民对计算过程维持控制的责任。现在大多数政府活动都依赖计算过程,而对这些活动的控制则依赖于对计算过程的控制。而在任务很关键的机构里失去这种控制将会极大危害国家安全。</p>
<p>软件有实现的层次;例如,一个软件包可能包括库、命令和脚本。但这些层次对软件的自由没有明显的贡献,因为可以把所有这些层次都变得自由。设计程序的组件和设计把组件组合在一起的代码是同类的工作;与其类似,从源代码编译程序的组件和将这些从源代码编译出来的组件组合在一起的程序是同类的工作。使整个系统自由只需继续工作直到完成整件任务。</p>
<p>因此,我们坚持主张程序要在全部层次上自由。对一个分类为自由软件的程序,组成它的每一行源代码都得是自由的,这样你才能只用自由的代码重建这个程序。</p>
<p>自由软件和“开源软件”这两个说法其实说的几乎都是同一类软件,但是它们所秉持的价值观是根本不同的。开源是一种开发方法论,自由软件是一场社会运动。对自由软件运动而言,自由软件是一种道义责任,尊重用户最根本的自由。而另一方面,开源的哲学更关注如何让软件“更好”——只关心实用价值。开源认为,非自由软件只是手边问题的欠妥解答,关于“开源”的大多数讨论并不关注对与错,只关注知名度和成功。</p>
<p>然而自由软件运动中,非自由软件是一个社会问题,解决方案就是停止使用并转向自由软件。</p>
<p>科学文献存在的理由应当是传播科学知识,并且科学期刊存在的理由应当是促进这一进程,这应该是一种不言自明的真理。由此可以推论,使用这些科学文献的规则应当被设计为有助于实现这一目标。</p>
<p>我们现在所拥有的规则,称之为版权,最初建立于印刷机时代,这是一种从本质上来说相对中心化的印刷量产方式。在这样一种印刷环境下,期刊文章的版权仅仅约束期刊发行者——要求它们获得出版文章的许可——以及潜在的抄袭者。它有助于期刊运营以及传播知识,而并未影响科学家们或者学生们的有用成果,不论对于文章的作者还是读者。这种规则可以很好地适应这种体系。</p>
<p>但是,用于科学文献发表的现代技术是万维网(WorldWideWeb)。那么,什么样的规则才能确保在网络上传播科学文献和知识的效果最大化呢?文献应当以非私有格式发布,并且对所有人开放访问权限。而且每个人应当有权利为文献提供“镜像”,即在满足适当署名的条件下逐字发表原文。</p>
<p>这些规则应当同样适用于过去与未来的文献,只要它们是以电子形式发布的。但是,现在并不急迫需要改变当前的版权体系,由于它们仍然适合于纸版期刊,此处的问题不属于那个领域。</p>
<p>自由软件意味着软件被其用户所控制,而不是相反。具体的说,这意味着软件在到达用户手中时,就具有用户应该得到的四大基本自由。列表中的第一条自由是自由之零:按照你的意愿运行程序来做你自己想做的事情。</p>
<p>你所拥有的是决定软件能够用来做什么的机会——当你决定实现什么功能的时候。你可以编写一个主要被你认为行为正当的人使用的软件,你也没有任何义务去编写任何可能被别人用于你不认同的行为的功能。</p>
<p>结论是明确的:程序不应当限制用户利用它所完成的工作。自由之零必须完整无缺。我们需要禁止酷刑,但我们不能通过软件许可协议来做到这点。软件许可协议的正确职责是建立与保护用户的自由。</p>
<p>一个人做出的每个决定都取决于这个人的价值观和目标。人们可以有很多种不同的目标和价值观;声誉、利益、爱情、生存、快乐和自由,其中有一些目标只有一些优秀的人才可能拥有。当这个目标是一种原则时,我们称之为理想主义。</p>
<p>一个理想主义的目标激励着我在自由软件上的工作:传播自由与协作的理念。我想鼓励自由软件的传播,取代阻碍合作的专有软件,从而使我们的社会更加美好。</p>
<p>当我们谈论自由软件时,我们指的是行为的自由,而非价格免费。GNU通用公共授权被设计为确保您拥有发布自由软件副本(以及为此收费,如果您希望的话)的自由,确保您能收到源代码或者在您需要时能获取源代码,确保您能修改软件或者将它的一部分用于新的自由软件,并且确保您知道您能做这些事情。</p>
<p>为了保护您的权利,我们需要做出要求,禁止任何人否认您的这些权利或者要求您放弃这些权利。因此,如果您发布此软件的副本或者修改它,您就需要肩负起尊重他人自由的责任。</p>
<p>例如,如果您发布自由软件的副本,无论以免费还是以收费的模式,您都必须把您获得的自由同样的给予副本的接收者。您必须确保他们也能收到或者得到源代码。而且您必须向他们展示这些条款,以使他们知道自己享有这样的权利。</p>
<p>自由软件运动致力于带来一场社会变革:让所有软件成为自由的,这样所有软件用户将获得自由,并且将会成为协作化社区的一部分。与之相反,任何一个非自由的程序赋予了其开发者凌驾于用户之上的不公权力。我们的目标是终结这种不公。</p>
<p>自由之路,路漫漫兮。这需要经历很多步骤,花费很多年的时间才能达到这样一种境地:软件用户拥有自由成为一种常态。这些步骤当中的一些可能会非常艰难,甚至需要为之付出一些牺牲。而其中有些步骤可能会变得简单,如果我们与其他拥有不同最终目标的人们达成某种妥协。</p>
<p>“开源”的哲学满足于消费者价值并且以此为前提,肯定并且强化这些消费者价值,这就是我们不能支持“开源”的原因。</p>
<p>为了完全地、长久地建立一个自由社区,我们要做的绝不仅限于让人们使用某些自由软件。我们需要宣传按照公民价值评估软件(及其他事物)的理念,即基于它们是否尊重用户的自由和社区,而非仅限于所谓的“易用性”。这样人们就不会落入以吸引人、易用的特性作为诱饵的私有软件的陷阱之中。</p>
<p>为了推广公民价值,我们必须讨论它们并且说明它们怎样才能成为我们的行为准则。我们必须拒绝戴尔•卡耐基式的妥协,因为这将通过强调人们的消费者价值而影响他们的行为。</p>
<p>破坏性的妥协不仅仅是对他人的不良影响,它还会通过认知上的不一致扭曲您自己的价值观。如果您抱有某种价值观,但是您的行动表现出来的是与之相冲突的其他价值观,您很可能将会试图改变您的价值观或者行动,以便解决这种矛盾。因此,那些仅仅争论实践上的好处的,或者引导用户转向某些私有软件的项目,几乎不可避免地羞于哪怕只是暗示“私有软件是不符合伦理的”。对于它们的参与者,以及对于公众,它们只能强化消费者价值。我们必须拒绝这些妥协,如果我们想要坚持我们自己的价值观不动摇。</p>
<p>一条能够让您更快前行的道路有时并不是一条更好的道路,如果它通往错误的目的地。为了成就一个充满雄心壮志的目标,做出一些妥协是必需的。但是,一定要警惕那些将您引离最终目标的妥协。</p>
<p>在自由软件运动中,我们主张的是软件用户的自由。我们在规划视角的时候审视了哪些自由是美好的生活方式所必需的,并且使得实用的程序能够帮助一个友善、合力、协作的社区成长。我们对于自由软件的评价尺度指出了软件用户赖以同社区协作所需的自由。</p>
<p>我们主张程序员的自由,同对待其他用户一样。我们中的大部分人是程序员,在赋予您自由的同时也需要拥有我们自己的自由。但我们中的每个人都需要使用由他人编写的软件,并且我们需要在使用那些软件的时候拥有自由,而不仅仅是使用我们自己编写的代码的自由。我们代表所有用户的自由,不论他们经常、偶尔还是从不进行编程。</p>
<p>然而,有一种所谓的自由是我们绝不提倡的,即“为您所编写的软件随意选择授权许可的自由”。我们拒绝承认这一条的原因在于它实际上是一种权力而非自由。</p>
<p>如果我们不想要一个全面监控的社会,我们必须将监控视为一种社会污染,并且限制监控对每一个新系统的影响,如同我们要限制实体建设工程对环境的影响。</p>
<h2 id="关于软件的基础知识"><a href="#关于软件的基础知识" class="headerlink" title="关于软件的基础知识"></a>关于软件的基础知识</h2><p>计算机程序员来写软件或者计算机程序。而程序可以认为是告诉计算机如何完成特定任务的一系列指令。你应该熟悉许多不同类型的应用程序:比如你的网页浏览器、你的文字处理器和你的邮件客户端等等。</p>
<p>程序最初的形态通常是源代码。这一系列高级指令由编程语言(比如C或者Java)编写而成。之后会被一个名为编译器的工具编译为一种更底层的语言——汇编语言。另一种被称为汇编器的工具会将汇编代码分解为最终的机器语言——计算机可以原生理解的最底层代码。</p>
<p>另一个重要概念是理解什么是操作系统。操作系统是控制输入输出,内存分配和任务调度的软件。通常点说,一些更常见且更有用的程序,比如图形用户界面(GraphicalUserInterface,GUI),也是操作系统的一部分。GNU/Linux操作系统包括GNU和非GNU软件,以及一个被称为Linux的内核。内核负责处理底层任务比如输入输出和任务调度。GNU软件包含了操作系统其余的大部分,比如GCC,一款支持多种语言的通用编译器;GNUEmacs,一款可扩展的并且有很多很多特性的文本编辑器;GNOME,GNU桌面环境;GNUlibc,一个程序库,除内核外所有其他程序与内核通讯时都必须使用的库;以及Bash,GNU命令行解释器可以读取你的命令行。这些程序很多都是早期由理查德·斯托曼在GNU工程里开发,并成为现代GNU/Linux操作系统的组成部分。</p>
<p>重要的是理解即使你没有修改程序源代码或直接使用所有这些工具的能力,找到一个可以做到的人也是相对容易的。因此,有源代码的程序你就有权力去修改、修复、定制和学习编程——而如果得不到源代码就没有这些权力。源代码是让一个软件变自由的必要条件之一,而其他必要条件可从本书的哲学和理想中找到答案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是理查德·斯托曼选集第三版的阅读笔记，我一直认为，互联网自由开放的精神是各种层出不穷创造力的来源，我也会尽我所能去捍卫它。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="思考" scheme="http://wdxtub.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Linux" scheme="http://wdxtub.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【通天塔之 W.I.S.E.】壹 开发路线图</title>
    <link href="http://wdxtub.com/2017/01/04/wise-roadmap/"/>
    <id>http://wdxtub.com/2017/01/04/wise-roadmap/</id>
    <published>2017-01-04T14:04:00.000Z</published>
    <updated>2017-01-06T23:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>W.I.S.E. 的全称是 Wdxtub’s InSight Engine，目的是打造一个人工智能管家。本文会给出具体的开发计划和路线图，让我们来一起看看 W.I.S.E. 能做什么吧！</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.04: 完成初稿</li>
</ul>
<p>为了配合 <a href="http://wdxtub.com/2016/12/30/2017-outside-window">2017 年度计划</a>，我不得不在手机上安装了一系列应用来应对各种简单却繁琐的需求，各类数据被一个个应用沙盒关闭在了孤岛中。于是我在想，有没有办法首先让所有的数据『流动』起来，然后随着时间的积累，从中挖掘出更多的有价值的东西呢？</p>
<p>答案是肯定的，但可惜的是，现在市面上还没有这么个产品，于是我决定自己做一个。</p>
<p><img src="/images/14835401520649.jpg" alt=""></p>
<ul>
<li>总览会自动选择最近的重要事项进行展示<ul>
<li>模块化展示，做成可配置的即可</li>
</ul>
</li>
<li>Wise 机器人：类似 Siri，可以用自然语言进行简单的交互<ul>
<li>相关技术：自然语言处理、知识图谱、自动问答</li>
</ul>
</li>
<li>信息流：推送精选信息（豆瓣、微博、知乎、及其他博客网站），结合机器学习进行信息筛选<ul>
<li>相关技术：爬虫、关键词抽取，知识图谱、推荐系统、搜索引擎</li>
</ul>
</li>
<li>笔记本：基于 Markdown 的笔记本<ul>
<li>WKK 中已有功能，需要集成到 W.I.S.E 中</li>
</ul>
</li>
<li>剪报本：自动导入 Kindle 等设备的书摘数据，方便整理到笔记本中<ul>
<li>WKK 中已有功能，需要集成到 W.I.S.E 中</li>
</ul>
</li>
<li>待办事项：GTD 风格任务管理（项目管理，可以链接到任意笔记）<ul>
<li>首发功能，后续 W.I.S.E. 项目就会以此为项目管理工具</li>
</ul>
</li>
<li>年度计划：年度计划的进度追踪与管理，还有重大日期记录（倒数日）<ul>
<li>优先开发功能，会以更加自动和智能的方式来进行年度计划跟踪管理</li>
</ul>
</li>
<li>数据统计：个人相关数据统计及可视化展示<ul>
<li>博客爬虫及页面访问分析</li>
</ul>
</li>
<li>分析报告：自动周报、月报、年报，结合年度计划给出分析与建议</li>
</ul>
<p>会首先做 Web 端，然后是针对 iPhone 的 iOS 应用（其他设备就用 Web 端吧）。具体的时间点还需要时间考虑，留待以后更新吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;W.I.S.E. 的全称是 Wdxtub’s InSight Engine，目的是打造一个人工智能管家。本文会给出具体的开发计划和路线图，让我们来一起看看 W.I.S.E. 能做什么吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Technique" scheme="http://wdxtub.com/categories/Technique/"/>
    
    
      <category term="开源" scheme="http://wdxtub.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="个人" scheme="http://wdxtub.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>【性能之巅：洞悉系统、企业与云计算】读书笔记</title>
    <link href="http://wdxtub.com/2017/01/04/system-performance-clip/"/>
    <id>http://wdxtub.com/2017/01/04/system-performance-clip/</id>
    <published>2017-01-04T00:45:33.000Z</published>
    <updated>2017-01-04T12:10:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于性能优化，最大的太占就是性能分析，而性能分析要求我们对于操作系统、网络的性能要了如指掌，明细各个部分的执行时间数量级，做出合理的判断。</p>
<a id="more"></a>
<p>性能的话题，从一开始就是复杂的。性能是一种典型的非功能需求，然而又贯穿在任何一种功能需求中，直接影响系统运行效率和用户体验。也正是由于这一特性，性能无法简单地通过单一的、直线式的思维来度量和管理，而注定需要以系统工程的方式来掌握和调整。</p>
<p>学生时代课本上计算机科学哪些诸多的概念和理论所呈现出的完美感觉更多是在书本上，在真实系统中往往更多是另外一副更为『现实』的景象。当系统庞大到一定程度时，其复杂性会变得不容易控制是一件很正常的事情。用技术手段把这些『失控』的点妥善摆平就是工程师价值的体现。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>性能问题可能来源于任何地方，包括系统中因你一无所知而不曾检查的地方（未知的未知）。</p>
<p>操作系统是一个复杂的软件体，管理着各种不断变化的物理设备，应对着不同的新应用程序的工作负载。内核也在持续地发展，不断增加新的特性以提高特定的工作负载的性能，随着系统继续扩展，所遇到的瓶颈被逐一移除。改进操作系统性能需要不断的分析和努力，这样才能带来性能的持续提升。</p>
<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><p>系统性能是对整个系统的研究，包括了所有的硬件组件和整个软件栈。所有数据路径上和软硬件上所发生的事情都包括在内，因为这些都有可能影响性能。</p>
<p>性能领域包括了以下的事情，如：</p>
<ol>
<li>设置性能目标和建立性能模型</li>
<li>基于软件或硬件原型进行性能特征归纳</li>
<li>对开发代码进行性能分析（软件整合之前）</li>
<li>执行软件非回归性测试（软件发布前或发布后）</li>
<li>针对软件发布版本的基准测试</li>
<li>目标环境中的概念验证测试</li>
<li>生产环境部署的配置优化</li>
<li>监控生产环境中运行的软件</li>
<li>特定问题的性能分析</li>
</ol>
<p>术语容量规划(capacity planning)指的是一系列事前行动。在设计阶段，包括通过研究开发软件的资源占用情况，来得知原有设计在多大程度上能满足目标需求。在部署后，包括监控资源的使用情况，这样问题在出现之前就能被预测。</p>
<p>性能分析必须量化问题的重要程度，有一个指标非常合适，就是延时(latency)。</p>
<p>动态跟踪技术把所有的软件变得可以监控，而且能用在真实的生产环境中。这项技术利用内存中的 CPU 指令并在这些指令之上动态构建检测数据。这样能从任何运行的软件中都可以获得定制话的性能统计数据，从而提供了远超系统的自带统计所能给予的观测性。</p>
<p>DTrace 对用户态和内核态的软件都提供了静态跟踪和动态跟踪，并且数据是实时产生的</p>
<h2 id="第二章-方法"><a href="#第二章-方法" class="headerlink" title="第二章 方法"></a>第二章 方法</h2><blockquote>
<p>在取得数据之前就把事情理论化是一个严重的错误。不理智的人扭曲事实来适应理论，而不是改变理论来适应事实。</p>
</blockquote>
<p>面对一个性能不佳且复杂的系统环境时，首先需要知道的挑战就是从什么地方开始分析、收集什么样的数据，以及如何分析这些数据。</p>
<p><strong>受测系统</strong></p>
<p><img src="/images/14834954125245.jpg" alt=""></p>
<p>扰动(perturbation)是会影响结果的，扰动包括定时执行的系统活动、系统的其他用户以及其他的工作负载。现代环境的另一个困难是系统很可能由若干个网络化的组件组成，都用于处理输入工作负载，包括负载平衡、Web 服务器、数据库服务器、应用程序服务器，以及存储系统。</p>
<p><strong>排队系统</strong></p>
<p><img src="/images/14834955366660.jpg" alt=""></p>
<h2 id="第三章-操作系统"><a href="#第三章-操作系统" class="headerlink" title="第三章 操作系统"></a>第三章 操作系统</h2><p>了解操作系统和它的内核对于系统性能分析是至关重要的。你会经常需要进行针对系统行为的开发和测试，如系统调用是如何执行的、CPU 是如何调度线程的、有限大小的内存是如何影响性能的，或者是文件系统是如何处理 I/O 的。</p>
<p>这部分的内容本书主要介绍了基本的概念，最好还是结合《深入理解计算机系统》来弄懂，不然真的很容易一知半解，列举如下：</p>
<ul>
<li>内核：内核执行、时钟、内核态</li>
<li>栈：用户栈和内核栈</li>
<li>中断和中断线程</li>
<li>中断优先级</li>
<li>进程：进程创建、进程生命周期、进程环境</li>
<li>系统调用</li>
<li>虚拟内存</li>
<li>内存管理</li>
<li>调度器</li>
<li>文件系统：VFS、I/O 栈</li>
<li>缓存（括号内为例子）：应用程序缓存、服务器缓存(Apache 缓存)、缓存服务器(Redis)、数据库缓存(MySQL 缓冲区高速缓存)、目录缓存(DNLC)、文件元数据缓存(inode 缓存)、操作系统缓冲区高速缓存(segvn)、文件系统主缓存(ZFS ARC)、文件系统次缓存(ZFS L2ARC)、设备缓存(ZFS vdev)、块缓存(缓冲区高速缓存)、磁盘控制器缓存(RAID 卡缓存)、存储阵列缓存、磁盘内置缓存</li>
<li>网络</li>
<li>设备驱动</li>
<li>多处理器：CPU 交叉调用</li>
<li>抢占</li>
<li>资源管理</li>
<li>观测性</li>
</ul>
<h2 id="第四章-观测工具"><a href="#第四章-观测工具" class="headerlink" title="第四章 观测工具"></a>第四章 观测工具</h2><p>性能观测工具可以按照系统级别和进程级别来分类，多数的工具要么基于计数器要么基于跟踪：</p>
<p><img src="/images/14834977227611.jpg" alt=""></p>
<p><strong>计数器</strong></p>
<p>内核维护了各种统计数据，称为计数器，用于对事件计数。通常计数器实现为无符号的整型数，发生事件时递增。</p>
<p>系统级别的计数器有：</p>
<ul>
<li><code>vmstat</code>: 虚拟内存和物理内存的统计，系统级别</li>
<li><code>mpstat</code>: 每个 CPU 的使用情况</li>
<li><code>iostat</code>: 每个磁盘 I/O 的使用情况，由块设备接口报告</li>
<li><code>netstat</code>: 网络接口的统计，TCP/IP 栈的统计，以及每个连接的一些统计信息</li>
<li><code>sar</code>: 各种各样的统计，能归档历史数据</li>
</ul>
<p>进程级别：</p>
<ul>
<li><code>ps</code>: 进程状态，显示进程的各种统计信息，包括内存和 CPU 的使用</li>
<li><code>top</code>: 按一个统计数据排序，显示排名高的进程</li>
<li><code>pmap</code>: 将进程的内存段和使用统计一起列出</li>
</ul>
<p>一般来说，上述这些工具是从 <code>/proc</code> 文件系统里读取统计信息的。</p>
<p><strong>跟踪</strong></p>
<p>跟踪收集每一个事件的数据以供分析。跟踪框架一般默认是不启用的，因为跟踪捕获数据会有 CPU 开销，另外还需要不小的存储空间来存放数据。</p>
<p>系统级别：</p>
<ul>
<li><code>tcpdump</code>: 网络包跟踪(libpcap lib)</li>
<li><code>blktrace</code>: 块 I/O 跟踪</li>
<li>DTrace: 跟踪内核的内部活动和所有资源的使用情况，支持静态和动态的跟踪</li>
<li>SystemTap: 同上</li>
<li><code>perf</code>: Linux 性能事件，跟踪静态和动态的指针</li>
</ul>
<p>进程级别：</p>
<ul>
<li><code>strace</code>: 系统调用跟踪</li>
<li><code>gbd</code>: 源码级别的调试器</li>
</ul>
<p>还有很多具体的细节，不过因为我不是专攻这个的，所以留待以后有需要时再继续研究</p>
<h2 id="第五章-应用程序"><a href="#第五章-应用程序" class="headerlink" title="第五章 应用程序"></a>第五章 应用程序</h2><p>性能调整离工作所执行的地方越近越好：最好在应用程序里，包括 Web 服务器、应用服务器、负载均衡器、文件服务器，等等。</p>
<p>设立性能目标能为你的性能分析工作指明方向，并帮助你选择要做的事情。没有清晰的目标，性能分析容易沦为随机的『钓鱼探险』。常见目标：</p>
<ul>
<li>延时</li>
<li>吞吐量</li>
<li>资源使用率</li>
</ul>
<p>应用程序性能技术：选择 I/O 尺寸、缓存、缓冲区、轮训(epoll)、并发和并行、非阻塞 I/O、处理器绑定</p>
<p>编程语言相关：编译语言使用编译器优化、解释语言一般不是首选、虚拟机、垃圾回收</p>
<h2 id="第六章-CPU-第九章-磁盘"><a href="#第六章-CPU-第九章-磁盘" class="headerlink" title="第六章 CPU - 第九章 磁盘"></a>第六章 CPU - 第九章 磁盘</h2><p>这部分一般来说在云时代可以暂时不用特别考虑，故略。</p>
<h2 id="第十章-网络"><a href="#第十章-网络" class="headerlink" title="第十章 网络"></a>第十章 网络</h2><p>网络通信是由一组协议栈组成的，其中的每一层实现一个特定的目标：</p>
<p><img src="/images/14835103300448.jpg" alt=""></p>
<p>一些网络通信和网络性能相关概念：网络和路由、协议、封装、包长度、延时（主机名解析延时、ping 延时、连接延时、首字节延时、往返时间、连接生命周期）、缓冲、连接积压队列、接口协商、使用率、本地连接。</p>
<p>对于日常监测来说，最常用的还是各种工具，如：</p>
<ul>
<li><code>netstat -s</code>: 查找高流量的重新传输和乱序数据包</li>
<li><code>netstat -i</code>: 检查接口的错误计数器</li>
<li><code>ifconfig</code>: 检查『错误』『丢弃』和『超限』</li>
<li><code>ip(8)</code>: 检查传输和接收的字节率</li>
<li><code>tcpdump/snoop</code>: 尽管需要大量的 CPU 开销，短期使用可能就足以发现谁在使用网络并且定位可以消除的不必要操作</li>
<li><code>dtrace/stap/perf</code>: 用来检查包括内核状态在内的应用程序与线路间选中的数据</li>
</ul>
<h2 id="第十一章-云计算-第十二章-基准测试"><a href="#第十一章-云计算-第十二章-基准测试" class="headerlink" title="第十一章 云计算 - 第十二章 基准测试"></a>第十一章 云计算 - 第十二章 基准测试</h2><p>这两章主要介绍相关底层概念，很多时候只是作为选择云服务提供商的依据（毕竟不能自己开发），暂略。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>方法</strong></p>
<ul>
<li>IOPS: 每秒发生的输入/输出操作的次数，是数据传输的一个度量方法。对于磁盘的读写，IOPS 指的是每秒读和写的次数</li>
<li>吞吐量: 评价工作执行的速率，尤其是在数据传输方面，这个术语用于描述数据传输速度。在某些情况下（如数据库），吞吐量指的是操作的速度（每秒操作数或每秒业务数）</li>
<li>响应事件: 一次操作完成的事件。包括用于等待和服务的事件，也包括用来返回结果的时间</li>
<li>延时: 描述操作里用来等待服务的事件。在某些情况下，它可以指的是整个操作时间，等同于响应时间</li>
<li>使用率: 对于服务所请求的资源，使用率描述在所给定的时间区间内资源的繁忙成都。对于存储资源来说，使用率指的就是所消耗的存储容量（例如，内存使用率）</li>
<li>饱和度: 指的是某一资源无法满足服务的排队工作量</li>
<li>瓶颈: 在系统性能力，瓶颈指的是限制系统性能的那个资源。分辨和移除系统瓶颈是系统性能的一项重要工作</li>
<li>工作负载: 系统的输入或者是对系统所施加的负载叫做工作负载。对于数据库来说，工作负载就是客户端发出的数据库请求和命令</li>
<li>缓存: 用于复制或者缓冲一定量数据的高速存储区域，目的是为了避免对较慢的存储层级的直接访问，从而提高性能。</li>
</ul>
<p><strong>操作系统</strong></p>
<ul>
<li>操作系统: 这里指的是安装在系统上的软件和文件，使得系统可以启动和运行程序。操作系统包括内核、管理工具，以及系统库</li>
<li>内核: 内核是管理系统的程序，包括设备（硬件）、内存和 CPU 调度。它运行在 CPU 的特权模式，允许直接访问硬件，称为内核态</li>
<li>进程: 是一个操作系统的抽象概念，是用来执行程序的环境。程序通常运行在用户模式，通过系统调用或陷阱来进入内核模式</li>
<li>线程: 可被调度的运行在 CPU 上的可执行上下文。内核有多个线程，一个进程有一个或多个线程</li>
<li>任务: 一个 Linux 的可运行实体，可以指一个进程（含有单个线程），或一个多线程的进程里的一个线程，或者内核线程</li>
<li>内核空间: 内核的内存地址空间</li>
<li>用户空间: 进程的内存地址空间</li>
<li>上下文切换: 内核程序切换 CPU 让其在不同的地址空间上做操作</li>
<li>系统调用: 一套定义明确的协议，为用户程序请求内核执行特权操作，包括设备 I/O</li>
<li>陷阱: 信号发送到内核，请求执行一段系统程序（特权操作）。陷阱类型包括系统调用、处理器异常以及中断</li>
<li>中断: 由物理设备发送给内核的信号，通常是请求 I/O 服务</li>
</ul>
<h2 id="USE-法-Linux-检查清单"><a href="#USE-法-Linux-检查清单" class="headerlink" title="USE 法 Linux 检查清单"></a>USE 法 Linux 检查清单</h2><p><img src="/images/14835162959625.jpg" alt=""><br><img src="/images/14835163088823.jpg" alt=""><br><img src="/images/14835163208331.jpg" alt=""></p>
<p><strong>软件资源</strong></p>
<p><img src="/images/14835163499443.jpg" alt=""><br><img src="/images/14835163585434.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于性能优化，最大的太占就是性能分析，而性能分析要求我们对于操作系统、网络的性能要了如指掌，明细各个部分的执行时间数量级，做出合理的判断。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://wdxtub.com/categories/Reading/"/>
    
    
      <category term="系统" scheme="http://wdxtub.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="性能" scheme="http://wdxtub.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>2016 的 12 个关键词</title>
    <link href="http://wdxtub.com/2016/12/31/12-keywords-2016/"/>
    <id>http://wdxtub.com/2016/12/31/12-keywords-2016/</id>
    <published>2016-12-31T02:01:40.000Z</published>
    <updated>2017-01-01T09:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>一年之中最幸福的时刻大概是回顾一整年，发现自己成长了不少。整理了一下今年的12个关键词，和去年对比之后发现：一半和过去一样，是为传承；另一半崭新崭新，是为探索。细细想来，我们都是用过去武装自己迈向未来，不断把想象中的将来变成现在的过程，就是人生吧。(沿用去年的开头)</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2017.01.01: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="http://wdxtub.com/2016/12/30/2017-outside-window">2017 年度计划</a> | <a href="http://wdxtub.com/2015/12/30/2016-outside-window/">2016 年度计划</a> | <a href="http://wdxtub.com/2014/12/18/2015-outside-window/">2015 年度计划</a></li>
<li><a href="http://wdxtub.com/2016/12/31/12-keywords-2016/">2016 的 12 个关键词</a> | <a href="http://wdxtub.com/2015/12/31/12-keywords-2015/">2015 的 12 个关键词</a> | <a href="http://wdxtub.com/2014/12/19/12-keywords-2014/">2014 的 12 个关键词</a> | <a href="http://wdxtub.com/2013/12/22/12-keywords-2013/">2013 的 12 个关键词</a></li>
</ul>
<h2 id="年度图片"><a href="#年度图片" class="headerlink" title="年度图片"></a>年度图片</h2><p><img src="/images/2016-keywords.jpg" alt="2016-keywords"></p>
<ul>
<li>左边：在 CMU Porter Hall 的 ECE Lounge 中和 CSAPP 这本对我影响巨大的书的合影。这本书和 15213 这门用它做配套教材的课让我的写作生涯进入了快车道，也因此认识了很多长辈和朋友。贯穿了整个 2016，还会继续影响 2017。</li>
<li>右边：下半年一直在做跟无人机相关的各类工作，从项目经理到架构师再到开发人员做了个遍，直到年末才真正开始『玩』起了无人机，从空中看到了新的自己。</li>
</ul>
<h2 id="年度数据"><a href="#年度数据" class="headerlink" title="年度数据"></a>年度数据</h2><h3 id="累计数据"><a href="#累计数据" class="headerlink" title="累计数据"></a>累计数据</h3><ul>
<li>博客累计日志/评论：<strong>777</strong> 篇 / <strong>985</strong> 条</li>
<li>博客累计访问量/访客数：<strong>312506</strong> 次 / <strong>111635</strong> 人</li>
<li>博客『不周山』板块：<strong>7</strong> 个系列文章</li>
<li>博客『通天塔』板块：<strong>5</strong> 个系列文章</li>
<li>博客『好望角』板块：<strong>4</strong> 个系列文章</li>
<li>博客累计周记：<strong>29</strong> + <strong>17</strong> + <strong>16</strong> = <strong>62</strong> 篇</li>
<li>博客『书影音』板块<ul>
<li>共 <strong>371</strong> 本书的相关书摘书评</li>
<li>共 <strong>9</strong> 篇影评</li>
<li>共 <strong>11</strong> 篇游戏评测</li>
</ul>
</li>
<li>博客收到打赏：<strong>92</strong> 次</li>
<li>豆瓣读书『读过』数量：<strong>1563</strong> 本</li>
<li>豆瓣电影『看过』数量：<strong>46</strong> 部</li>
</ul>
<h3 id="2016-数据"><a href="#2016-数据" class="headerlink" title="2016 数据"></a>2016 数据</h3><p><strong>Github 统计</strong></p>
<p><img src="/images/14832607958173.jpg" alt=""></p>
<ul>
<li>代码仓库：<strong>50</strong> 个</li>
<li>粉丝：<strong>201</strong> 人</li>
<li>关注：<strong>51</strong> 人</li>
</ul>
<p><strong>Keep 统计</strong></p>
<ul>
<li>训练总时长：<strong>3240</strong> 分钟</li>
<li>完成训练：<strong>187</strong> 次</li>
<li>累计消耗：<strong>39210</strong> 千卡</li>
<li>平均训练时长：<strong>27</strong> 分钟</li>
<li>经常训练的时间：<strong>20:00</strong></li>
<li>最长连续打卡：<strong>16</strong> 天</li>
<li>训练等级：T7 / 110 次 / 62 小时</li>
<li>跑步等级：R6 / 77 次 / 333 公里 </li>
</ul>
<p><strong>微博统计</strong></p>
<ul>
<li>2016 发布微博/被阅读：<strong>1350</strong> 条 / <strong>368.7</strong> 万次</li>
<li>2016 被转发/评论/点赞：<strong>2705</strong> 次 / <strong>1093</strong> 次 / <strong>4366</strong> 次</li>
<li>关注/粉丝/微博总数：<strong>736</strong> 关注 / <strong>3209</strong> 粉丝 / <strong>9915</strong> 条</li>
</ul>
<p><strong>知乎统计</strong></p>
<ul>
<li>登录：<strong>324</strong> 天</li>
<li>浏览页面：<strong>54878</strong> 个</li>
<li>发布回答：<strong>6</strong> 篇</li>
<li>收到赞同/感谢：<strong>282</strong> / <strong>73</strong> 个</li>
<li>被收藏：<strong>200</strong> 次</li>
<li>发出赞同/评论：<strong>78</strong> / <strong>42</strong> 个</li>
<li>新关注：<strong>70</strong> 人</li>
<li>新增关注者：<strong>688</strong> 人</li>
</ul>
<p><strong>新增装备</strong></p>
<ul>
<li>iPhone7 / iPhone 6s Plus</li>
<li>Sony A7M2</li>
<li>PS4</li>
</ul>
<h2 id="【转换】"><a href="#【转换】" class="headerlink" title="【转换】"></a>【转换】</h2><p>『转换』这个关键词和去年一样，虽然生活是连续而非离散的，但是偶尔的剧烈震荡仍然让我心潮澎湃。</p>
<ul>
<li>从校园到社会的转换，让我明白了在学校所学知识的局限。开始接触社会总是有些不适应，无论是待人接物，还是临场应变，都有很多需要学，需要提高的地方。</li>
<li>从国外到国内的转换，让我重新去审视这片我曾经生活过二十多年的土地，才发现在这样一个『启蒙时代』，有太多太多让年轻人大展宏图的机会。</li>
<li>从博客爱好者到作者的转换，让我严肃去思考写作这件事儿，在计算机教育领域还有很多值得探索的领域，我也在摸爬滚打中学着去写一本书。</li>
</ul>
<p>正义之子面对有悖于常理的世界，会使其天翻地覆</p>
<h2 id="【内聚】"><a href="#【内聚】" class="headerlink" title="【内聚】"></a>【内聚】</h2><p>由去年的『极简』变成今年的『内聚』。自己的内核逐渐成型，但时不时依旧内核恐慌(Kernel Panic)。</p>
<ul>
<li>建立了属于自己的工作生活学习的闭环，不再去做任何投机取巧的事情，就用『笨』办法一步一个脚印踏踏实实往前走。</li>
<li>自我在慢慢成长，甚至变得有些过分坚硬，虽然刀枪不入，但静静想来，也有点残酷无情。刚体容易出现不可逆的结构性损伤，所以还是要加点弹性，方能百折不挠。</li>
<li>把从前分散在各处的能量汇聚在一起，明白了要如何去学习思考，如何去探索发现，如何去交流沟通，如何去传播分享，如何像男子汉一样面对风雨，如何去决定自己未来的路。</li>
</ul>
<p>我的内部世界构建基本完成，内核稳定，即使出现意外情况也能快速恢复。正所谓帅的人在做自己该做的事情，丑的人在逃避自己该做的事情。</p>
<h2 id="【独立】"><a href="#【独立】" class="headerlink" title="【独立】"></a>【独立】</h2><p>由去年的『自立』变成今年的『独立』。我开始独自面对生活中的各种选择，并为之负责，在关键和不关键的时刻都不掉链子。</p>
<ul>
<li>在校园里平衡了生活与学习，在超额完成学习任务的前提下，尽可能去探索了生活中的其他可能性。有一些遗憾，但好在并不是无法弥补的。</li>
<li>医保社保公积金信用卡各种卡都有了自己的账户，和各行各业的人开始打交道。</li>
<li>工作中随着对业务和公司情况的了解，有了自己的想法和计划，并能通过自己的努力把事情推进好。</li>
</ul>
<p>翅膀慢慢坚硬了起来，人生慢慢张开，知道自己想要去的地方，剩下的就是勇往直前了。</p>
<h2 id="【朋友】"><a href="#【朋友】" class="headerlink" title="【朋友】"></a>【朋友】</h2><p>『朋友』这个关键词和去年一样，不同的是，因为博客越来越多人了解，认识很多来自各行各业的朋友。</p>
<ul>
<li>有的是微博上久闻大名，有的是因缘际会的校友，有的是神交已久但第一次相见的书友。</li>
<li>因为工作的缘故，认识了不少业界的朋友，作为职场新人，在老司机身上还是学到了很多东西</li>
<li>在年末还是抽时间跑了几个城市见了不少朋友，既然是在意的羁绊，就应该去努力维护。</li>
</ul>
<p>好朋友的意义在于让我意识到自己即使孤单一人也并不应该感到孤独，毕竟有大家在后面『顶』我呢。</p>
<h2 id="【思考】"><a href="#【思考】" class="headerlink" title="【思考】"></a>【思考】</h2><p>由去年的『阅读』与『写作』合并变成今年的『思考』。我迈上了新的台阶，从输入到输出这之间的转化质量有了极大提高。</p>
<ul>
<li>开始从更长远的角度去考虑问题和制定计划了。做事情有目标，有计划，也有评判标准和紧急情况备案了。</li>
<li>从最初的摘抄积累到拾人牙慧，慢慢有了自己的想法像是和作者跨越时间空间讨论着，无论是辨析力和判断力，都有了很大的提高。能够用淡定代替焦虑，或者说，会更加理智用思考去代替本能，因为很多时候本能并不太靠谱。</li>
<li>在工作中能够从不同的角色和位置去思考项目本身所能提供的价值和应该起到的做用，避免了很多无谓的浪费，形成了自己的评判标准，不会迷信权威。</li>
</ul>
<p>人工智能将取代的是那些思维强度太低的人，最好的做法就是多读多写多思考，人类在推动技术发展的同时，技术也在引导着人类进步的方向，跟不上时代的注定要淘汰，物竞天择，优胜劣汰。</p>
<h2 id="【创造】"><a href="#【创造】" class="headerlink" title="【创造】"></a>【创造】</h2><p>『创造』是今年新增的关键词，从写作出发，历经几年的锤炼，终于意识到自己所能创造的东西。写作不是人生，但可能是一条重回人生的路径。</p>
<ul>
<li>个人博客终于发布了 Beta 版，把所有的文章归于三大系列，打造个人品牌进入新阶段。所有看起来很酷的东西一开始都是简陋慌张的，但是只要坚持，一定会慢慢成长起来的。</li>
<li>因为是第一次写书，所以在各种尝试中走了不少弯路，好在最终还是找到了属于自己的风格与方向，虽然会延期，但应该能够高质量完成写作。</li>
<li>播客节目和视频计划已经完成前期的筹备，从各种节目中取经，应该经过几期的尝试，可以做出不错的节目。</li>
</ul>
<p>工作之余努力把自己打造成一个创意工作者，我心目中的跨界是一定是要结合科学精神与人文态度的，两手都要抓两手都要硬。</p>
<h2 id="【探索】"><a href="#【探索】" class="headerlink" title="【探索】"></a>【探索】</h2><p>『探索』这个关键词和去年一样，合并了之前的『旅行』关键词。喜欢什么，讨厌什么，擅长什么，拙于什么，都应该在不同的体验中增进对自己的了解。</p>
<ul>
<li>综合自己的实践经验和习惯拿出了 W.I.S.E. 计划并完成了前期的技术调研，确定了年度工作计划，今后技术和理论上的探索都会围绕这个框架进行。</li>
<li>重拾了剪报这个爱好，虽然现在是以数字化的形式进行</li>
<li>开始学习摄影和航拍，尝试用镜头表达自己的想法</li>
</ul>
<p>探索的过程中总会需要问题，很多时候朝着问题笔直前进并不是最好的做法，最好是绕到问题背后去弄清楚问题的来源。通过问题本身来观察自己的思维模式还有哪些误区和盲点。问题是解决不完的，但是思维体系是可以逐渐完善的，有了一整套观察问题，思考问题，解决问题的框架，那么大部分问题就不是问题了，小部分问题就是给自己这套框架升级换代的问题了。</p>
<h2 id="【坚持】"><a href="#【坚持】" class="headerlink" title="【坚持】"></a>【坚持】</h2><p>『坚持』是今年新增的关键词，坚持写周记，坚持读书，坚持写作，坚持跑步。每次都选择正确的事做很难，不如直接做自己喜欢做的事情（压根不需要选择了），然后坚持到它成为正确的事情。</p>
<ul>
<li>前半年的校园周记和后半年的工作周记使得自己每周都要总结和思考自己的生活，一直在鞭策自己前进。</li>
<li>跑步的配速达到了四分三十秒之内了，比大学和研究生的时候每公里都快了一分多钟。</li>
<li>读了不少经典教材和一些比较难啃的书，感觉自己对专业的理解进入到了更加成熟的阶段。</li>
</ul>
<p>制定目标 -&gt; 努力训练 -&gt; 坚持不懈 -&gt; 最终突破，这其实是非常靠谱的成长方式。坚持本身并不轻松甚至有些痛苦，但是能够体验从一开始的斗志满满到临近极限的艰难再到突破自己的喜悦。不由得想，原地踏步的人看不到新的风景，眼里只有终点的人无暇欣赏一路的风景，只有方向坚定但是又不拘泥于此的人才能真正享受探索和发现的旅程。</p>
<h2 id="【修行】"><a href="#【修行】" class="headerlink" title="【修行】"></a>【修行】</h2><p>『修行』是今年新增的关键词，无论是身与心都以更严格的标准在努力修行。</p>
<ul>
<li>技术上不再拘泥于一行代码一个函数一个模块甚至是一个项目，开始以更长远的角度去思考技术的意义，并在不断的实践中积攒自己的悟性。</li>
<li>生活上更多时候会选择顺其自然的态度，得与失喜与悲其实都是很宝贵的体验，从中汲取到些许养分就已足够</li>
<li>精神上更加可以接受不同的观点和态度，遇到事情第一时间不是慌张而是极端冷静，甚至我都不太清楚为什么会发生这样的转变。</li>
</ul>
<p>用修行的心态去度过每一分每一秒，看待自己和观察世界的角度就完全不一样了，基本上不会有空虚和无聊的时刻。</p>
<h2 id="【边界】"><a href="#【边界】" class="headerlink" title="【边界】"></a>【边界】</h2><p>『边界』是今年新增的关键词，走入社会之后才意识到边界的重要性，所谓游刃有余，就是模棱两可的区域足够少之后所达到的境界。</p>
<ul>
<li>真正知道自己想要什么的人，不存在打工还是创业，重点在于做事情。想做的事情，有人在做，自己也认同这个方向，那么就一起做；如果没人在做，那就弄到所需的资源，然后自己做，接着吸引更多志同道合的人来做。</li>
<li>不喜欢抱团凑一起，不喜欢时时事事都瞻前顾后，不喜欢『乖孩子』的生活，经过一年的调整，终于在两边找到了合适的界限。</li>
<li>更加尊重自己的时间和精力，放弃了大部分仪式性的无谓社交，什么事该过问，什么人该关心都有了自己的评判标准。</li>
</ul>
<p>最难处理的大约是在边界附近的范围，很容易一着不慎满盘皆输。所以还是要努力站得更高看得更清晰，不要陷入在局部最优里不可自拔。</p>
<h2 id="【挣扎】"><a href="#【挣扎】" class="headerlink" title="【挣扎】"></a>【挣扎】</h2><p>『挣扎』是今年新增的关键词，因为环境的巨大变化，困难和不安的时刻都多了许多，我高兴的是在不断地挣扎中又找回了平衡，有了抗体。</p>
<ul>
<li>看到势，找到自己的势头，以此为起点，去尝试任何可能有裨益的事情。对于年轻人来说，不变才是最可怕的。</li>
<li>信心是人的视力，把目光放远点，再远一点，真的会影响到当下的选择。当我看得足够远，就知道如何按照自己的想法，通过不懈努力，去塑造想要的未来。</li>
<li>工作中动力大于压力，喜悦大于焦虑，逼着自己快速学习快速成长，同时可以尽情施展自己的才华天赋。</li>
</ul>
<p>多挣扎几次之后就会发现，其实挣扎本身也是有很多门道的，这就是为什么有的人总是可以化险为夷，而有的人就只能望洋兴叹了。于我，矛盾与冲突是机会，要善于置死地而后生。</p>
<h2 id="【感情】"><a href="#【感情】" class="headerlink" title="【感情】"></a>【感情】</h2><p>『感情』这个关键词和去年一样，历经了起起伏伏，有快乐也有悲伤，但终究是在『人性』化的道路上迈出了坚实的一步。</p>
<ul>
<li>类似新海诚的系列电影，从秒速五厘米到言叶之庭到最新的你的名字，终于学会了放过自己。</li>
<li>类似卢冠廷的如风往事，就算失落过，都不想变改往事，因那所有的旧事，烙印在现在的我。</li>
<li>类似廖一梅的恋爱的犀牛，希望看过戏的观众，能感到在他的生命中有一些东西是值得坚持，可以坚持的。 至于爱情的结局不是这个戏里所关心的。</li>
</ul>
<p>生离死别让人痛苦，但有的时候正是这样的痛苦提醒自己，要为了昨天今天明天更努力一些。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>至于为什么关键词里没有家人，因为家人是永远的关键词！爸爸妈妈，我爱你们！</p>
<p>南非前总统曼德拉曾经说：“如果你隐藏自己，不敢让别人看到你如何做自己喜欢的事，别人就会认为，他们也不能做到。但如果你让他们看见，就等于允许他们像你一样去做自己喜欢的事，就等于解放了他们的愿望。这并不是说要让他们去做和你一样的事，而是让每一个都做最适合自己、自己最希望做的事。”(这一段同样是借用去年的)</p>
<p>再见！2016！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年之中最幸福的时刻大概是回顾一整年，发现自己成长了不少。整理了一下今年的12个关键词，和去年对比之后发现：一半和过去一样，是为传承；另一半崭新崭新，是为探索。细细想来，我们都是用过去武装自己迈向未来，不断把想象中的将来变成现在的过程，就是人生吧。(沿用去年的开头)&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="总结" scheme="http://wdxtub.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2016" scheme="http://wdxtub.com/tags/2016/"/>
    
  </entry>
  
  <entry>
    <title>2017 年度计划</title>
    <link href="http://wdxtub.com/2016/12/30/2017-outside-window/"/>
    <id>http://wdxtub.com/2016/12/30/2017-outside-window/</id>
    <published>2016-12-30T15:11:25.000Z</published>
    <updated>2016-12-31T02:07:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>上士闻道，勤而行之。现在才慢慢意识到给自己的一年定下量化计划是多么重要的事情。2017 年的核心目标依然是全面提高自己，机遇和挑战都会很多，希望自己能带着禅者的初心一路向前。</p>
<a id="more"></a>
<hr>
<p>更新历史</p>
<ul>
<li>2016.12.31: 完成初稿</li>
</ul>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="http://wdxtub.com/2016/12/30/2017-outside-window">2017 年度计划</a> | <a href="http://wdxtub.com/2015/12/30/2016-outside-window/">2016 年度计划</a> | <a href="http://wdxtub.com/2014/12/18/2015-outside-window/">2015 年度计划</a></li>
<li><a href="http://wdxtub.com/2016/12/31/12-keywords-2016/">2016 的 12 个关键词</a> | <a href="http://wdxtub.com/2015/12/31/12-keywords-2015/">2015 的 12 个关键词</a> | <a href="http://wdxtub.com/2014/12/19/12-keywords-2014/">2014 的 12 个关键词</a> | <a href="http://wdxtub.com/2013/12/22/12-keywords-2013/">2013 的 12 个关键词</a></li>
</ul>
<h2 id="2017-计划"><a href="#2017-计划" class="headerlink" title="2017 计划"></a>2017 计划</h2><p>2016 年完成了从校园到社会的转换，经过半年的适应，2017 应该是火力全开的一年，希望自己能够一步一个脚印，继续敢打敢拼，毕竟年轻就是最大的资本。根据这个原则，新年愿望，贪心一点，12 条。和去年不同的是，今年用更加具体的量化指标来代替模糊性描述，给自己一些 KPI。</p>
<ol>
<li>健身，体重维持在 66kg（『瘦身旅程』记录），跑 600 公里（大约 150 次，打卡记录），每公里配速达到 4分30秒（『Keep』记录），继续和小肚子搏斗。</li>
<li>找到自己在社会上的定位，做成至少 2 个项目</li>
<li>围绕 W.I.S.E. 这个产品做持续跨界学习（在 Github 上记录），至少上线 3 个领域，如：数据挖掘、教育、数学、概率统计、机器学习、云计算</li>
<li>个人品牌打造，博客达到 100W 访问量，播客制作至少 6 期，公众号、微博、知乎要尝试着自己运营一下（暂时不以粉丝数量来衡量，还是简单摸索一下）</li>
<li>带着无人机旅行至少 3 次（需要配合有游记及视频）</li>
<li>多读书，读经典，不少于 48 本</li>
<li>多写作，用笔带动思考，不少于 96 篇</li>
<li>学 1 种新乐器，学会演奏 3 首歌曲</li>
<li>广结良缘，认识至少 24 个新朋友（可以配合播客，了解不同领域） </li>
<li>写完至少 1 本书</li>
<li>通关 6 款大型游戏（奖杯和评测一个都不能少）</li>
<li>好好开始一段感情，找个靠谱女朋友（同 2016）</li>
</ol>
<h2 id="2016-的愿望及完成情况"><a href="#2016-的愿望及完成情况" class="headerlink" title="2016 的愿望及完成情况"></a>2016 的愿望及完成情况</h2><ol>
<li>减脂增肌塑性，针对不同的运动项目进行练习，速度、反应、平衡、爆发都应该考虑在内<ul>
<li>【完成】工作之后跑步 77 次，总距离 332.54 公里，平均配速 5’17，最远距离 13.14 公里</li>
</ul>
</li>
<li>知识架构，继续完善配套的工具集和工作流程，目标是打造信息自由流动的闭环<ul>
<li>【完成】闭环已经基本完成，也有了计划中的产品 W.I.S.E.</li>
</ul>
</li>
<li>旅行，到处走走看看，多留下些回忆<ul>
<li>【完成】路过过美国不少城市，去了华盛顿、纽约、大瀑布、湾区、西雅图</li>
</ul>
</li>
<li>读书，多读经典，往更深更广的方向努力<ul>
<li>【完成】把计算机经典书籍基本上刷完了</li>
</ul>
</li>
<li>写作，用笔带动思考，思考得越深入，看得越远<ul>
<li>【完成】博客已经进入了产品化阶段，三大板块初具规模</li>
</ul>
</li>
<li>个人品牌打造，重新维护公众号，有机会在知乎答答题，扩大自己微博的影响力，让更多人知道我的博客<ul>
<li>【完成】微博粉丝 3100+，博客访问量达 30W</li>
</ul>
</li>
<li>语言能力，表达和沟通的效率和准确度，不仅仅是中文，更要在英文上多多努力<ul>
<li>【完成】无论是写作还是说话，给我一点时间都能吐一点点象牙了</li>
</ul>
</li>
<li>音乐积累，多多涉猎，了解各种流派的基本知识，培养一定的鉴赏能力<ul>
<li>【挑战失败】心有余而力不足，朋友送了我一把尤克里里，是时候了？</li>
</ul>
</li>
<li>尝试新领域，结交新朋友，体验新东西<ul>
<li>【完成】开始写影评了，扩展了写作的范围，在年末开启了新的航拍 + 播客方向</li>
</ul>
</li>
<li>勇于承担更大的责任，工作上独当一面，生活中独立自主，为父母分担压力，做一个靠谱的朋友<ul>
<li>【完成】可以养活自己，开始摸索扩张，为家里出一份力，为朋友义字当头</li>
</ul>
</li>
<li>观察能力，了解天下大势，培养敏锐嗅觉，学会从不同角度看问题<ul>
<li>【挑战失败】世界好大，我的小心脏还需要一些时间适应</li>
</ul>
</li>
<li>好好开始一段感情，找个靠谱女朋友<ul>
<li>【挑战失败】快到碗里来!!!</li>
</ul>
</li>
</ol>
<p>注，更详细的年度总结在 <a href="http://wdxtub.com/2016/12/31/12-keywords-2016/">2016 的 12 个关键词</a> 一文中</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上士闻道，勤而行之。现在才慢慢意识到给自己的一年定下量化计划是多么重要的事情。2017 年的核心目标依然是全面提高自己，机遇和挑战都会很多，希望自己能带着禅者的初心一路向前。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://wdxtub.com/categories/Life/"/>
    
    
      <category term="计划" scheme="http://wdxtub.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="新年" scheme="http://wdxtub.com/tags/%E6%96%B0%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>第二十九周 - 长路漫漫任我闯</title>
    <link href="http://wdxtub.com/2016/12/30/long-way-to-go/"/>
    <id>http://wdxtub.com/2016/12/30/long-way-to-go/</id>
    <published>2016-12-30T11:26:16.000Z</published>
    <updated>2016-12-30T12:38:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>长路漫漫伴你闯，带一身胆色与热肠。投入命运万劫火，那得失怎么去量。驰马闯江湖，谁为往事再紧张！</p>
<a id="more"></a>
<hr>
<p>2016 终于猴不停蹄走到了终点，周记系列也来到了今年的最后一周了。简单看一眼数字，居然也一路写了二十九周了。那么问题来了，下一周算第三十周还是第一周呢？</p>
<p>马上就是元旦假期了，虽然这周天气忽然转冷，不过还是跑了两天步，可惜刚从上海和南京奔波回来，体能储备基本都见底了，就算是恢复训练吧。名义上是旅行，实际上更多是去见朋友，有老同学，有老邻居，也有第一次面对面的『网友』，时不时出去走走看是拓宽眼界和思路最好的方式，更何况我还带了无人机，能从空中观察这个世界呢。</p>
<p>航拍是非常有意思的事情，拍摄的维度一下拓展了一维，还真有点不适应。但哪怕是最简单的空中环绕飞行拍摄，就已经足够高大上了。飞着飞着我忽然明白为什么刚来公司的时候二老板要让我多去飞飞机，只有真正去飞那么几个小时，才能真正体会到个中奥妙。等现在在做的项目彻底做完之后，想要去做一些真正有意思的事情。</p>
<p>休假后回到工作岗位后被告知下周老板要看这个项目的进展，虽然核心的功能已经基本稳定，但是作为一个产品，还是有许多需要打磨的地方，于是我仿佛回到了当年一个人开发英雄联盟百科时的日子，不断 ship 各种 feature（在微软的时候我和小伙伴经常是这么描述自己的工作的）。回想当初，一个人断断续续开发英雄联盟百科，其实核心功能几周就写完了，但是真正把产品打磨到获得官方推荐，用了超过 12 个月的时间。虽然早已停止开发，不过时不时还是会收到来自世界各地的反馈邮件，还知道自己的东西有人在用着。人嘛总要想点办法留下点痕迹，我很开心当初把一个随手开发的小应用打造成了完整的产品，相比现在动辄三四十人的大团队，当年我一个人就吭哧吭哧得到了官方应用商店的认可，想想还有点小自豪。</p>
<p>现在在做的是一个数据产品，最重要的要求是数据和逻辑的绝对精确（需要精确到 0.00001）。原先做数据平台的时候因为很多数据是通过应用上报的，本身就存在一定误差（也没办法精确审计核算），所以只要保证服务稳定，数据不过分异常即可。为了把数据对上，可真是费了九牛二虎之力，不过也因此过了一遍整个数据处理流水线，这其实是很好的锻炼。从数据源、预处理到最后的统计，从基础逻辑、公式定义和具体实现，这一切的一切都是一个一个坑踩出来的。说个数字，这两周大概发了 80 个版本，居然能在满足各种临时要求的情况下完善整个系统，感觉我的编程能力已经恢复到了历史巅峰水平。但是现在设计+前端+后端+测试+质量保证都得我做，真的是分身乏术，感觉身体被掏空。好在老大已经给了指标，明年一定要招几个靠谱的小伙伴一起来搞点事情。</p>
<p>因为是老板亲自盯的项目，有些看似科学但实际上不太合理的既要马儿跑又要马儿不吃草的需求让团队很为难。要我说，老板可以给出一些方向的指引，但不要过多参与具体实现，不然又当运动员又当裁判，做好了当然皆大欢喜，但是做糟了，我们总不能说是老板的锅吧，这样的事情发生几次对团队的士气就是极大的打击了。不过说到底还是一个沟通问题，我现在在做的项目大家的沟通还不错，希望不要随着项目进入最后的收成阶段演化成上面所说的状况。</p>
<p>最近被吐槽颇多的以『长城』为首的国产『烂』片纵队所引发的新闻着实让人难以释怀。在我看来，张艺谋的『长城』其实并没有想象中那么糟，对于一部以试水中外合作为主要目的的商业大片，具体靠不靠谱还要看明年 2 月在北美上映的票房。但其他几部几十部烂片，真的是烂，尤其是各类以小鲜肉为卖点主演的电影，真的是欺负粉丝没有审美了。不过按照中国电影现在所处的阶段，这种乱七八糟其实是不可避免的，品位需要慢慢培养，这不，还是有一些有追求的国产电影的（点名表扬『驴得水』『湄公河行动』和『罗曼蒂克消亡史』），只是希望明年这样的店名表扬能来得再多一点。</p>
<p>真正的创作者会很早意识到根本没有什么捷径，找几个小鲜肉瞎拍固然可以骗骗脑残粉的钱，但一直脑残的人不会是大多数，傻子不够用了怎么办呢？拿我自己来说，学习写作没有任何捷径，就是多读和多写。</p>
<p>虽然没有捷径，但是我们依然可以多思考多琢磨怎么能走得更快更有效率一些，老是重复自己的过往，多没意思。</p>
<p>感谢读过我周记的每一位读者，希望我的经历和想法能让大家有一些感触和共鸣。关于 2016 还有很多想说的话，就放在年末的总结与展望里吧！周记系列就跟大家明年再见咯，2016 完结撒花！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;长路漫漫伴你闯，带一身胆色与热肠。投入命运万劫火，那得失怎么去量。驰马闯江湖，谁为往事再紧张！&lt;/p&gt;
    
    </summary>
    
      <category term="Gossip" scheme="http://wdxtub.com/categories/Gossip/"/>
    
    
      <category term="周记" scheme="http://wdxtub.com/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="工作" scheme="http://wdxtub.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
</feed>
